---
layout: default
title: "Dart Language Specification (0.08)"
description: "A work in progress: The official specification of the Dart language"
---


<title> {{page.title }} </title>
<style type="text/css">
      body {
        font-family: arial, sans, sans-serif;
        margin: 0;
      }

      #header, #footer {
        display: none;
      }

      #contents p {
        margin-bottom: 0px;
      }

    </style></head><body><div id="header">Dart Language Specification (0.08)</div><div id="contents"><style type="text/css">@import url('https://themes.googleusercontent.com/fonts/css?kit=IWRdB3j7Gqf1AhWJ7xAYR5RBQ_iWzNKgurkYl3DhUt15CYSsO0-Wr64DAcNttXj0');ol{margin:0;padding:0}p{margin:0}.c34{list-style-type:circle;margin:0;padding:0}.c25{list-style-type:disc;margin:0;padding:0}.c0{color:#1155cc;font-style:italic;text-decoration:underline}.c26{list-style-type:decimal;margin:0;padding:0}.c12{color:#0000ff;font-size:12pt;background-color:#ffffff}.c1{color:#000099;text-decoration:underline}.c7{padding-left:0pt;margin-left:36pt}.c20{padding-left:0pt;margin-left:72pt}.c8{color:inherit;text-decoration:inherit}.c37{max-width:468pt;padding:72pt 72pt 72pt 72pt}.c13{color:#0000ff;text-decoration:underline}.c10{color:#1155cc;text-decoration:underline}.c33{color:#0000cc;text-decoration:underline}.c39{font-size:10pt;background-color:#e9f6ff}.c21{color:#274e13}.c32{color:#0c343d}.c9{vertical-align:sub}.c23{margin-left:72pt}.c5{font-weight:bold}.c28{color:#666666}.c30{font-size:14pt}.c16{background-color:#ffffff}.c38{font-size:9pt}.c2{direction:ltr}.c36{margin-left:90pt}.c27{color:#8e7cc3}.c4{height:11pt}.c35{text-indent:36pt}.c17{margin-left:54pt}.c24{font-size:12pt}.c31{margin-left:18pt}.c29{color:#6aa84f}.c18{font-size:7pt}.c11{color:#38761d}.c3{font-style:italic}.c19{color:#ff0000}.c14{color:#0000ff}.c6{font-family:Tahoma}.c22{text-align:center}.c15{margin-left:36pt}.title{padding-top:24pt;line-height:1.15;text-align:left;color:#000000;font-size:36pt;font-family:Arial;font-weight:bold;padding-bottom:6pt}.subtitle{padding-top:18pt;line-height:1.15;text-align:left;color:#666666;font-style:italic;font-size:24pt;font-family:Georgia;padding-bottom:4pt}body{color:#000000;font-size:11pt;font-family:Arial}h1{padding-top:24pt;line-height:1.15;text-align:left;color:#000000;font-size:24pt;font-family:Arial;font-weight:bold;padding-bottom:6pt}h2{padding-top:18pt;line-height:1.15;text-align:left;color:#000000;font-size:18pt;font-family:Arial;font-weight:bold;padding-bottom:4pt}h3{padding-top:14pt;line-height:1.15;text-align:left;color:#000000;font-size:14pt;font-family:Arial;font-weight:bold;padding-bottom:4pt}h4{padding-top:12pt;line-height:1.15;text-align:left;color:#000000;font-size:12pt;font-family:Arial;font-weight:bold;padding-bottom:2pt}h5{padding-top:11pt;line-height:1.15;text-align:left;color:#000000;font-size:11pt;font-family:Arial;font-weight:bold;padding-bottom:2pt}h6{padding-top:10pt;line-height:1.15;text-align:left;color:#000000;font-size:10pt;font-family:Arial;font-weight:bold;padding-bottom:2pt}</style><div><p class="c2 c4"><span></span></p></div><h1 class="c2 c22"><a name="h.jpubrpygof4i"></a><span>The Dart Programming Language Specification (0.08)</span></h1><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><p class="c2 c22"><span class="c5 c30">The Dart Team</span></p><hr style="page-break-before:always;display:none;"><p class="c2 c4 c22"><span class="c5 c30"></span></p><p class="c2 c4 c22"><span class="c5 c30"></span></p><p class="c2 c31"><span class="c10"><a class="c8" href="#h.jpubrpygof4i"></a></span></p><p class="c23 c2"><span class="c10"><a class="c8" href="#h.jn6bj1irtqj1">Licensing</a></span></p><p class="c23 c2"><span class="c10"><a class="c8" href="#h.t4es9cmzw059">Changes</a></span></p><p class="c2 c36"><span class="c10"><a class="c8" href="#h.e8xxgwjgzpjc">Changes Since Version 0.02</a></span></p><p class="c2 c36"><span class="c10"><a class="c8" href="#h.68dpyt5nyl5z">Changes Since Version 0.03</a></span></p><p class="c2 c36"><span class="c10"><a class="c8" href="#h.squ00fhhd653">Changes Since Version 0.04</a></span></p><p class="c2 c36"><span class="c10"><a class="c8" href="#h.ulrk584ahfkg">Changes Since Version 0.05</a></span></p><p class="c2 c36"><span class="c10"><a class="c8" href="#h.bkbuva4b219u">Changes since Version 0.06</a></span></p><p class="c2 c36"><span class="c10"><a class="c8" href="#h.rbsrz7603b1n">Changes since Version 0.07</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.e59lyipdamf1">Notation</a></span></p><p class="c2 c15"><span class="c10"><a class="c8" href="#h.p51fkz19s0b2">Overview</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.jb82efuudrc5">Scoping</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.9oi5o1gdzoe8">Privacy</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.a21lfdy211x8">Concurrency</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.n3lq43t151ad">Errors and Warnings</a></span></p><p class="c2 c15"><span class="c10"><a class="c8" href="#h.55kzc4r0q21p">Variables</a></span></p><p class="c2 c15"><span class="c10"><a class="c8" href="#h.kt174mfrzv4a">Functions</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.yntwge6nalyc">Function Declarations</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.1ng1g7im8ubk">Formal Parameters</a></span></p><p class="c23 c2"><span class="c10"><a class="c8" href="#h.co9rbd1pkdlm">Positional Formals</a></span></p><p class="c23 c2"><span class="c10"><a class="c8" href="#h.lqef8gma6oso">Named Optional Formals</a></span></p><p class="c23 c2"><span class="c10"><a class="c8" href="#h.ejzzw7tu534b">Type of a Function</a></span></p><p class="c2 c15"><span class="c10"><a class="c8" href="#h.ed5f44k6gfp">Classes</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.ze2p6bhp40it">Instance Methods</a></span></p><p class="c23 c2"><span class="c10"><a class="c8" href="#h.csqy2h5zh7b0">Abstract Methods</a></span></p><p class="c23 c2"><span class="c10"><a class="c8" href="#h.8z01vn73qf90">Operators</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.semn73yhmkb5">Getters</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.xn3nrcf01kbi">Setters</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.dikrs7svwb70">Instance Variables</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.500yt9xvog42">Constructors</a></span></p><p class="c2 c23"><span class="c10"><a class="c8" href="#h.flm5xvbwhs6u">Generative Constructors</a></span></p><p class="c2 c36"><span class="c10"><a class="c8" href="#h.mnfuvjel4wl1">Redirecting Constructors</a></span></p><p class="c2 c36"><span class="c10"><a class="c8" href="#h.7ybyo5btajop">Initializer Lists</a></span></p><p class="c23 c2"><span class="c10"><a class="c8" href="#h.1t7lgvdmbwt9">Factories</a></span></p><p class="c23 c2"><span class="c10"><a class="c8" href="#h.gk4elj1gohb4">Constant Constructors</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.i641x57pmqjt">Static Methods</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.1k2j0ywtrfjj">Static Variables</a></span></p><p class="c23 c2"><span class="c10"><a class="c8" href="#h.yl719jqc1vh1">Evaluation of Static Variable Getters</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.7crfigeelg47">Superclasses</a></span></p><p class="c23 c2"><span class="c10"><a class="c8" href="#h.n9p3c8rq84d5">Inheritance and Overriding</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.pbz42oyr5t19">Superinterfaces</a></span></p><p class="c2 c15"><span class="c10"><a class="c8" href="#h.l2scqcqw64rv">Interfaces</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.m5evou6f8tgl">Methods</a></span></p><p class="c23 c2"><span class="c10"><a class="c8" href="#h.rnrc3kvf8xpl">Operators</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.dkjessmm6dxp">Getters and Setters</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.v7d57wsbsfo">Factories and Constructors</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.6njjvzks70uf">Superinterfaces</a></span></p><p class="c23 c2"><span class="c10"><a class="c8" href="#h.n9p3c8rq84d5">Inheritance and Overriding</a></span></p><p class="c2 c15"><span class="c10"><a class="c8" href="#h.dkzw3xyky3rs">Generics</a></span></p><p class="c2 c15"><span class="c10"><a class="c8" href="#h.dz8ekoegseec">Expressions</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.9asvt38phduq">Constants</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.gianetx6ltsy">Null</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.ofa8cxlvo8lw">Numbers</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.jitw991wrmh5">Booleans</a></span></p><p class="c23 c2"><span class="c10"><a class="c8" href="#h.qoglfpvek4rj">Boolean Conversion</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.fp52o176rzde">Strings</a></span></p><p class="c23 c2"><span class="c10"><a class="c8" href="#h.us5hu2wpthk4">String Interpolation</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.aj7d3xqsd3m5">Lists</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.1f7gnk1hnxaz">Maps</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.w0k5ugtz3rpv">Function Expressions</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.a02n00oljphq">This</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.seezxc7foicl">Instance Creation</a></span></p><p class="c23 c2"><span class="c10"><a class="c8" href="#h.twiod7rqtbah">New</a></span></p><p class="c23 c2"><span class="c10"><a class="c8" href="#h.kk36x2av9f7f">Const</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.w9xbbkh4rog6">Spawning an Isolate</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.b7g4ujn98rce">Property Extraction</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.y92yhnm0wxy7">Function Invocation</a></span></p><p class="c23 c2"><span class="c10"><a class="c8" href="#h.3tizygdkqnej">Actual Argument List Evaluation</a></span></p><p class="c23 c2"><span class="c10"><a class="c8" href="#h.edxvczd1cw0f">Binding Actuals to Formals</a></span></p><p class="c23 c2"><span class="c10"><a class="c8" href="#h.o9n2pv4hceh1">Unqualified Invocation</a></span></p><p class="c23 c2"><span class="c10"><a class="c8" href="#h.5l8tud6ne77w">Function Expression Invocation</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.mwjqhj0r8mr">Method Invocation</a></span></p><p class="c23 c2"><span class="c10"><a class="c8" href="#h.bq7ggoshcofg">Ordinary Invocation</a></span></p><p class="c23 c2"><span class="c10"><a class="c8" href="#h.30hsq2v14fk2">Cascaded Invocations</a></span></p><p class="c23 c2"><span class="c10"><a class="c8" href="#h.jwevbcchdb5f">Static Invocation</a></span></p><p class="c23 c2"><span class="c10"><a class="c8" href="#h.x8qjjxmvmrg9">Super Invocation</a></span></p><p class="c23 c2"><span class="c10"><a class="c8" href="#h.4d637niex9m0">Sending Messages</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.qnxio27bibb">Getter Invocation</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.wkwl6fs6jml0">Assignment</a></span></p><p class="c23 c2"><span class="c10"><a class="c8" href="#h.ctjzifgzeqep">Compound Assignment</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.fpalvmah8gsn">Conditional</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.33dew20hjpt">Logical Boolean Expressions</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.gxkncuzhsd9x">Bitwise Expressions</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.5kdfq4b9vyr1">Equality</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.fmzbyxz4ly1c">Relational Expressions</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.jmq7bvufo5ez">Shift</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.7hq9zn6blrwm">Additive Expressions</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.uofn135f1hb3">Multiplicative Expressions</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.nctl41fjp9vk">Unary Expressions</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.h035ru2uchdu">Postfix Expressions</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.dt5sshf3wb90">Assignable Expressions</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.igni7ynd65c8">Identifier Reference</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.x0ar1hv8tolv">Type Test</a></span></p><p class="c2 c15"><span class="c10"><a class="c8" href="#h.hqr7euivxf2k">Statements</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.cl7xuoqlaaeh">Blocks</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.xqzpebdcgm4">Expression Statements</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.w2e1gboc13um">Variable Declaration</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.e62bkwgzzagn">If</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.phf2izoilhq7">For</a></span></p><p class="c23 c2"><span class="c10"><a class="c8" href="#h.30cq61pcbhlr">For Loop</a></span></p><p class="c23 c2"><span class="c10"><a class="c8" href="#h.7l7e185heu0v">Foreach</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.4t8k3tvkyul3">While</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.vj4ainfqsbwg">Do</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.50ae78s6gbw2">Switch</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.jodos9r2r9lz">Try</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.q1wj04wamlw9">Return</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.k6ffi6ql1tjy">Labels</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.s4y8w9w8zyl0">Break</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.hkf3vffzbfy6">Continue</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.lo4c3zw824l">Throw</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.cb5i0axenow6">Assert</a></span></p><p class="c2 c15"><span class="c10"><a class="c8" href="#h.9ljawpv6s0wp">Libraries and Scripts</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.jzu775pul7r3">Namespaces</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.eyqxfqjhe14t">Imports</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.2zfa4ypqygnv">Includes</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.ey3rvr2kjush">Scripts</a></span></p><p class="c2 c15"><span class="c10"><a class="c8" href="#h.g191elx0cpi8">Types</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.7tlgp5n9j12w">Static Types</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.6g03yyyk32we">Dynamic Type System</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.h8qq10r7b7a7">Type Declarations</a></span></p><p class="c23 c2"><span class="c10"><a class="c8" href="#h.vv8c77hhsmtm">Typedef</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.ew91lxv9x8zq">Interface Types</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.hj977zpcf6uf">Function Types</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.myhds5lp5ovr">Type Dynamic</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.a5hjb7g00phr">Type Void</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.6kyg74b28ed0">Parameterized Types</a></span></p><p class="c23 c2"><span class="c10"><a class="c8" href="#h.eu4kv2vjewua">Actual Type of a Declaration</a></span></p><p class="c23 c2"><span class="c10"><a class="c8" href="#h.hegkdje9bscx">Least Upper Bounds</a></span></p><p class="c2 c15"><span class="c10"><a class="c8" href="#h.lhp7sn5lni0h">Reference</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.h9utggye7amm">Lexical Rules</a></span></p><p class="c23 c2"><span class="c10"><a class="c8" href="#h.7y8tn090mmsr">Reserved Words</a></span></p><p class="c23 c2"><span class="c10"><a class="c8" href="#h.gey5ehc2i2ad">Comments</a></span></p><p class="c2 c17"><span class="c10"><a class="c8" href="#h.sn1uuf2ffwwd">Operator Precedence</a></span></p><p class="c2 c31"><span class="c10"><a class="c8" href="#h.ta30h0c1shzq"></a></span></p><p class="c2 c4 c22"><span></span></p><p class="c2 c4 c22"><span class="c5 c30"></span></p><p class="c2 c4 c22"><span class="c5 c30"></span></p><hr style="page-break-before:always;display:none;"><p class="c2 c4 c22"><span class="c5 c30"></span></p><p class="c2 c4 c22"><span class="c5 c30"></span></p><p class="c2 c4 c22"><span class="c5 c30"></span></p><a href="#" name="id.mx38kee05esu"></a><p class="c2"><span class="c5 c30">Notes</span></p><p class="c2 c4"><span class="c5 c30 c19"></span></p><p class="c2"><span class="c5 c3">This is a work in progress</span><span>. Expect the contents and language rules to change over time. This document is synced to version 0.08.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Please send comments to gbracha@google.com.</span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><h4 class="c2"><a name="h.jn6bj1irtqj1"></a><span>Licensing</span></h4><p class="c2 c4"><span></span></p><p class="c2"><span class="c16">Except as otherwise </span><span class="c33 c16"><a class="c8" href="http://code.google.com/policies.html#restrictions">noted</a></span><span class="c28 c16">, </span><span class="c16">the content of this document is licensed under the </span><span class="c1 c16"><a class="c8" href="http://creativecommons.org/licenses/by/3.0/">Creative Commons Attribution 3.0 License</a></span><span class="c16">, and code samples are licensed under the </span><span class="c16 c33"><a class="c8" href="http://code.google.com/google_bsd_license.html">BSD License</a></span><span class="c16 c28">.</span></p><p class="c2 c4"><span class="c28 c16"></span></p><h4 class="c2"><a name="h.t4es9cmzw059"></a><span>Changes</span></h4><p class="c2 c4"><span></span></p><h5 class="c2"><a name="h.e8xxgwjgzpjc"></a><span>Changes Since Version 0.02</span></h5><p class="c2 c4"><span></span></p><p class="c2"><span>The following changes have been made in version 0.03 since version 0.02. In addition, various typographical errors have been corrected. The changes are listed by section number.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c1 c5"><a class="c8" href="#id.7zsvgjszhvsx">2:</a></span><span> Expanded examples of grammar in notation section.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c1 c5"><a class="c8" href="#id.c8755sosjkuz">7.9:</a></span><span class="c5"> </span><span>Removed static warning when imported superinterface of a class contains private members.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c1 c5"><a class="c8" href="#id.5kvtnnyqvcjb">8.3:</a></span><span> Removed redundant prohibition on default values.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c1 c5"><a class="c8" href="#id.1dtu82gkimcm">8.4:</a></span><span> Removed static warning when imported superinterface of an interface contains private members.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c1 c5"><a class="c8" href="#id.5cg9qz6trgbb">10:</a></span><span> Fixed typo in grammar</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c1 c5"><a class="c8" href="#id.pp0ymlz8g03s">10.10.1</a></span><span class="c5">, </span><span class="c1 c5"><a class="c8" href="#id.bfpdh2tlvt0v">10.10.2</a></span><span class="c5"> :</span><span> made explicit accessibility requirement for class being constructed.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c1 c5"><a class="c8" href="#id.bfpdh2tlvt0v">10.10.2:</a></span><span> make clear that referenced constructor must be marked const.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c1 c5"><a class="c8" href="#id.mmuk7ayxh6r9">10.14.3:</a></span><span> fixed botched sentence where superclass </span><span class="c3">S</span><span> is introduced.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c1 c5"><a class="c8" href="#id.jzsb5y8clslk">10.27:</a></span><span> qualified definition of </span><span class="c3">v++</span><span> so it is clear that </span><span class="c3">v</span><span> is an identifier.</span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><h5 class="c2"><a name="h.68dpyt5nyl5z"></a><span>Changes Since Version 0.03</span></h5><p class="c2 c4"><span></span></p><p class="c2"><span class="c1 c5"><a class="c8" href="#id.6kuu1330zv2p">7.1</a></span><span class="c5">:</span><span> Added rules prohibiting clashes of inherited variable names or of static and instance methods.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c1 c5"><a class="c8" href="#id.6kuu1330zv2p">7.1</a></span><span class="c5">, </span><span class="c1 c5"><a class="c8" href="#id.oq9a3ejdhhkw">8.1</a></span><span class="c5">:</span><span> Added missing requirement that overriding methods have same number of required parameters and all optional parameters as overridden method, in same order.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c1 c5"><a class="c8" href="#id.64iudgj9wjj1">9:</a></span><span> Added prohibition against cyclic type hierarchy for type parameters.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c1 c5"><a class="c8" href="#id.hvkbnlui8uvu">10.10: </a></span><span> Clarified requirements on use of parameterized types in instance creation expressions.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c1 c5"><a class="c8" href="#id.p7pe6x2fs02j">10.13.2:</a></span><span class="c5"> </span><span>Added requirement that </span><span class="c3">q</span><span class="c9 c3">i</span><span> are distinct. </span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c1 c5"><a class="c8" href="#id.fe2sq6esvhvp">10.4.2:</a></span><span class="c5"> </span><span>Static method invocation determines the function (which may involve evaluating a getter) before evaluating the arguments, so that static invocation and top-level function invocation agree.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c1 c5"><a class="c8" href="#id.8l84oujmjm7p">10:30:</a></span><span> Added missing test that type being tested against is in scope and is indeed a type.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c1 c5"><a class="c8" href="#id.j9iezeasgfnv">11.5.1:</a></span><span> Changed for loop to introduce fresh variable for each iteration.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c1 c5"><a class="c8" href="#id.nr95v4q1z9z0">13.8:</a></span><span class="c5"> </span><span> Malformed parameterized types generate warnings, not errors(except when </span><span>used i</span><span>n reified contexts like instance creation and superclasses/interfaces).</span></p><p class="c2 c4"><span class="c5"></span></p><h5 class="c2"><a name="h.squ00fhhd653"></a><span>Changes Since Version 0.04</span></h5><p class="c2 c4"><span class="c5"></span></p><p class="c2"><span class="c1 c5"><a class="c8" href="#id.qd5b7xk45uot">7.1.2:</a></span><span class="c5"> </span><span>Removed unary plus operator. Clarified that operator formals must be required.</span></p><p class="c2 c4"><span class="c5"></span></p><p class="c2"><span class="c1 c5"><a class="c8" href="#id.okcph2t66jnm">7.5.3:</a></span><span> Filled in a lot of missing detail.</span></p><p class="c2 c4"><span class="c5"></span></p><p class="c2"><span class="c1 c5"><a class="c8" href="#id.5kvtnnyqvcjb">8.3:</a></span><span> Allowed factory class to be declared via a qualified name.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c1 c5"><a class="c8" href="#id.qjvme5fkz60x">10.3:</a></span><span class="c5"> </span><span>Changed production for Number.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c1 c5"><a class="c8" href="#id.bfpdh2tlvt0v">10.10.2:</a></span><span> Added requirements that actuals be constant, rules for dealing with inappropriate types of actuals, and examples. Also explicitly prohibit type variables.</span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c1 c5"><a class="c8" href="#kix.5k4ge149hokr">10.13.4:</a></span><span> Modified final bullet to keep it inline with similar clauses in other sections. Exact wording of these sections also tweaked slightly.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c1 c5"><a class="c8" href="#id.20somwjc6usp">10.25</a></span><span class="c1 c5"><a class="c8" href="#id.kkly3nwmaye">:</a></span><span> Specified ! operator. Eliminated section on prefix expressions and moved contents to section on unary expressions.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c1 c5"><a class="c8" href="#id.72xk08vpsgpx">14.1:</a></span><span> Specified unicode form of Dart source.</span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><h5 class="c2"><a name="h.ulrk584ahfkg"></a><span>Changes Since Version 0.05</span></h5><p class="c2 c4"><span class="c5"></span></p><p class="c2"><span class="c1 c5"><a class="c8" href="#id.e2bn3056d7ls">7:5.1:</a></span><span class="c5"> </span><span>Clarified how initializing formals can act as optional parameters of generative constructors.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c1 c5"><a class="c8" href="#id.ue4n89yodj3k">7.5.2:</a></span><span>  Treat factories as constructors, so type parameters are implicitly in scope</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c1 c5"><a class="c8" href="#id.5kvtnnyqvcjb">8.3:</a></span><span> Simplify rules for interface factory clauses. Use the keyword </span><span class="c5">default</span><span> instead of </span><span class="c5">factory</span><span>.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c1 c5"><a class="c8" href="#id.64iudgj9wjj1">9:</a></span><span> Mention that typedefs can have type parameters.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c1 c5"><a class="c8" href="#id.8l84oujmjm7p">10.29:</a></span><span> Added checked mode test that type arguments match generic type.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c1 c5"><a class="c8" href="#id.xmnezjjgjrld">13.2:</a></span><span> Added definition of malformed types, and requirement on their handling in checked mode.</span></p><p class="c2 c4"><span></span></p><h5 class="c2"><a name="h.bkbuva4b219u"></a><span>Changes since Version 0.06</span></h5><p class="c2 c4"><span></span></p><p class="c2"><span class="c1 c5"><a class="c8" href="#kix.6b1cgvgf1cyq">5:</a></span><span> Top level variable initializers must be constant.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c1 c5"><a class="c8" href="#id.o6h4ul6q3sru">7</a></span><span class="c5">: </span><span>Added</span><span class="c5"> </span><span class="c5 c6">abstract</span><span> modifier to grammar.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c1 c5"><a class="c8" href="#id.o6h4ul6q3sru">7</a></span><span class="c5">, </span><span class="c1 c5"><a class="c8" href="#id.y3ufp36d01bv">7.6</a></span><span class="c5">, </span><span class="c1 c5"><a class="c8" href="#id.4vjq3uijqjm">7.7</a></span><span class="c5">, </span><span class="c1 c5"><a class="c8" href="#id.umipgzep5jdf">10.13.3</a></span><span class="c5">, </span><span class="c1 c5"><a class="c8" href="#id.ayq1ul833tkz">10.28</a></span><span class="c5">:  </span><span>Superclass static members are not in scope in subclasses, and do not conflict with subclass members.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c1 c5"><a class="c8" href="#id.qd5b7xk45uot">7.1.2:</a></span><span> </span><span class="c6">[]=</span><span> must return </span><span class="c5 c6">void</span><span>. Operator </span><span class="c5 c6">call</span><span> added to support function emulation. Removed operator </span><span class="c6">&gt;&gt;&gt;</span><span>. Made explicit restriction on methods named </span><span class="c5 c6">call</span><span>  or </span><span class="c5 c6">negate</span><span>.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c1 c5"><a class="c8" href="#id.hzs87hup8wb">10.1:</a></span><span> Added </span><span class="c3">!e</span><span> as constant expression. Clarified what happens if evaluation of a constant fails.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c1 c5"><a class="c8" href="#id.riie55qjrb82">10.7:</a></span><span> Map keys need not be constants. However, they are always string literals.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c1 c5"><a class="c8" href="#id.v2khzso6nh04">10.9:</a></span><span class="c5"> </span><span>State restrictions on use of </span><span class="c5 c6">this</span><span>.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c1 c5"><a class="c8" href="#id.hvkbnlui8uvu">10.10</a></span><span class="c5">, </span><span class="c1 c5"><a class="c8" href="#id.pp0ymlz8g03s">10.10.1</a></span><span class="c5">:</span><span> Rules for bounds checking of constructor arguments when calling default constructors for interfaces refined.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c1 c5"><a class="c8" href="#kix.5k4ge149hokr">10.13.4:</a></span><span> Revised semantics to account for function emulation.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c1 c5"><a class="c8" href="#kix.dveayw720vs7">10.14.1</a></span><span class="c5">: </span><span>Revised semantics to account for function emulation.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c1 c5"><a class="c8" href="#id.fe2sq6esvhvp">10.14.2:</a></span><span> Revised semantics to account for function emulation.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c1 c5"><a class="c8" href="#id.mmuk7ayxh6r9">10.14.3: </a></span><span> Factory constructors cannot contain super invocations. Revised semantics to account for function emulation.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c1 c5"><a class="c8" href="#id.lc2fh7iv9xwt">10.16:</a></span><span> Specified assignment involving </span><span class="c6">[]=</span><span> operator. </span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c1 c5"><a class="c8" href="#id.jkue5mysxwsv">10.16.1:</a></span><span> Removed operator </span><span class="c6">&gt;&gt;&gt;</span><span>.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c1 c5"><a class="c8" href="#id.dvp94fjydf3m">10.22:</a></span><span> Removed operator </span><span class="c6">&gt;&gt;&gt;</span><span>.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c1 c5"><a class="c8" href="#id.jzsb5y8clslk">10.26:</a></span><span> Postfix </span><span class="c6">--</span><span> operator specified. Behavior of postfix operations on subscripted expressions specified.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c1 c5"><a class="c8" href="#id.ayq1ul833tkz">10:28:</a></span><span> Added built-in identifier </span><span class="c5 c6">call</span><span>.  Banned use of built-in identifiers as types, and made other uses warnings.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c1 c5"><a class="c8" href="#id.8l84oujmjm7p">10.29:</a></span><span>  Moved specification of test that type arguments match generic type to </span><span class="c1 c5"><a class="c8" href="#id.xmnezjjgjrld">13.2</a></span><span> .</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c1 c5"><a class="c8" href="#id.9tgfidrdlcan">11.8:</a></span><span> Corrected evaluation of case clauses so that case expression is the receiver of ==. Revised specification to correctly deal with blank statements in case clauses.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c1 c5"><a class="c8" href="#id.d0t8no72xrno">11:15:</a></span><span> Fixed bug in </span><span class="c5 c6">assert</span><span> specification that could lead to puzzlers.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c1 c5"><a class="c8" href="#id.xmnezjjgjrld">13.2:</a></span><span> Consolidated definition of malformed types.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c1 c5"><a class="c8" href="#id.mmt307l7ge76">13.5:</a></span><span> Revised semantics to account for function emulation.</span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><h5 class="c2"><a name="h.rbsrz7603b1n"></a><span>Changes since Version 0.07</span></h5><p class="c2 c4"><span></span></p><p class="c2"><span class="c10 c5"><a class="c8" href="#kix.6b1cgvgf1cyq">5:</a></span><span class="c5">  </span><span>Static variables are lazily initialized, but need not be constants. Orthogonal notion of constant variable introduced.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c1 c5"><a class="c8" href="#id.qd5b7xk45uot">7.1.2:</a></span><span> Added </span><span class="c5 c6">equals</span><span> operator as part of revised </span><span class="c6">==</span><span> treatment.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c10 c5"><a class="c8" href="#id.e2bn3056d7ls">7.5.1:</a></span><span> Initializing formals have the same type as the field they correspond to.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c10 c5"><a class="c8" href="#id.4vjq3uijqjm">7.7:</a></span><span> Static variable getter rules revised to deal with lazy initialization.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c10 c5"><a class="c8" href="#id.5cg9qz6trgbb">10:</a></span><span> Modified syntax to support cascaded method invocations.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c10 c5"><a class="c8" href="#id.hzs87hup8wb">10.1:</a></span><span> Removed support for + operator on Strings. Extended string constants to support certain cases of string interpolation. Revised constants to deal with constant variables</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c1 c5"><a class="c8" href="#id.6fv1qfiad49o">10.5:</a></span><span> Corrected definition of </span><span class="c5">HEX_DIGIT_SEQUENCE</span><span>. Support implicit concatenation of adjacent single line strings. </span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c10 c5"><a class="c8" href="#id.p7pe6x2fs02j">10.13.2:</a></span><span> Centralized and corrected type rules for function invocation.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c10 c5"><a class="c8" href="#kix.1bfikjk2e9bd">10.14:</a></span><span> Moved rules for checking function/method invocations to 10.1.3.2. Added definition of cascaded method invocations.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c5 c10"><a class="c8" href="#id.lharm2td3qkb">10.15</a></span><span>, </span><span class="c10 c5"><a class="c8" href="#id.lc2fh7iv9xwt">10.16</a></span><span>: Updated </span><span class="c6">noSuchMethod()</span><span> call for getters and setters to conform to planned API.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c10 c5"><a class="c8" href="#id.qbnp7zy55vr8">10.17:</a></span><span> Modified syntax to support cascaded method invocations.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c10 c5"><a class="c8" href="#id.i3yv71am0yah">10:20:</a></span><span> Revised semantics for </span><span class="c6">==.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c1 c5"><a class="c8" href="#id.ayq1ul833tkz">10:28:</a></span><span> Removed </span><span class="c5 c6">import</span><span>, </span><span class="c5 c6">library</span><span> and </span><span class="c5 c6">source</span><span> from list of built-in identifiers. Revised rules for evaluating identifiers to deal with lazy static variable initialization.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c1 c5"><a class="c8" href="#id.rmt74cjqdxyr">11.13:</a></span><span> Fixed bug that allowed </span><span class="c5 c6">continue</span><span> labeled on non-loops.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c10 c5"><a class="c8" href="#id.3o1inam4xp4c">12</a></span><span class="c5">:</span><span> Revised syntax so no space is permitted between </span><span class="c6">#</span><span> and directives. Introduced </span><span class="c6">show:</span><span> combinator. Describe </span><span class="c6">prefix:</span><span> as a combinator. Added initial discussion of namespaces. Preclude string interpolation in arguments to directives.</span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><a href="#" name="id.7zsvgjszhvsx"></a><h3 class="c2"><a name="h.e59lyipdamf1"></a><span>Notation</span></h3><p class="c2 c4"><span></span></p><p class="c2"><span>We distinguish between normative and non-normative text. Normative text defines the rules of Dart. It is given in this font (black </span><span>Arial</span><span> 11pt). At this time, non-normative text includes:</span></p><ol class="c25" start="1"><li class="c7 c2"><span> Rationale. Discussion of the motivation for language design decisions appears in </span><span class="c3 c14">blue</span><span class="c3 c14"> italics</span><span>.  </span><span class="c3 c14">Distinguishing normative from non-normative helps clarify what part of the text is binding and what part is merely expository.  </span></li><li class="c7 c2"><span>Commentary, given </span><span>in </span><span class="c11">green</span><span> (Arial, 11pt) . Comments such as “</span><span class="c11">The careful reader will have noticed that the name Dart  has four characters</span><span>”</span><span> serve to illustrate or clarify the specification, but are redundant with the normative text.  </span><span class="c11">The difference between commentary and rationale can be subtle.</span><span class="c21"> </span><span class="c3 c14">Commentary is more general than rationale, and may include illustrative examples or clarifications.</span></li><li class="c7 c2"><span>Open questions (</span><span class="c19">in red</span><span>). Open questions are points that are unsettled in the mind of the author(s) of the specification; expect them  (the questions, not the authors; precision is important in a specification) to be eliminated in the final specification. </span><span class="c19">Should the text at the end of the previous bullet be rationale or commentary?</span></li></ol><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Reserved words and built-in identifiers appear in </span><span class="c5 c6">this font. </span></p><p class="c2"><span class="c11">Examples would be </span><span class="c5 c11 c6">switch</span><span class="c11"> or </span><span class="c5 c11 c6">class. </span></p><p class="c2 c4"><span class="c5 c6"></span></p><p class="c2"><span>Grammar productions are given in a common variant of EBNF. The left</span></p><p class="c2"><span>hand side of a production ends with a colon. On the right hand side, alternation is represented by vertical bars, and sequencing by spacing. Optional elements of a production are suffixed by a question mark like so: </span><span class="c6">anElephant?</span><span> . Appending a star to an element of a production means it may be repeated zero or more times. Appending a plus sign to a production means it occurs one or more times. Parentheses are used for grouping. Negation (the </span><span class="c5">not</span><span> combinator of PEGs) is represented by prefixing an element of a production with a tilde.</span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c11">An example would be:</span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span class="c5 c11 c3">AProduction:</span><span class="c11"> </span></p><p class="c2"><span class="c11 c3">      AnAlternative</span></p><p class="c2"><span class="c11 c3">    | AnotherAlternative</span></p><p class="c2"><span class="c11 c3">    |  OneThing After Another</span></p><p class="c2"><span class="c11">  </span><span class="c11 c3">| ZeroOrMoreThings*</span></p><p class="c2"><span class="c11 c3">  | OneOrMoreThings+</span></p><p class="c2"><span class="c11 c3">  | AnOptionalThing?</span></p><p class="c2"><span class="c11 c3">  | (</span><span class="c11 c3">Some Grouped Things</span><span class="c11 c3">)</span></p><p class="c2"><span class="c11 c3">  | ~NotAThing</span></p><p class="c2"><span class="c11 c3">  | A_LEXICAL_THING </span></p><p class="c2"><span class="c11 c3">  ;</span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span>Both syntactic and lexical productions are represented this way. Lexical productions are distinguished by their names. The names of lexical productions consist exclusively of upper case characters and underscores. As always, within grammatical productions, whitespace and comments between elements of the production are implicitly ignored unless stated otherwise.</span></p><p class="c2"><span>Productions are embedded, as much as possible, in the discussion of the constructs they represent.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>A list </span><span class="c3">x</span><span class="c9 c3">1</span><span class="c3">,..., x</span><span class="c9 c3">n</span><span> denotes any list of </span><span class="c3">n</span><span> elements of the form </span><span class="c3">x</span><span class="c9 c3">i</span><span class="c3">, 1 &lt;= i &lt;= n.</span><span> Note that </span><span class="c3">n</span><span> may be zero, in which case the list is empty. We use such lists extensively throughout this specification.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>The notation </span><span class="c3">[x</span><span class="c9 c3">1</span><span class="c3">, ..., x</span><span class="c9 c3">n</span><span class="c3">/y</span><span class="c9 c3">1</span><span class="c3">, ..., y</span><span class="c9 c3">n</span><span class="c3">]E</span><span>  denotes a copy of </span><span class="c3">E</span><span> in which all occurrences of </span><span class="c3">y</span><span class="c9 c3">i</span><span class="c3">, 1 &lt;= i &lt;= n</span><span> have been replaced with </span><span class="c3">x</span><span class="c9 c3">i</span><span class="c3">.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>The specifications of operators often involve statements such as </span><span class="c3">x op y is equivalent to the method invocation x.op(y).</span><span> Such specifications should be understood as a shorthand for:</span></p><p class="c2"><span> </span><span class="c3">x op y is equivalent to the method invocation x.op</span><span class="c3">’</span><span class="c3">(y), assuming the class of x actually declared a non-operator method named op’ defining the same function as the operator op</span><span class="c3">.</span><span class="c3"> </span><span class="c3 c14">This circumlocution is required because x.op(y), where op is an operator, is not legal syntax. However, it is painfully verbose, and we prefer to state this rule once here, and use a concise and clear notation across the specification.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>When the specification refers to</span><span class="c3"> the order given in the program,</span><span> it means the order of the program source code text, scanning left-to-right and top-to-bottom.</span></p><p class="c2 c4"><span></span></p><a href="#" name="id.nr0objucb6zv"></a><h2 class="c2"><a name="h.p51fkz19s0b2"></a><span>Overview</span></h2><p class="c2 c4"><span></span></p><p class="c2"><span>Dart is a class-based, single-inheritance, pure object-oriented programming language. Dart is optionally </span><span class="c1"><a class="c8" href="#id.438ffsdvzkfw">typed</a></span><span> and supports reified generics and interfaces. </span></p><p class="c2 c4"><span class="c19"></span></p><p class="c2"><span>Dart</span><span> programs can be statically checked. The </span><span class="c1"><a class="c8" href="#id.hiljskbmppmb">static checker</a></span><span> will report some violations of the type rules, but such violations do not abort compilation or preclude execution. </span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Dart programs may be executed in one of two modes: production mode or checked mode. In production mode, </span><span class="c1"><a class="c8" href="#id.hiljskbmppmb">static type annotations</a></span><span> have absolutely no effect on execution.  In checked mode, </span><span>assignments</span><span> are dynamically checked, and certain violations of the type system raise exceptions at run time.</span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c21">The coexistence between optional typing and reification is based on the following:</span></p><ol class="c25" start="1"><li class="c7 c2"><span class="c21">Reified type information reflects the types of objects at runtime and may always be queried by dynamic typechecking constructs (the analogs of instanceOf, casts, typecase etc. in other languages). Reified type information includes class and interface declarations, the class of an object, and type arguments to constructors. </span></li><li class="c7 c2"><span class="c21">Static type annotations determine the types of variables and function declarations (including methods and constructors). </span></li><li class="c7 c2"><span class="c21">Production mode respects optional typing. Static type annotations do not a</span><span class="c21">ffect</span><span class="c21"> runtime behavior.</span></li><li class="c7 c2"><span class="c21">Checked mode utilizes static type annotations and dynamic type information aggressively yet selectively to provide early error detection during development.</span></li></ol><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Dart programs are organized in a modular fashion into units called </span><span class="c1"><a class="c8" href="#id.3o1inam4xp4c">libraries</a></span><span>. Libraries are units of encapsulation and may be mutually recursive. </span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c11">However they are not first class.  To get multiple copies of a library running simultaneously, one needs to spawn an isolate.</span><span class="c19">  </span></p><p class="c2 c4"><span class="c19"></span></p><a href="#" name="id.ph0zb6qp0qlw"></a><h3 class="c2"><a name="h.jb82efuudrc5"></a><span>Scoping</span></h3><p class="c2 c4"><span></span></p><p class="c2"><span>Dart is lexically scoped and uses a single namespace for variables, functions and types.  It is a compile-time error if there is more than one entity, other than a setter and a getter, with the same name declared in the same scope.  Names in nested scopes may hide names in lexically enclosing scopes, however, it is a static warning if a declaration introduces a name that is available in a lexically enclosing scope.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Names may be introduced into a scope by  declarations within the scope or by other mechanisms such as imports or inheritance.</span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span class="c19"></span></p><a href="#" name="id.zeletzevxf8t"></a><h3 class="c2"><a name="h.9oi5o1gdzoe8"></a><span>Privacy</span></h3><p class="c2"><span>Dart supports two levels of privacy: </span><span class="c3">public</span><span> and </span><span class="c3">private</span><span>. A declaration is private if it begins with an underscore (the _ character) otherwise it is public. </span></p><p class="c2 c4"><span></span></p><p class="c2"><span>A declaration </span><span class="c3">m</span><span> is </span><span class="c3">accessible to library L</span><span> </span><span>if </span><span class="c3">m</span><span> is declared in </span><span class="c3">L</span><span> </span><span>or if </span><span class="c3">m</span><span> is public</span><span>.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c11">Private declarations may only be accessed within the library in which they are declared.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c3 c14">Privacy is, at this point, a static notion tied to a particular piece of code (a library). It is designed to support software engineering concerns rather than security concerns. Untrusted code should always run in an another isolate.  It is possible that libraries will become first class objects and privacy will be a dynamic notion tied to a library instance.</span></p><p class="c2 c4"><span class="c3 c14"></span></p><p class="c2"><span class="c3 c14">Privacy is indicated by the name of a declaration - hence privacy and naming are not orthogonal. This has the advantage that both humans and machines can recognize access to private declarations at the point of use without knowledge of the context from which the declaration is derived.</span></p><p class="c2 c4"><span class="c3 c14"></span></p><p class="c2 c4"><span></span></p><a href="#" name="id.wd33q1u3sguh"></a><h3 class="c2"><a name="h.a21lfdy211x8"></a><span>Concurrency</span></h3><p class="c2"><span>Dart code is always single threaded. There is no shared-state concurrency in Dart. Concurrency is supported via actor-like entities called </span><span class="c3">isolates</span><span>.</span></p><p class="c2"><span>An </span><span class="c3">isolate</span><span> is a unit of concurrency. It has its own memory and its own thread of control. Isolates communicate by </span><span class="c1"><a class="c8" href="#id.3drgiqgu864y">message passing</a></span><span>. </span><span>No mutable state </span><span>is ever shared between isolates. Isolates are created by </span><span class="c1"><a class="c8" href="#id.x6lx0jb4kti5">spawning</a></span><span>.</span></p><p class="c2 c4"><span></span></p><a href="#" name="id.l4twf9coi3a3"></a><h3 class="c2"><a name="h.n3lq43t151ad"></a><span>Errors</span><span> and Warnings</span></h3><p class="c2"><span>This specification distinguishes between several kinds of errors.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c3">Compile-time errors</span><span> are </span><span>errors that preclude execution</span><span>. A compile time error must be reported by a Dart compiler before the erroneous code is executed. </span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c3 c14">A Dart implementation has considerable freedom as to when compilation takes place. Modern programming language implementations often interleave compilation and execution, so that compilation of a method may be delayed, e.g.,  until it is first invoked. Consequently, compile-time errors in a method m </span><span class="c3 c14">may be reported as late as the time of m’s first invocation</span><span class="c3 c14">.</span></p><p class="c2 c4"><span class="c3 c14"></span></p><p class="c2"><span class="c3 c14">As a web language, Dart is often loaded directly from source, with no intermediate binary representation. In the interests of rapid loading, Dart implementations may choose to avoid full parsing of method bodies, for example. This can be done by tokenizing the input and checking for balanced curly braces on method body entry. In such an implementation, even syntax errors will be detected only when the method needs to be executed, at which time it will be compiled (JITed).</span></p><p class="c2 c4"><span class="c3 c14"></span></p><p class="c2"><span class="c3 c14">In a development environment a compiler should of course report compilation errors eagerly so as to  best serve the programmer.</span></p><p class="c2 c4"><span class="c3 c14"></span></p><p class="c2"><span>If a compile-time error occurs within the code of a running isolate </span><span class="c3">A</span><span>, </span><span class="c3">A</span><span> is immediately suspended.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c3 c14">Typically, </span><span class="c5 c3 c14">A</span><span class="c3 c14"> will then be terminated. However, this depends on the overall environment. A Dart engine runs in the context of an </span><span class="c5 c3 c14">embedder</span><span class="c3 c14">, a program that interfaces between the engine and the surrounding computing environment. The embedder will often be a web browser, but need not be; it may be a C++ program on the server for example. When an isolate fails with a compile-time error as described above, control returns to the embedder, along with an exception describing the problem.  This is necessary so that the embedder can clean up resources etc. It is then the embedder’s decision whether to terminate the isolate or not.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c3">Static warnings</span><span> are those warnings reported by the static checker. They have no effect on execution. Many, but not all, static warnings relate to types, in which case they are known as </span><span class="c3">static type warnings. </span><span>Static warnings must be provided by Dart compilers used during development.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c3">Dynamic type errors</span><span> are type errors reported in </span><span class="c1"><a class="c8" href="#id.xmnezjjgjrld">checked mode</a></span><span>.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c3">Run time errors</span><span> are exceptions raised during execution. Whenever we say that an exception </span><span class="c3">ex</span><span> is </span><span class="c3">raised</span><span> or </span><span class="c3">thrown</span><span>, we mean that  a </span><span class="c1"><a class="c8" href="#id.2p1bowyir5aa">throw statement</a></span><span> of the form</span><span>: </span><span class="c5 c6">throw</span><span> </span><span class="c3">ex</span><span class="c6">;</span><span> was implicitly executed. When we say that </span><span class="c3">a C is thrown</span><span>, where </span><span class="c3">C</span><span> is an exception class, we mean that an instance of class</span><span class="c6"> </span><span class="c3 c6">C</span><span class="c6"> </span><span>is thrown.</span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><a href="#" name="kix.6b1cgvgf1cyq"></a><h2 class="c2"><a name="h.55kzc4r0q21p"></a><span>Variables</span></h2><p class="c2"><span>Variables are storage locations in memory.  </span></p><p class="c2 c4"><span></span></p><a href="#" name="id.prmcvifr6l2h"></a><p class="c2"><span class="c5 c3">variableDeclaration:</span><span class="c3"><br>      </span><span class="c1 c3"><a class="c8" href="#id.2xe95ykmes0u">declaredIdentifier</a></span><span class="c3"> (&#39;,&#39; </span><span class="c0"><a class="c8" href="#id.te0njh1fhw7g">identifier</a></span><span class="c3">)*<br>    ;<br><br></span><a href="#" name="id.m3rhzz9horb4"></a><span class="c5 c3">initializedVariableDeclaration:</span><span class="c3"><br>      </span><span class="c1 c3"><a class="c8" href="#id.2xe95ykmes0u">declaredIdentifier</a></span><span class="c3"> (&#39;=&#39; </span><span class="c0"><a class="c8" href="#id.1u3vxuwrz6py">expression</a></span><span class="c3">)? (&#39;,&#39; </span><span class="c1 c3"><a class="c8" href="#id.cjgl4bau1n1l">initializedIdentifier</a></span><span class="c3">)*<br>    ;<br><br></span><a href="#" name="id.2slkn210dwxm"></a><span class="c5 c3">initializedIdentifierList</span><span class="c5 c3">:</span><span class="c3"><br>      </span><span class="c0"><a class="c8" href="#id.cjgl4bau1n1l">initializedIdentifier</a></span><span class="c3"> (&#39;,&#39; </span><span class="c1 c3"><a class="c8" href="#id.cjgl4bau1n1l">initializedIdentifier</a></span><span class="c3">)*<br>    ;<br><br></span><a href="#" name="id.cjgl4bau1n1l"></a><span class="c5 c3">initializedIdentifier:</span><span class="c3"><br>      </span><span class="c0"><a class="c8" href="#id.te0njh1fhw7g">identifier</a></span><span class="c3"> (&#39;=&#39; </span><span class="c0"><a class="c8" href="#id.1u3vxuwrz6py">expression</a></span><span class="c3">)?<br>    ;</span></p><p class="c2 c4"><span class="c3"></span></p><a href="#" name="id.2xe95ykmes0u"></a><p class="c2"><span class="c5 c3">declaredIdentifier:</span><span class="c3"><br>      </span><span class="c0"><a class="c8" href="#id.w1smn1f9ij10">finalConstVarOrType</a></span><span class="c3"> </span><span class="c0"><a class="c8" href="#id.te0njh1fhw7g">identifier</a></span><span class="c3"><br>    ;</span></p><a href="#" name="id.6u0m5tcnhim0"></a><p class="c2 c4"><span class="c3"></span></p><p class="c2 c4"><span class="c3"></span></p><a href="#" name="id.w1smn1f9ij10"></a><p class="c2"><span class="c5 c3">finalConst</span><span class="c5 c3">VarOrType:</span><span class="c3"><br>      </span><span class="c5 c6">final</span><span class="c3"> </span><span class="c0"><a class="c8" href="#id.qv2a3rupuer9">type</a></span><span class="c3">?</span></p><p class="c2"><span class="c3">    | </span><span class="c5 c6">const</span><span class="c3"> </span><span class="c0"><a class="c8" href="#id.qv2a3rupuer9">type</a></span><span class="c3">?<br>    | </span><span class="c5 c6">var</span><span class="c3"><br>    | </span><span class="c0"><a class="c8" href="#id.qv2a3rupuer9">type</a></span><span class="c3"><br>    ;<br></span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><p class="c2"><span>A variable that has not been initialized has the initial value </span><span class="c5 c6">null</span><span class="c5">.</span></p><p class="c2"><span>A </span><span class="c3">final variable</span><span> is a variable whose declaration includes the modifier </span><span class="c5 c6">final.</span><span> </span><span>A final variable can only be assigned once, when it is initialized, or a compile-time error occurs. It is a compile-time error if a variable </span><span class="c3">v</span><span> is a final top-level variable or a final local variable and </span><span class="c3">v</span><span> is not initialized at its point of declaration.</span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span class="c19"></span></p><p class="c2"><span>A </span><span class="c3">constant variable</span><span> is a variable whose declaration includes the modifier </span><span class="c5 c6">const.</span><span> A constant variable is always implicitly final. A constant variable must be initialized to a </span><span class="c10"><a class="c8" href="#id.hzs87hup8wb">compile-time constant</a></span><span> or a compile-time error occurs</span><span>.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c11">Constant variables are not yet implemented. </span></p><p class="c2 c4"><span></span></p><p class="c2"><span>A </span><span class="c3">static variable</span><span> is a variable that is not associated with a particular instance, but rather with an entire library or class.  </span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Static variable declarations are initialized lazily. The first time a static variable </span><span class="c3">v</span><span> is read, it is set to the result of evaluating its initializer. The precise rules are given in sections</span><span class="c10"><a class="c8" href="#id.4vjq3uijqjm"> 7.7</a></span><span> and</span><span class="c10"><a class="c8" href="#id.ayq1ul833tkz"> 10.28</a></span><span>.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c11">Current implementations give a compile-time error if  static variables are not initialized with compile-time constants. These restrictions will be lifted in time.</span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span class="c3 c14">The lazy semantics are given because we do not want a language where one tends to define expensive initialization computations, causing long application startup times. This is especially crucial for Dart, which is designed for coding client applications.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>If a variable declaration does not explicitly specify a type, the type of the declared variable(s) is </span><span class="c5 c6">Dynamic</span><span class="c1"><a class="c8" href="#kix.5kehb35oxqwh">, the unknown type</a></span><span>.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>A top-level variable is implicitly static. It is a compile-time error to preface a top level variable declaration with the built-in identifier </span><span class="c5 c6">static.</span><span>  </span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><a href="#" name="kix.v3h5pp33ioek"></a><h2 class="c2"><a name="h.kt174mfrzv4a"></a><span>Functions</span></h2><p class="c2 c4"><span></span></p><p class="c2"><span>Functions abstract over executable actions.</span></p><p class="c2 c4"><span></span></p><a href="#" name="id.7ttlaph5nhkh"></a><p class="c2"><span class="c5 c3">functionSignature:</span><span class="c3"><br>    </span><span class="c0"><a class="c8" href="#id.mriqqq9dwbm5">returnType</a></span><span class="c3">? </span><span class="c0"><a class="c8" href="#id.te0njh1fhw7g">identifier</a></span><span class="c3"> </span><span class="c0"><a class="c8" href="#id.6xer2paz3k7q">formalParameterList</a></span><span class="c3"><br>    ;<br></span></p><a href="#" name="id.mriqqq9dwbm5"></a><p class="c2"><span class="c5 c3">returnType:</span><span class="c3"><br>      </span><span class="c5 c6">void</span><span class="c3"><br>    | </span><span class="c0"><a class="c8" href="#id.qv2a3rupuer9">type</a></span></p><p class="c2"><span class="c3">    ;<br><br><br></span><a href="#" name="id.twypn7sgnd3j"></a><span class="c5 c3">functionBody:</span><span class="c3"><br>      </span><span class="c3">&#39;</span><span class="c3 c6">=&gt;</span><span class="c3">&#39; </span><span class="c0"><a class="c8" href="#id.1u3vxuwrz6py">expression</a></span><span class="c3"> &#39;;&#39;<br>    | </span><span class="c0"><a class="c8" href="#kix.kx7urn183i41">block</a></span><span class="c3"><br>    ;</span></p><p class="c2 c4"><span class="c3"></span></p><a href="#" name="kix.kx7urn183i41"></a><p class="c2"><span class="c5 c3">block:</span><span class="c3"><br>      &#39;{&#39; </span><span class="c0"><a class="c8" href="#id.mfp056u1wxhj">statements</a></span><span class="c3"> &#39;}&#39;<br>    ;</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Functions include  function declarations, methods, getters, setters and function literals. </span></p><p class="c2 c4"><span></span></p><p class="c2"><span>All functions have a signature and a body. The signature describes the formal parameters of the function, and possibly its name and return type. The body is a block statement containing the statements executed by the function. A function body of the form  </span><span class="c6">=&gt; e</span><span> is equivalent to a body of the form {</span><span class="c5 c6">return</span><span class="c6"> e;}</span><span>.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>If the last statement of a function is not a return statement, the statement </span><span class="c5 c6">return null</span><span class="c6">;</span><span> is implicitly appended to the function body.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c3 c14">Because Dart is optionally typed, we cannot guarantee that a function that does not return a value will not be used in the context of an expression. Therefore, every function must return a value. See the </span><span class="c1 c3"><a class="c8" href="#id.963bggxlx5wo">discussion</a></span><span class="c3"> </span><span class="c3 c14">around the return statement</span><span class="c3 c14">. </span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><h3 class="c2"><a name="h.yntwge6nalyc"></a><span>Function Declarations</span></h3><p class="c2 c4"><span></span></p><p class="c2"><span>A </span><span class="c3">function declaration</span><span> is a function that is not a method, getter, setter or function literal. Function declarations include </span><span class="c3">library functions,</span><span> which are function declarations at the top level of a library, and </span><span class="c3">local functions,</span><span> which are functions declarations declared inside other functions.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>A function declaration of the form  </span><span class="c3">T</span><span class="c9 c3">0</span><span class="c3"> id(T</span><span class="c9 c3">1 </span><span class="c3">a</span><span class="c9 c3">1</span><span class="c3">, …, T</span><span class="c9 c3">n </span><span class="c3">a</span><span class="c9 c3">n</span><span class="c3">, [T</span><span class="c9 c3">n+1  </span><span class="c3">x</span><span class="c9 c3">n+1</span><span class="c3"> = d</span><span class="c9 c3">1</span><span class="c3">, …, T</span><span class="c9 c3">n+k</span><span class="c3"> x</span><span class="c9 c3">n+k</span><span class="c3"> = d</span><span class="c9 c3">k</span><span class="c3">]){s}</span><span> is </span><span>equivalent to a variable declaration of the form</span><span> </span><span class="c5 c6">final</span><span class="c3"> F id</span><span> = </span><span class="c3">(T</span><span class="c9 c3">1 </span><span class="c3">a</span><span class="c9 c3">1</span><span class="c3">, …, T</span><span class="c9 c3">n </span><span class="c3">a</span><span class="c9 c3">n</span><span class="c3">, [T</span><span class="c9 c3">n+1  </span><span class="c3">x</span><span class="c9 c3">n+1</span><span class="c3"> = d</span><span class="c9 c3">1</span><span class="c3">, …, T</span><span class="c9 c3">n+k</span><span class="c3"> x</span><span class="c9 c3">n+k</span><span class="c3"> = d</span><span class="c9 c3">k</span><span class="c3">]){s}</span><span> where </span><span class="c3">F</span><span> is the function type alias </span><span class="c5 c6">typedef</span><span> </span><span class="c3">T</span><span class="c9 c3">0</span><span class="c3"> F(T</span><span class="c9 c3">1 </span><span class="c3">a</span><span class="c9 c3">1</span><span class="c3">, …, T</span><span class="c9 c3">n </span><span class="c3">a</span><span class="c9 c3">n</span><span class="c3">, [T</span><span class="c9 c3">n+1  </span><span class="c3">x</span><span class="c9 c3">n+1</span><span class="c3">, …, T</span><span class="c9 c3">n+k</span><span class="c3"> x</span><span class="c9 c3">n+k</span><span class="c3">])</span><span>.</span></p><p class="c2"><span> Likewise, a function declaration of the form  </span><span class="c3">id(T</span><span class="c9 c3">1 </span><span class="c3">a</span><span class="c9 c3">1</span><span class="c3">, …, T</span><span class="c9 c3">n </span><span class="c3">a</span><span class="c9 c3">n</span><span class="c3">, [T</span><span class="c9 c3">n+1  </span><span class="c3">x</span><span class="c9 c3">n+1</span><span class="c3"> = d</span><span class="c9 c3">1</span><span class="c3">, …, T</span><span class="c9 c3">n+k</span><span class="c3"> x</span><span class="c9 c3">n+k</span><span class="c3"> = d</span><span class="c9 c3">k</span><span class="c3">]){s}</span><span> is equivalent to a variable declaration of the form </span><span class="c5 c6">final</span><span> </span><span class="c3">F id</span><span> = </span><span class="c3">(T</span><span class="c9 c3">1 </span><span class="c3">a</span><span class="c9 c3">1</span><span class="c3">, …, T</span><span class="c9 c3">n </span><span class="c3">a</span><span class="c9 c3">n</span><span class="c3">, [T</span><span class="c9 c3">n+1  </span><span class="c3">x</span><span class="c9 c3">n+1</span><span class="c3"> = d</span><span class="c9 c3">1</span><span class="c3">, </span><span class="c3">…, T</span><span class="c9 c3">n+k</span><span class="c3"> x</span><span class="c9 c3">n+k</span><span class="c3"> = d</span><span class="c9 c3">k</span><span class="c3">]){s}</span><span> where </span><span class="c3">F</span><span> is the function type alias </span><span class="c5 c6">typedef</span><span> </span><span class="c3">F(T</span><span class="c9 c3">1 </span><span class="c3">a</span><span class="c9 c3">1</span><span class="c3">, …, T</span><span class="c9 c3">n </span><span class="c3">a</span><span class="c9 c3">n</span><span class="c3">, [T</span><span class="c9 c3">n+1  </span><span class="c3">x</span><span class="c9 c3">n+1</span><span class="c3">, …, T</span><span class="c9 c3">n+k</span><span class="c3"> x</span><span class="c9 c3">n+k</span><span class="c3">])</span><span>.</span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span class="c6"></span></p><p class="c2"><span class="c11">Some obvious conclusions:</span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span class="c11">A function declaration of the form  </span><span class="c11 c3">id(T</span><span class="c9 c11 c3">1 </span><span class="c11 c3">a</span><span class="c9 c11 c3">1</span><span class="c11 c3">, …, T</span><span class="c9 c11 c3">n </span><span class="c11 c3">a</span><span class="c9 c11 c3">n</span><span class="c11 c3">, [T</span><span class="c9 c11 c3">n+1  </span><span class="c11 c3">x</span><span class="c9 c11 c3">n+1</span><span class="c11 c3"> = d</span><span class="c9 c11 c3">1</span><span class="c11 c3">, …, T</span><span class="c9 c11 c3">n+k</span><span class="c11 c3"> x</span><span class="c9 c11 c3">n+k</span><span class="c11 c3"> = d</span><span class="c9 c11 c3">k</span><span class="c11 c3">]) =&gt; e</span><span class="c11"> is equivalent to a variable declaration of the form </span><span class="c5 c11 c6">final</span><span class="c11"> </span><span class="c11 c3">id</span><span class="c11"> = </span><span class="c11 c3">(T</span><span class="c9 c11 c3">1 </span><span class="c11 c3">a</span><span class="c9 c11 c3">1</span><span class="c11 c3">, …, T</span><span class="c9 c11 c3">n </span><span class="c11 c3">a</span><span class="c9 c11 c3">n</span><span class="c11 c3">, [T</span><span class="c9 c11 c3">n+1  </span><span class="c11 c3">x</span><span class="c9 c11 c3">n+1</span><span class="c11 c3"> = d</span><span class="c9 c11 c3">1</span><span class="c11 c3">,…, T</span><span class="c9 c11 c3">n+k</span><span class="c11 c3"> x</span><span class="c9 c11 c3">n+k</span><span class="c11 c3"> = d</span><span class="c9 c11 c3">k</span><span class="c11 c3">])=&gt; e</span><span class="c11">.</span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span class="c11">A function literal of the form </span><span class="c11 c3">(T</span><span class="c9 c11 c3">1 </span><span class="c11 c3">a</span><span class="c9 c11 c3">1</span><span class="c11 c3">, …, T</span><span class="c9 c11 c3">n </span><span class="c11 c3">a</span><span class="c9 c11 c3">n</span><span class="c11 c3">, [T</span><span class="c9 c11 c3">n+1  </span><span class="c11 c3">x</span><span class="c9 c11 c3">n+1</span><span class="c11 c3"> = d</span><span class="c9 c11 c3">1</span><span class="c11 c3"> ,… ,T</span><span class="c9 c11 c3">n+k</span><span class="c11 c3"> x</span><span class="c9 c11 c3">n+k</span><span class="c11 c3"> = d</span><span class="c9 c11 c3">k</span><span class="c11 c3">])=&gt; e </span><span class="c11">is equivalent to a function literal of the form </span><span class="c11 c3">(T</span><span class="c9 c11 c3">1 </span><span class="c11 c3">a</span><span class="c9 c11 c3">1</span><span class="c11 c3">, …, T</span><span class="c9 c11 c3">n </span><span class="c11 c3">a</span><span class="c9 c11 c3">n</span><span class="c11 c3">, [T</span><span class="c9 c11 c3">n+1  </span><span class="c11 c3">x</span><span class="c9 c11 c3">n+1</span><span class="c11 c3">  = d</span><span class="c9 c11 c3">1</span><span class="c11 c3">,… T</span><span class="c9 c11 c3">n+k</span><span class="c11 c3"> x</span><span class="c9 c11 c3">n+k</span><span class="c11 c3"> = d</span><span class="c9 c11 c3">k</span><span class="c11 c3">]){ </span><span class="c5 c11 c6">return</span><span class="c11 c3"> e;}</span><span class="c11">.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>It is a compile-time error to preface a function declaration with the built-in identifier </span><span class="c5 c6">static.</span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><a href="#" name="id.dbnqav8zbk9d"></a><h3 class="c2"><a name="h.1ng1g7im8ubk"></a><span>Formal Parameters</span></h3><p class="c2"><span>Every function declaration includes a </span><span class="c3">formal parameter list,</span><span> which consists of a list of</span><span> required </span><span class="c10"><a class="c8" href="#id.lzl30mluk4sf">positional parameters</a></span><span>, followed by any optional parameters. Optional parameters consist of  a set of named parameters.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>The scope of formal parameters includes, but is distinct from, the scope of the function body.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>It is a compile-time error if a formal parameter is declared as a constant variable.</span></p><p class="c2 c4"><span class="c19"></span></p><p class="c2"><span><br><br></span><a href="#" name="id.6xer2paz3k7q"></a><span class="c5 c3">formalParameterList:</span><span class="c3">     </span></p><p class="c2"><span class="c3">    </span><span class="c3 c19"> </span><span class="c3">  &#39;(&#39; &#39;)&#39; </span></p><p class="c2"><span class="c3">    | &#39;(&#39; </span><span class="c1 c3"><a class="c8" href="#id.fwj9r1x9ultc">normalFormalParameters</a></span><span class="c3"> ( ‘,’ </span><span class="c1 c3"><a class="c8" href="#id.ha46vgashw72">namedFormalParameters</a></span><span class="c3">)? &#39;)&#39;</span></p><p class="c2"><span class="c3">    |  &#39;(&#39; </span><span class="c1 c3"><a class="c8" href="#id.ha46vgashw72">namedFormalParameters</a></span><span class="c3"> &#39;)&#39;<br>    ;<br></span></p><a href="#" name="id.fwj9r1x9ultc"></a><p class="c2"><span class="c5 c3">normalFormalParameters:<br></span><span class="c3">      </span><span class="c1 c3"><a class="c8" href="#id.nu20924aw7uh">normalFormalParameter</a></span><span class="c3"> (&#39;,&#39; </span><span class="c1 c3"><a class="c8" href="#id.nu20924aw7uh">normalFormalParameter</a></span><span class="c3">)* <br>    ;<br><br><br></span><a href="#" name="id.ha46vgashw72"></a><span class="c5 c3">namedFormalParameters:</span><span class="c3"><br>      &#39;[&#39; </span><span class="c1 c3"><a class="c8" href="#id.hnv76i7pvtkk">defaultFormalParameter</a></span><span class="c3"> (&#39;,&#39; </span><span class="c1 c3"><a class="c8" href="#id.hnv76i7pvtkk">defaultFormalParameter</a></span><span class="c3">)* &#39;]&#39;<br>    ;<br></span><span><br><br></span></p><a href="#" name="id.lzl30mluk4sf"></a><h4 class="c2"><a name="h.co9rbd1pkdlm"></a><span>Positional Formals </span></h4><p class="c2"><span>A </span><span class="c3">positional formal parameter</span><span> is a simple </span><span class="c1"><a class="c8" href="#kix.6b1cgvgf1cyq">variable declaration</a></span><span>.</span></p><p class="c2"><span><br></span><a href="#" name="id.nu20924aw7uh"></a><span class="c5 c3">normalFormalParameter:</span><span class="c3"><br>      functionSignature<br>    | </span><span class="c1 c3"><a class="c8" href="#id.1nhs5plthzz2">fieldFormalParameter</a></span><span class="c3"><br>    | </span><span class="c1 c3"><a class="c8" href="#id.g51um5hg0av">simpleFormalParameter</a></span><span class="c3"><br>    ;</span></p><p class="c2 c4"><span class="c3"></span></p><a href="#" name="id.g51um5hg0av"></a><p class="c2"><span class="c5 c3">simpleFormalParameter:</span><span class="c3"><br>      </span><span class="c1 c3"><a class="c8" href="#id.2xe95ykmes0u">declaredIdentifier</a></span><span class="c3"><br>    | </span><span class="c0"><a class="c8" href="#id.te0njh1fhw7g">identifier</a></span><span class="c3"><br>    ;<br><br></span><a href="#" name="id.1nhs5plthzz2"></a><span class="c5 c3">fieldFormalParameter:</span><span class="c3"><br>   </span><span class="c0"><a class="c8" href="#id.w1smn1f9ij10">finalConstVarOrType</a></span><span class="c3">? </span><span class="c5 c6">this</span><span class="c3"> &#39;.&#39; </span><span class="c0"><a class="c8" href="#id.te0njh1fhw7g">identifier</a></span><span class="c3"><br>   ;<br></span></p><h4 class="c2"><a name="h.lqef8gma6oso"></a><span>Named Optional Formals</span></h4><p class="c2 c4"><span></span></p><p class="c2"><span>Optional parameters may be specified and provided with default values.</span></p><p class="c2 c4"><span></span></p><a href="#" name="id.hnv76i7pvtkk"></a><p class="c2"><span class="c5 c3">defaultFormalParameter:</span><span class="c3"><br>      </span><span class="c1 c3"><a class="c8" href="#id.nu20924aw7uh">normalFormalParameter</a></span><span class="c3"> (&#39;=&#39; constantExpression)?<br>    ;</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span>It is a compile-time error if the default value of a named parameter is not a compile-time constant. </span></p><p class="c2"><span> If no default is explicitly specified for an optional parameter, but a default could legally be provided, an implicit default of </span><span class="c5 c6">null</span><span> is provided.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c11">There are situations (in abstract methods and interfaces) where optional parameters are allowed but an explicit default is illegal. In these cases, no implicit default is provided. This causes no difficulty, as any implementation of the method will provide defaults.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span> </span><span>It is a compile-time error if the name of a named optional parameter begins with an ‘_’ character.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c3 c14">The need for this restriction is a direct consequence of the fact that naming and privacy are not orthogonal. If we allowed named parameters to begin with an underscore, they would be considered private and inaccessible to callers from outside the library where it was defined. If a method outside the library overrode a method with a private optional name, it would not be a subtype of the original method. The static checker would of course flag such situations, but the consequence would be that adding a private named formal would break clients outside the library in a way they could not easily correct.<br></span></p><a href="#" name="id.a7h0wsr8vps9"></a><h4 class="c2"><a name="h.ejzzw7tu534b"></a><span>Type of a Function</span></h4><p class="c2"><span>If a function does not declare a return type explicitly, its return type is </span><span class="c5 c6">Dynamic</span><span>.</span></p><p class="c2"><span> Let </span><span class="c3">F</span><span> be a function with required formal parameters </span><span class="c3">T</span><span class="c9 c3">1</span><span class="c3"> p</span><span class="c9 c3">1</span><span class="c3">, …, T</span><span class="c9 c3">n</span><span class="c3"> p</span><span class="c9 c3">n</span><span>., return type </span><span class="c3">T</span><span class="c9 c3">0</span><span> </span><span>and named optional parameters </span><span class="c3">T</span><span class="c9 c3">n+1</span><span class="c3"> p</span><span class="c9 c3">n+1</span><span class="c3">, . . . , T</span><span class="c9 c3">n+k</span><span class="c3"> p</span><span class="c9 c3">n+k</span><span class="c3">.</span><span class="c5"> </span><span>Then the type of </span><span class="c3">F</span><span> is</span></p><p class="c2"><span>(</span><span class="c3">T</span><span class="c9 c3">1</span><span class="c3"> , …, T</span><span class="c9 c3">n</span><span class="c3">, [p</span><span class="c9 c3">n+1</span><span class="c3">:T</span><span class="c9 c3">n+1</span><span class="c3">, …, p</span><span class="c9 c3">n+k</span><span class="c3">:T</span><span class="c9 c3">n+k</span><span class="c3">]</span><span>)</span><span class="c3"> </span><span class="c3">→</span><span class="c3"> T</span><span class="c9 c3">0</span><span class="c3">.</span></p><p class="c2 c4"><span></span></p><a href="#" name="id.o6h4ul6q3sru"></a><h2 class="c2"><a name="h.ed5f44k6gfp"></a><span>Classes</span></h2><p class="c2"><span>A class defines the form and behavior of a set of objects which are its </span><span class="c3">instances</span><span>. </span></p><p class="c2 c4"><span></span></p><a href="#" name="id.64pqsyyi6upg"></a><p class="c2"><span class="c5 c3">classDefinition:</span><span class="c3"><br>     </span><span class="c5 c6">abstract</span><span class="c3">? </span><span class="c5 c6">class</span><span class="c3"> </span><span class="c0"><a class="c8" href="#id.te0njh1fhw7g">identifier</a></span><span class="c3"> </span><span class="c0"><a class="c8" href="#id.p9q99pefxn6v">typeParameters</a></span><span class="c3">? </span><span class="c0"><a class="c8" href="#id.frtqvspfkgww">superclass</a></span><span class="c3">? </span><span class="c0"><a class="c8" href="#id.5h6h28b15vp8">interfaces</a></span><span class="c3">?<br>      &#39;{&#39; </span><span class="c0"><a class="c8" href="#id.gi9xowfrmnlw">classMemberDefinition</a></span><span class="c3">* &#39;}&#39;<br>    ;<br><br></span><a href="#" name="id.gi9xowfrmnlw"></a><span class="c5 c3">classMemberDefinition:</span><span class="c3"><br>      </span><span class="c0"><a class="c8" href="#id.723wzts63cdy">declaration</a></span><span class="c3"> &#39;;&#39;<br>    | </span><span class="c0"><a class="c8" href="#id.z6otqtmvmk16">methodSignature</a></span><span class="c3"> </span><span class="c0"><a class="c8" href="#id.twypn7sgnd3j">functionBody</a></span><span class="c3"><br>    ;<br></span></p><p class="c2 c4"><span></span></p><a href="#" name="id.z6otqtmvmk16"></a><p class="c2"><span class="c5 c3">methodSignature:</span><span class="c3"><br>      </span><span class="c0"><a class="c8" href="#id.xcry94lhv85u">factoryConstructorSignature</a></span><span class="c3"><br>    | </span><span class="c5 c6">static</span><span class="c3">? </span><span class="c0"><a class="c8" href="#id.7ttlaph5nhkh">functionSignature</a></span><span class="c3"><br>    | </span><span class="c0"><a class="c8" href="#id.utm3o466r3od">getterSignature</a></span></p><p class="c2"><span class="c3">    | </span><span class="c0"><a class="c8" href="#id.qdrk084cdrn3">setterSignature</a></span></p><p class="c2"><span class="c3">    | </span><span class="c0"><a class="c8" href="#id.6nkf54b7sdlk">operatorSignature</a></span><span class="c3"><br>    | </span><span class="c0"><a class="c8" href="#kix.hw33d2of06k2">constructorSignature</a></span><span class="c3"> </span><span class="c0"><a class="c8" href="#id.rzzedc987gnp">initializers</a></span><span class="c3">?<br>    ;<br><br></span><a href="#" name="id.723wzts63cdy"></a><span class="c5 c3">declaration:</span><span class="c3"><br>      </span><span class="c0"><a class="c8" href="#id.v89lf7v68kxd">constantConstructorSignature</a></span><span class="c3"> (</span><span class="c0"><a class="c8" href="#id.esidjylk5k5o">redirection</a></span><span class="c3"> | </span><span class="c0"><a class="c8" href="#id.rzzedc987gnp">initializers</a></span><span class="c3">)?<br>    | </span><span class="c0"><a class="c8" href="#kix.hw33d2of06k2">constructorSignature</a></span><span class="c3"> (</span><span class="c0"><a class="c8" href="#id.esidjylk5k5o">redirection</a></span><span class="c3"> | </span><span class="c0"><a class="c8" href="#id.rzzedc987gnp">initializers</a></span><span class="c3">)?<br>    | </span><span class="c5 c6">abstract</span><span class="c3"> </span><span class="c0"><a class="c8" href="#id.utm3o466r3od">getterSignature</a></span></p><p class="c2"><span class="c3">    | </span><span class="c5 c6">abstract</span><span class="c3"> </span><span class="c0"><a class="c8" href="#id.qdrk084cdrn3">setterSignature</a></span></p><p class="c2"><span class="c3">    | </span><span class="c5 c6">abstract</span><span class="c3"> </span><span class="c0"><a class="c8" href="#id.6nkf54b7sdlk">operatorSignature</a></span><span class="c3"><br>    | </span><span class="c5 c6">abstract</span><span class="c3"> </span><span class="c0"><a class="c8" href="#id.7ttlaph5nhkh">functionSignature</a></span><span class="c3"><br>    | </span><span class="c5 c6">static</span><span class="c6"> (</span><span class="c5 c6">final </span><span class="c6">|</span><span class="c5 c6"> const</span><span class="c6">)</span><span class="c3"> </span><span class="c0"><a class="c8" href="#id.qv2a3rupuer9">type</a></span><span class="c3">? </span><span class="c0"><a class="c8" href="#id.uz2qeuvvrq3r">staticFinalDeclarationList</a></span></p><p class="c2"><span class="c3">    | </span><span class="c5 c6">const</span><span class="c3"> </span><span class="c0"><a class="c8" href="#id.qv2a3rupuer9">type</a></span><span class="c3">? </span><span class="c0"><a class="c8" href="#id.uz2qeuvvrq3r">staticFinalDeclarationList</a></span><span class="c3">  </span></p><p class="c2"><span class="c3">    | </span><span class="c5 c6">final</span><span class="c3"> </span><span class="c0"><a class="c8" href="#id.qv2a3rupuer9">type</a></span><span class="c3">? </span><span class="c0"><a class="c8" href="#id.cjgl4bau1n1l">initialized</a></span><span class="c0"><a class="c8" href="#id.cjgl4bau1n1l">IdentifierList</a></span><span class="c3"><br>    | </span><span class="c5 c6">static</span><span class="c3">? (</span><span class="c5 c6">var</span><span class="c3"> | </span><span class="c0"><a class="c8" href="#id.qv2a3rupuer9">type</a></span><span class="c3">) </span><span class="c0"><a class="c8" href="#id.cjgl4bau1n1l">initialized</a></span><span class="c0"><a class="c8" href="#id.cjgl4bau1n1l">IdentifierList</a></span><span class="c3"><br>    ;<br></span></p><a href="#" name="id.uz2qeuvvrq3r"></a><p class="c2"><span class="c5 c3">staticFinalDeclarationList:</span><span class="c3"><br>    : </span><span class="c0"><a class="c8" href="#id.ljxm87kv8in9">staticFinalDeclaration</a></span><span class="c3"> (&#39;,&#39; </span><span class="c0"><a class="c8" href="#id.ljxm87kv8in9">staticFinalDeclaration</a></span><span class="c3">)*<br>    ;<br><br></span><a href="#" name="id.ljxm87kv8in9"></a><span class="c5 c3">staticFinalDeclaration</span><span class="c5 c3">:</span><span class="c3"><br>      </span><span class="c0"><a class="c8" href="#id.te0njh1fhw7g">identifier</a></span><span class="c3"> &#39;=&#39; </span><span class="c0"><a class="c8" href="#id.1u3vxuwrz6py">expression</a></span><span class="c3"><br>    ;<br><br><br></span><span>A</span><span> class has constructors,  instance members and static members. The instance members of a class are its instance methods, getters, setters and instance variables. The static members of a class are its static methods, getters, setters and static variables. </span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Every class has a single superclass except class </span><span class="c6">Object</span><span> which has no superclass. A class may implement a </span><span>number of interfaces</span><span> by declaring them in its </span><span class="c5 c6">implements</span><span> clause.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>An </span><span class="c3">abstract class</span><span> is a class that is either explicitly </span><span>declared</span><span> with the </span><span class="c5 c6">abstract</span><span> modifier, or a </span><span>class that </span><span>declares</span><span> at least one abstract method. </span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span class="c3 c14">The </span><span class="c5 c3 c14 c6">abstract</span><span class="c3 c14"> modifier for classes </span><span class="c3 c14">is intended to be </span><span class="c3 c14">used in scenarios where an abstract class A inherits from another abstract class B. In such a situation, it may be that A itself does not declare any abstract methods. In the absence of an abstract modifier on the class, the class would be interprete</span><span class="c3 c14">d as</span><span class="c3 c14"> a concrete class. However, we want different behavior for concrete classes and abstract classes. If A is intended to be abstract, we want the static checker to warn about any attempt to instantiate A, and we do not want the checker to complain about unimplemented methods in A. In contrast, if A is intended to be concrete, the checker should warn about all unimplemented methods, but allow clients to instantiate it freely.</span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><p class="c2"><span>The </span><span class="c3">interface of class C</span><span> is an implicit interface that declares instance members that correspond to the instance members declared by </span><span class="c3">C,</span><span> and whose direct superinterfaces are the direct superinterfaces of </span><span class="c3">C.</span><span> When a class name appears as type or interface, that name denotes the interface of the class.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>It is a compile-time error if a class declares two members of the same name, except that a getter and a setter may be declared with the same name provided both are instance members or both are static members.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c3 c14">What about a final instance variable and a setter? This case is illegal as well. If the setter is setting the variable, the variable should not be final. </span></p><p class="c2"><span class="c3"><br><br></span><span>It is a compile-time error if a class has two member variables with the same name. It is a compile-time error if a class has an instance method and a static member method with the same name.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c11">Here are simple examples, that illustrate the difference between “has a member” and “declares a member”. For example, </span><span class="c11 c6">B</span><span class="c11"> </span><span class="c11 c3">declares</span><span class="c11"> one member named </span><span class="c11 c6">f</span><span class="c11">, but </span><span class="c11 c3">has</span><span class="c11"> two such members. The rules of inheritance determine what members a class has.</span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span class="c5 c11 c6">class</span><span class="c11 c6"> A {</span></p><p class="c2"><span class="c11 c6">  </span><span class="c5 c11 c6">var</span><span class="c11 c6"> i = 0;</span></p><p class="c2"><span class="c11 c6">  </span><span class="c5 c11 c6">var</span><span class="c11 c6"> j;</span></p><p class="c2"><span class="c11 c6">  f(x) =&gt; 3;</span></p><p class="c2"><span class="c11 c6">}</span></p><p class="c2 c4"><span class="c11 c6"></span></p><p class="c2"><span class="c5 c11 c6">class</span><span class="c11 c6"> B </span><span class="c5 c11 c6">extends</span><span class="c11 c6"> A {</span></p><p class="c2"><span class="c11 c6">  int i = 1; // compile-time error: B has two variables with same name i</span></p><p class="c2"><span class="c11 c6">  </span><span class="c5 c11 c6">static</span><span class="c11 c6"> j; // compile-time error: B has two variables with same name j</span></p><p class="c2"><span class="c11 c6">  </span><span class="c5 c11 c6">static</span><span class="c11 c6"> f(x) =&gt; 3; // compile-time error: static method conflicts with instance method</span></p><p class="c2"><span class="c11 c6">}</span></p><p class="c2 c4"><span class="c11 c6"></span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><a href="#" name="id.6kuu1330zv2p"></a><h3 class="c2"><a name="h.ze2p6bhp40it"></a><span>Instance Methods</span></h3><p class="c2 c4"><span></span></p><p class="c2"><span class="c3">Instance methods</span><span> are </span><span class="c1"><a class="c8" href="#kix.v3h5pp33ioek">functions</a></span><span> whose declarations are immediately contained within a class declaration and that are not declared </span><span class="c5 c6">static</span><span>. The instance methods of a class </span><span class="c3">C</span><span> are those instance methods declared by </span><span class="c3">C</span><span> and the instance methods inherited by </span><span class="c3">C</span><span> from its superclass.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>It is a compile-time error if an instance method </span><span class="c3">m</span><span class="c9 c3">1</span><span> overrides an instance member </span><span class="c3">m</span><span class="c9 c3">2</span><span> and  </span><span class="c3">m</span><span class="c9 c3">1</span><span> has a different number of required parameters than </span><span class="c3">m</span><span class="c9 c3">2</span><span>. It is a compile-time error if an instance method </span><span class="c3">m</span><span class="c9 c3">1</span><span> overrides  an instance member </span><span class="c3">m</span><span class="c9 c3">2</span><span> and  </span><span class="c3">m</span><span class="c9 c3">1</span><span> does not declare all the named parameters declared by </span><span class="c3">m</span><span class="c9 c3">2</span><span> in the same order. </span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><p class="c2"><span> It is a static warning if an instance method</span><span class="c3"> m</span><span class="c9 c3">1</span><span> overrides an instance method </span><span class="c3">m</span><span class="c9 c3">2</span><span> and the type of </span><span class="c3">m</span><span class="c9 c3">1</span><span> is not a </span><span>subtype</span><span> of the type of </span><span class="c3">m</span><span class="c9 c3">2</span><span>. </span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><a href="#" name="id.t8nep39l3cq0"></a><h4 class="c2"><a name="h.csqy2h5zh7b0"></a><span>Abstract Methods</span></h4><p class="c2 c4"><span></span></p><p class="c2"><span>An </span><span class="c3">abstract method</span><span> declares an instance method without providing an implementation. The declaration of an abstract method is prefixed by the built in identifier </span><span class="c5 c6">abstract</span><span class="c6">.</span><span class="c19"> </span><span>It is a compile-time error to specify a body</span><span> for an abstract method. It is a compile-time error if any default values are specified in the signature of an abstract method. </span><span class="c19">This could all be enforced syntactically. </span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Invoking an abstract method always results in a run-time error. This must be an instance of  </span><span class="c6">NoSuchMethodError</span><span> or an instance of a subclass of </span><span class="c6">NoSuchMethodError</span><span>, such as </span><span class="c6">AbstractMethodError</span><span>.</span><span class="c19"> </span></p><p class="c2 c4"><span class="c19"></span></p><p class="c2"><span class="c11">These errors are ordinary objects and are therefore catchable.</span></p><p class="c2 c4"><span class="c19"></span></p><p class="c2"><span>Unless explicitly stated otherwise, a</span><span>ll ordinary rules that apply to methods apply to abstract methods.</span></p><p class="c2 c4"><span class="c21"></span></p><a href="#" name="id.qd5b7xk45uot"></a><h4 class="c2"><a name="h.8z01vn73qf90"></a><span>Operators</span></h4><p class="c2 c4"><span></span></p><p class="c2"><span>Operators are instance methods with special names. </span></p><p class="c2 c4"><span></span></p><a href="#" name="id.6nkf54b7sdlk"></a><p class="c2"><span class="c5 c3">operatorSignature:</span></p><p class="c2"><span class="c3">       </span><span class="c0"><a class="c8" href="#id.mriqqq9dwbm5">returnType</a></span><span class="c3">? </span><span class="c5 c6">operator</span><span class="c3"> operator </span><span class="c0"><a class="c8" href="#id.6xer2paz3k7q">formalParameterList</a></span><span class="c3"><br>       ;</span></p><p class="c2"><span class="c3"><br></span><a href="#" name="kix.24ocm01qa635"></a><span class="c5 c3">operator:</span><span class="c3"><br>      </span><span class="c0"><a class="c8" href="#kix.d4e5p7r887m5">unaryOperator</a></span><span class="c3"><br>    | </span><span class="c0"><a class="c8" href="#kix.2skk1yl46yms">binaryOperator</a></span><span class="c3"><br>    | &#39;[&#39; &#39;]&#39;<br>    | &#39;[&#39; &#39;]&#39; &#39;=&#39;<br>    | </span><span class="c5 c6">negate</span></p><p class="c2"><span class="c3">    | </span><span class="c5 c6">call</span></p><p class="c2"><span class="c5 c6">    </span><span>|</span><span class="c5 c6"> equals</span><span class="c3"><br></span><span class="c3">    ;<br><br></span><a href="#" name="kix.d4e5p7r887m5"></a><span class="c5 c3">unaryOperator:</span><span class="c3"><br>      </span><span class="c0"><a class="c8" href="#kix.nn6yp71tfizq">negateOperator</a></span><span class="c3"><br>    ;<br><br></span><a href="#" name="kix.2skk1yl46yms"></a><span class="c5 c3">binaryOperator:</span><span class="c3"><br>      </span><span class="c0"><a class="c8" href="#id.q23phy16kl7s">multiplicativeOperator</a></span><span class="c3"><br>    | </span><span class="c0"><a class="c8" href="#id.zg2oy42p83ut">additiveOperator</a></span><span class="c3"><br>    | </span><span class="c0"><a class="c8" href="#id.m87pll3ti0gq">shiftOperator</a></span><span class="c3"><br>    | </span><span class="c0"><a class="c8" href="#id.dqm1hvagt3y5">relationalOperator</a></span><span class="c3"><br>    | </span><span class="c0"><a class="c8" href="#id.udvn0y5cd5a9">equalityOperator</a></span><span class="c3"><br>    | </span><span class="c0"><a class="c8" href="#id.mp6goh4wcueb">bitwiseOperator</a></span><span class="c3"><br>    ;</span></p><p class="c2 c4"><span class="c3"></span></p><a href="#" name="id.ddbfdqqeafna"></a><p class="c2"><span class="c5 c3">prefixOperator:</span><span class="c3"><br>       &#39;-&#39;</span></p><p class="c2"><span class="c3">    | </span><span class="c0"><a class="c8" href="#kix.nn6yp71tfizq">negateOperator</a></span><span class="c3"><br>    ;</span></p><p class="c2"><span class="c3"><br><br></span><a href="#" name="kix.nn6yp71tfizq"></a><span class="c5 c3">negateOperator:</span><span class="c3"><br>      &#39;!&#39;<br>    | &#39;~&#39;<br>    ;<br></span></p><p class="c2"><span>An operator declaration is identified with built-in identifier </span><span class="c5 c6">operator.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>The following names are allowed for user-defined operators: </span><span class="c6">&lt;, &gt;, &lt;=, &gt;=, -, +, /, ~/,  *, %, |, ^, &amp;, &lt;&lt;, &gt;&gt;, []=, [], ~, </span><span class="c5 c6">call</span><span class="c6">, </span><span class="c5 c6">equals</span><span class="c6">, </span><span class="c5 c6">negate</span><span class="c6">. </span></p><p class="c2 c4"><span class="c6"></span></p><p class="c2"><span>The built-in identifier </span><span class="c5 c6">call</span><span> is used to denote function application ( ()  ). The built-in identifier </span><span class="c5 c6">equals</span><span> is used to denote equality (==). The built-in identifier </span><span class="c5 c6">negate</span><span> is used to denote </span><span>unary minus</span><span>. </span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c11">Defining a nullary method named </span><span class="c5 c11 c6">negate</span><span class="c11"> or a unary method named </span><span class="c5 c11 c6">equals</span><span class="c11"> or a </span><span class="c5 c11 c6">call</span><span class="c11"> method of any arity, will have the same effect as defining an operator, but is considered bad style, and will cause a static warning.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c3 c14">It is tempting to define it to be a compile-time error to declare a method named </span><span class="c5 c3 c14 c6">call</span><span class="c3 c14"> , </span><span class="c5 c3 c14 c6">equals</span><span class="c3 c14"> or </span><span class="c5 c3 c14 c6">negate</span><span class="c3 c14">. However, this causes compatibility problems.  Since all three are </span><span class="c0"><a class="c8" href="#id.ayq1ul833tkz">built-in identifiers</a></span><span class="c3 c14">, unsanctioned use will cause a static warning, which is arguably sufficient to alert the programmer to the fact that the ported code is not likely to work as intended. In fresh Dart code, the warning will indicate that either the built-in identifier </span><span class="c5 c3 c14 c6">operator</span><span class="c3 c14"> was forgotten, or that the method should have a different name.</span></p><p class="c2 c4"><span class="c6"></span></p><p class="c2"><span>It is a compile-time error if the number of formal parameters of the user-declared operator </span><span class="c6">[]=</span><span> is not 2.</span><span class="c6"> </span><span>It is a compile time error if the number of formal parameters of a user-declared operator with one of the names:  </span><span class="c5 c6">equals</span><span class="c6">, &lt;, &gt;, &lt;=, &gt;=, -, +, /, ~/, *, %, |, ^, &amp;, &lt;&lt;, &gt;&gt;, []</span><span> is not 1. It is a compile time error if the arity of a user-declared operator with one of the names: </span><span class="c6">~,</span><span class="c6"> </span><span class="c5 c6">negate</span><span> is not 0. </span></p><p class="c2 c4"><span></span></p><p class="c2"><span>It is a compile-time error to declare an optional named parameter in an operator. </span><span>The operator </span><span class="c5 c6">call</span><span> can have any arity.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>It is a compile-time error to declare an optional named parameter in an operator, with the exception of the operator </span><span class="c5 c6">call</span><span>.</span></p><p class="c2 c4"><span class="c6"></span></p><p class="c2"><span>It is a static warning if the return type of the user-declared operator </span><span class="c6">[]=</span><span> is explicitly declared  and not </span><span class="c5 c6">void</span><span>. It is a static warning if the return type of the operator </span><span class="c5 c6">equals</span><span> is explicitly declared and is not </span><span class="c6">bool</span><span>. It is a static warning if the return type of the operator </span><span class="c5 c6">negate</span><span> is explicitly declared and not a numerical type.</span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><a href="#" name="kix.wlocpej6rvqa"></a><h3 class="c2"><a name="h.semn73yhmkb5"></a><span>Getters </span></h3><p class="c2 c4"><span></span></p><p class="c2"><span>Getters are </span><span class="c1"><a class="c8" href="#kix.v3h5pp33ioek">functions</a></span><span> that are used to retrieve the values of object properties. </span></p><p class="c2 c4"><span></span></p><a href="#" name="id.utm3o466r3od"></a><p class="c2"><span class="c5 c3">getterSignature:</span><span class="c3"><br>      </span><span class="c5 c6">static</span><span class="c3">? </span><span class="c0"><a class="c8" href="#id.mriqqq9dwbm5">returnType</a></span><span class="c3">? </span><span class="c5 c6">get</span><span class="c3"> </span><span class="c0"><a class="c8" href="#id.te0njh1fhw7g">identifier</a></span><span class="c3"> </span><span class="c0"><a class="c8" href="#id.6xer2paz3k7q">formalParameterList</a></span></p><p class="c2 c4"><span></span></p><p class="c2"><span>If no return type is specified, the return type of the getter </span><span>is </span><span class="c5 c6">Dynamic</span><span class="c6">.</span></p><p class="c2 c4"><span class="c6"></span></p><p class="c2"><span>A getter definition that is prefixed with the </span><span class="c5 c6">static</span><span> modifier defines a </span><span>static</span><span> getter. Otherwise, it defines an instance getter. The name of the getter is given by the identifier in the definition.</span></p><p class="c2 c4"><span class="c6"></span></p><p class="c2"><span>It is a compile-time error if a getter’s formal parameter list is not empty.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>It is a compile-time error if a class has both a </span><span>getter and a method with the same name</span><span>. This restriction holds regardless of whether the getter is defined explicitly or implicitly, or whether the getter or the method are inherited or not.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c11">This implies that a getter can never override a method, and a method can never override a getter or field. </span></p><p class="c2 c4"><span></span></p><p class="c2"><span>It is a static warning if a getter </span><span class="c3">m</span><span class="c9 c3">1</span><span> overrides a getter </span><span class="c3">m</span><span class="c9 c3">2</span><span> and the type of </span><span class="c3">m</span><span class="c9 c3">1</span><span> is not a subtype of the type of </span><span class="c3">m</span><span class="c9 c3">2</span><span>.</span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><a href="#" name="kix.i4xvz9z9edz"></a><h3 class="c2"><a name="h.xn3nrcf01kbi"></a><span>Setters</span></h3><p class="c2 c4"><span class="c5 c30"></span></p><p class="c2"><span>Setters are </span><span class="c1"><a class="c8" href="#kix.v3h5pp33ioek">functions</a></span><span> that are used to set the values of object properties.</span></p><p class="c2 c4"><span></span></p><a href="#" name="id.qdrk084cdrn3"></a><p class="c2"><span class="c5 c3">setterSignature:</span><span class="c3"><br>      </span><span class="c5 c6">static</span><span class="c3">? </span><span class="c0"><a class="c8" href="#id.mriqqq9dwbm5">returnType</a></span><span class="c3">? </span><span class="c5 c6">set</span><span class="c3"> </span><span class="c0"><a class="c8" href="#id.te0njh1fhw7g">identifier</a></span><span class="c3"> </span><span class="c0"><a class="c8" href="#id.dbnqav8zbk9d">formalParameterList</a></span></p><p class="c2 c4"><span></span></p><p class="c2"><span>If no return type is specified, the return type of the setter is </span><span class="c5 c6">Dynamic</span><span class="c6">.</span></p><p class="c2 c4"><span class="c6"></span></p><p class="c2"><span>A setter definition that is prefixed with the </span><span class="c5 c6">static</span><span> modifier defines a static setter. Otherwise, it defines an instance setter. The name of the setter is given by the identifier in the definition.</span></p><p class="c2 c4"><span class="c6"></span></p><p class="c2"><span>It is a compile-time error if a setter’s formal parameter list does not include exactly one required  formal parameter </span><span class="c3">p.</span><span> </span><span class="c3 c14">We could enforce this via the grammar, but we’d have to specify the evaluation rules in that case.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>It is a compile-time error if a class has both a setter and a method with the same name. This restriction holds regardless of whether the setter is defined explicitly or implicitly, or whether the setter or the method are inherited or not.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c11">Hence, a setter can never override a method, and a method can never override a setter. </span></p><p class="c2 c4"><span></span></p><p class="c2"><span>It is a static warning if a setter declares a </span><span>return type </span><span>other than </span><span class="c5 c6">void</span><span>. </span><span>It is a static warning if a setter </span><span class="c3">m</span><span class="c9 c3">1</span><span> overrides a setter </span><span class="c3">m</span><span class="c9 c3">2</span><span> and the type of </span><span class="c3">m</span><span class="c9 c3">1</span><span> is not a </span><span>subtype</span><span> of the type of </span><span class="c3">m</span><span class="c9 c3">2</span><span>. It is a static warning if a class has a setter with argument type </span><span class="c3">T</span><span> and a getter of the same name with return type </span><span class="c3">S</span><span>, and </span><span class="c3">T</span><span> may not be assigned to </span><span class="c3">S.</span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span class="c3 c14"></span></p><a href="#" name="id.x0c4e7xfkarq"></a><h3 class="c2"><a name="h.dikrs7svwb70"></a><span>Instance Variables</span></h3><p class="c2"><span class="c3">Instance variables</span><span> are </span><span class="c1"><a class="c8" href="#kix.6b1cgvgf1cyq">variables</a></span><span> whose declarations are immediately contained within a class declaration and that are not declared static. The instance variables of a class </span><span class="c3">C</span><span> are those instance variables declared by </span><span class="c3">C</span><span> and the instance variables inherited by </span><span class="c3">C</span><span> from its superclass.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>It is a compile-time error if an instance variable declaration has one of the forms </span><span class="c3">T v = e;</span><span>,</span><span class="c3"> </span><span class="c5 c3 c6">var</span><span class="c3"> v = e;</span><span>, </span><span class="c5 c3 c6">const</span><span class="c5 c6"> </span><span class="c3">T v = e;</span><span>,</span><span class="c3"> </span><span class="c5 c3 c6">const</span><span class="c3"> v = e;</span><span>, </span><span class="c5 c3 c6">final</span><span> </span><span class="c3">T v = e;</span><span> or</span><span class="c3"> </span><span class="c5 c3 c6">final</span><span class="c3"> v = e; </span><span>and the expression </span><span class="c3">e</span><span> is not a </span><span class="c1"><a class="c8" href="#id.hzs87hup8wb">compile-time constant</a></span><span>.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c3 c14">In Dart, all uninitialized variables have the value </span><span class="c5 c3 c14 c6">null</span><span class="c3 c14">, regardless of type. Numeric variables in particular must, therefore,  be explicitly initialized; such variables will </span><span class="c5 c3 c14">not</span><span class="c3 c14"> be initialized to 0 by default. The form above is intended to ease the burden of such initialization.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>An instance variable declaration of one of the forms </span><span class="c3">T v;</span><span>,</span><span class="c3"> </span><span class="c5 c6">final</span><span> </span><span class="c3">T v;</span><span> , </span><span class="c3">T v = e;</span><span>, </span><span class="c5 c3 c6">const</span><span class="c3"> T v = e;</span><span class="c3">  </span><span>or</span><span class="c3"> </span><span class="c5 c3 c6">final</span><span class="c3"> T v = e;</span><span class="c3"> </span><span>always induces an implicit </span><span class="c1"><a class="c8" href="#kix.wlocpej6rvqa">getter function</a></span><span> with signature</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c3">T get v()</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>whose  invocation evaluates to the value stored in </span><span class="c3">v.</span></p><p class="c2"><span>An instance variable declaration of one of the forms </span><span class="c5 c3 c6">var</span><span class="c3"> v;</span><span>,</span><span class="c3"> </span><span class="c5 c3 c6">final</span><span class="c3"> v;</span><span>,</span><span class="c3"> </span><span class="c5 c3 c6">var</span><span class="c3"> v = e;</span><span>, </span><span class="c5 c3 c6">const</span><span class="c3">  v = e;</span><span class="c3">  </span><span> or</span><span class="c3"> </span><span class="c5 c3 c6">final</span><span class="c3"> v = e;</span><span> always induces an implicit </span><span class="c1"><a class="c8" href="#kix.wlocpej6rvqa">getter function</a></span><span> with signature</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c3">get v()</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>whose  invocation evaluates to the value stored in </span><span class="c3">v.</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span class="c11">Getters are introduced for all instance and static variables, regardless of whether they are final or not.</span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span>A non-final instance variable declaration of the form </span><span class="c3">T v;</span><span> or the form </span><span class="c3">T v = e; </span><span>always induces an implicit </span><span class="c1"><a class="c8" href="#kix.i4xvz9z9edz">setter function</a></span><span> with signature</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c5 c3 c6">void</span><span class="c3"> set v(T x)</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>whose execution sets the value of </span><span class="c3">v</span><span> to the incoming argument </span><span class="c3">x.</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span>A non-final instance variable declaration of the form </span><span class="c5 c3 c6">var </span><span class="c3">v;</span><span> or the form </span><span class="c5 c3 c6">var</span><span class="c3"> v = e; </span><span>always induces an implicit </span><span class="c1"><a class="c8" href="#kix.i4xvz9z9edz">setter function</a></span><span> with signature</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c3">set v(x)</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>whose execution sets the value of </span><span class="c3">v</span><span> to the incoming argument </span><span class="c3">x.</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><a href="#" name="id.yh8ud94ky84"></a><h3 class="c2"><a name="h.500yt9xvog42"></a><span>Constructors</span></h3><p class="c2 c4"><span></span></p><p class="c2"><span>A </span><span class="c3">constructor</span><span> is a special member that is used in instance creation expressions (</span><span class="c1"><a class="c8" href="#id.hvkbnlui8uvu">instanceCreation</a></span><span>) to produce objects. Constructors may be </span><span class="c10"><a class="c8" href="#id.e2bn3056d7ls">generative</a></span><span> or they may be </span><span class="c10"><a class="c8" href="#id.ue4n89yodj3k">factories</a></span><span>. </span></p><p class="c2 c4"><span></span></p><p class="c2"><span>A </span><span class="c3">constructor name</span><span> always begins with the name of its immediately enclosing class or interface, and may optionally be followed by a dot and an identifier. It is a compile-time error if the name of a non-factory constructor is not </span><span>a c</span><span>onstructor name. </span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c11">Interfaces can have constructor Signatures (but not bodies). See the discussion of factories.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Iff no constructor is specified for a class </span><span class="c3">C,</span><span> it implicitly has </span><span>a default constructor </span><span class="c6">C() : super() {}, , </span><span>unless </span><span class="c3">C</span><span> is class </span><span class="c6">Object.</span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><a href="#" name="id.e2bn3056d7ls"></a><h4 class="c2"><a name="h.flm5xvbwhs6u"></a><span>Generative Constructors</span></h4><p class="c2 c4"><span></span></p><p class="c2"><span>A </span><span class="c3">generative constructor</span><span> consists of a constructor name, a constructor parameter list, an initializer list and </span><span>a</span><span>n optional body.</span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><a href="#" name="kix.hw33d2of06k2"></a><p class="c2"><span class="c5 c3">constructorSignature:</span><span class="c3"><br>      </span><span class="c0"><a class="c8" href="#id.te0njh1fhw7g">identifier</a></span><span class="c3"> </span><span class="c1 c3"><a class="c8" href="#id.6xer2paz3k7q">formalParameterList</a></span><span class="c3"><br>    | </span><span class="c1 c3"><a class="c8" href="#id.fpsafrn7f9m5">namedConstructorSignature</a></span><span class="c3"><br>    ;</span></p><p class="c2 c4"><span></span></p><a href="#" name="kix.nci152d728t"></a><p class="c2"><span class="c5 c3">namedConstructorSignature:</span><span class="c3"><br>      </span><span class="c0"><a class="c8" href="#id.te0njh1fhw7g">identifier</a></span><span class="c3"> &#39;.&#39; </span><span class="c0"><a class="c8" href="#id.te0njh1fhw7g">identifier</a></span><span class="c3"> </span><span class="c1 c3"><a class="c8" href="#id.6xer2paz3k7q">formalParameterList</a></span><span class="c3"><br>    ;<br></span></p><p class="c2 c4"><span></span></p><p class="c2"><span>A </span><span class="c3">constructor parameter list </span><span>is a parenthesized, comma-separated list of formal constructor parameters. A </span><span class="c3">formal constructor parameter</span><span> is either a </span><span class="c1"><a class="c8" href="#id.dbnqav8zbk9d">formal parameter</a></span><span> or an initializing formal. An </span><span class="c3">initializing formal</span><span> has the form </span><span class="c5 c6">this</span><span class="c6">.id. </span><span> It is a compile-time error if </span><span class="c6">id</span><span> is not the name of an instance variable of the immediately enclosing class. It is a compile-time error if an initializing formal is used by a function other than a non-redirecting generative constructor.  </span></p><p class="c2 c4"><span></span></p><p class="c2"><span>If an explicit type is attached to the initializing formal, that is its static type. Otherwise, the type of an initializing formal named </span><span class="c6">id</span><span> is </span><span class="c3">T</span><span class="c9 c3">id</span><span>, where </span><span class="c3">T</span><span class="c9 c3">id </span><span>is the type of the field named </span><span class="c6">id </span><span>in the immediately enclosing class. </span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Using an initializing formal </span><span class="c5 c6">this</span><span class="c6">.id </span><span>in a formal parameter list does not introduce a formal parameter name into the scope of the constructor. However, the initializing formal does effect the type of the constructor function exactly as if </span><span>a formal parameter named </span><span class="c6">id</span><span> of the same type were introduced in the same position. </span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c11">The above rule allows initializing formals to be used as optional parameters:</span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span class="c11">class A {</span></p><p class="c2"><span class="c11">  int x;</span></p><p class="c2"><span class="c11">  A([this.x]);</span></p><p class="c2"><span class="c11">}</span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span class="c11">is legal, and has the same effect as</span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span class="c11">class A { </span></p><p class="c2"><span class="c11">  int x;</span></p><p class="c2"><span class="c11">  A([int x]): this.x = x;</span></p><p class="c2"><span class="c11">}</span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span class="c11">No warning is issued over shadowing in this case.</span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2 c4"><span></span></p><p class="c2"><span>A </span><span class="c3">fresh instance</span><span> is an instance whose identity is distinct from any previously allocated instance of its class. A generative constructor always allocates a </span><span>fresh instance </span><span>of its immediately enclosing class. </span><span class="c21">The above holds if the constructor is actually run, as it is by </span><span class="c21 c5 c6">new</span><span class="c21 c6">.</span><span class="c21"> If a constructor </span><span class="c21 c3">c</span><span class="c21"> is referenced by </span><span class="c21 c5 c6">const</span><span class="c21 c6">,</span><span class="c21"> </span><span class="c21 c3">c</span><span class="c21"> may not be run; instead, a canonical object may be looked up. See the section on </span><span class="c1"><a class="c8" href="#id.hvkbnlui8uvu">instance creation</a></span><span class="c21">.</span></p><p class="c2 c4"><span class="c21"></span></p><p class="c2"><span>If a generative constructor </span><span class="c3">c</span><span>  is not a redirecting constructor and no body is provided, then </span><span class="c3">c</span><span> implicitly has an empty body {}.</span></p><p class="c2 c4"><span></span></p><a href="#" name="id.joo06zfmou7z"></a><h5 class="c2"><a name="h.mnfuvjel4wl1"></a><span>Redirecting Constructors</span></h5><p class="c2 c4"><span></span></p><p class="c2"><span>A generative constructor may be </span><span class="c3">redirecting</span><span>, in which case its only action is to invoke another generative constructor. A redirecting constructor has no body; instead, it has a redirect clause that specifies which constructor the invocation is redirected to, and with what arguments.</span></p><p class="c2 c4"><span></span></p><a href="#" name="id.esidjylk5k5o"></a><p class="c2"><span class="c5 c3">redirection:</span><span class="c3"><br>     &#39;:&#39; </span><span class="c5 c6">this</span><span class="c3"> (&#39;.&#39; </span><span class="c0"><a class="c8" href="#id.te0njh1fhw7g">identifier</a></span><span class="c3">)? </span><span class="c1 c3"><a class="c8" href="#kix.xl2ewwstkqba">arguments</a></span><span class="c3"><br>    ;<br></span></p><p class="c2 c4"><span></span></p><a href="#" name="id.9ffw73x9vb3v"></a><h5 class="c2"><a name="h.7ybyo5btajop"></a><span>Initializer Lists</span></h5><p class="c2 c4"><span></span></p><p class="c2"><span>An </span><span class="c3">initializer list</span><span> begins with a colon, and consists of a comma-separated list of individual </span><span class="c3">initializers</span><span>. There are two kinds of initializers.</span></p><ol class="c25" start="1"><li class="c7 c2"><span>A </span><span class="c3">superinitializer</span><span> identifies a </span><span class="c3">superconstructor</span><span> - that is, a specific constructor of the superclass.  Execution of the superinitializer causes the initializer list of the superconstructor to be executed.</span></li><li class="c7 c2"><span>An </span><span class="c3">instance variable initializer</span><span> assigns a value to an individual instance variable. </span></li></ol><p class="c2 c4"><span></span></p><a href="#" name="id.rzzedc987gnp"></a><p class="c2"><span class="c5 c3">initializers:</span><span class="c3"><br>      &#39;:&#39; </span><span class="c1 c3"><a class="c8" href="#id.yz2abulwugs9">superCallOrFieldInitializer</a></span><span class="c3"> (&#39;,&#39; </span><span class="c1 c3"><a class="c8" href="#id.yz2abulwugs9">superCallOrFieldInitializer</a></span><span class="c3">)*<br>    ;<br></span></p><a href="#" name="id.yz2abulwugs9"></a><p class="c2"><span class="c5 c3">superCallOrFieldInitializer:</span><span class="c3"><br>      </span><span class="c5 c6">super</span><span class="c3"> </span><span class="c1 c3"><a class="c8" href="#kix.xl2ewwstkqba">arguments</a></span><span class="c3"><br>    | </span><span class="c5 c6">super</span><span class="c3"> &#39;.&#39; </span><span class="c0"><a class="c8" href="#id.te0njh1fhw7g">identifier</a></span><span class="c3"> </span><span class="c1 c3"><a class="c8" href="#kix.xl2ewwstkqba">arguments</a></span><span class="c3"><br>    | </span><span class="c0"><a class="c8" href="#id.4ncl8xtqfh3z">fieldInitializer</a></span><span class="c3"><br>    ;<br></span></p><a href="#" name="id.4ncl8xtqfh3z"></a><p class="c2"><span class="c5 c3">fieldInitializer:</span><span class="c3"><br>        (</span><span class="c5 c6">this</span><span class="c3"> &#39;.&#39;)? </span><span class="c0"><a class="c8" href="#id.te0njh1fhw7g">identifier</a></span><span class="c3"> &#39;=&#39; </span><span class="c0"><a class="c8" href="#id.u42blbh7fdm7">conditionalExpression</a></span><span class="c3"><br>    ;</span></p><p class="c2 c4"><span class="c3"><br></span></p><p class="c2"><span>Let </span><span class="c3">k</span><span> be a generative constructor. Then </span><span class="c3">k</span><span> may include at most one superinitializer in its initializer list or a compile time error occurs.  If no superinitializer is provided, an implicit superinitializer of the form </span><span class="c6">super()</span><span> is added at the end of </span><span class="c3">k</span><span>’s  initializer list, unless the enclosing class is class </span><span class="c6">Object</span><span>. It is </span><span>a</span><span> compile time error if </span><span>more than one initializer</span><span> corresponding to a given instance variable appears in </span><span class="c3">k</span><span>’s list. It is </span><span>a</span><span> compile time error if </span><span class="c3">k</span><span>’s  initializer list contains an initializer for a variable that is initialized by means of an initializing formal of </span><span class="c3">k.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span> </span></p><p class="c2"><span>E</span><span>ach final instance variable </span><span class="c3">f </span><span>declared in the immediately enclosing class must have an initializer in </span><span class="c3">k</span><span>&#39;s initializer list unless it has already been initialized by one of the following means:</span></p><ol class="c25" start="1"><li class="c7 c2"><span>Initialization at the declaration of </span><span class="c3">f.</span></li><li class="c7 c2"><span>Initialization by means of an initializing formal of </span><span class="c3">k.</span></li></ol><p class="c2 c4"><span></span></p><p class="c2"><span>or a compile-time error occurs. It is a compile-time error if </span><span class="c3">k</span><span>&#39;s initializer list contains an initializer for a variable that is not an instance variable declared in the immediately surrounding class.</span></p><p class="c2"><span> </span></p><p class="c2"><span class="c11">The  initializer list may of course contain an initializer for any instance variable declared by the immediately surrounding class, even if it is not final. </span></p><p class="c2 c4"><span></span></p><p class="c2"><span>It is a compile-time error if a generative constructor of class </span><span class="c6">Object</span><span> includes a superinitializer.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Execution of a generative constructor proceeds as follows:</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>First, a fresh instance </span><span class="c3">i</span><span> of the immediately enclosing class is allocated.  Next, the instance variable declarations of the immediately enclosing class are visited in the order they appear in the program text. For each such declaration </span><span class="c3">d</span><span>, i</span><span>f </span><span class="c3">d</span><span> has the form  </span><span class="c3">finalConstVarOrType v = e;</span><span>  then the instance variable </span><span class="c3">v</span><span> of </span><span class="c3">i</span><span> is bound to the value of </span><span class="c3">e</span><span> (which is necessarily a compile-time constant).</span></p><p class="c2"><span>Next, any initializing formals declared in the constructor&#39;s parameter list are executed in the order they appear in the program.  Then, the constructor&#39;</span><span>s</span><span> initializers are executed in the order they appear in the program.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c3 c14">We could observe the order by side effecting external routines called. So we need to specify the order.</span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><p class="c2"><span>After all the </span><span>initializers</span><span> have completed, the body of the constructor is executed in a scope where </span><span class="c5 c6">this</span><span> is bound to </span><span class="c3">i.</span><span> Execution of the body begins with execution of the body of the superconstructor with respect to t</span><span>he bindings determined by the argument list of the superinitializer</span><span> of </span><span class="c3">k.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c3 c14">This process ensures that no uninitialized final field is ever seen by code. Note that </span><span class="c1 c5 c6"><a class="c8" href="#id.v2khzso6nh04">this</a></span><span class="c3 c14"> </span><span class="c3 c14"> is not in scope on the right hand side of an initializer so no instance method can execute during initialization: an instance method cannot be directly invoked, nor can </span><span class="c14 c6">this</span><span class="c3 c14"> be passed into any other code being invoked in the initializer. </span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Execution of an initializer of the form </span><span class="c5 c6">this</span><span class="c3">.v = e</span><span> proceeds as follows:</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>First, the expression </span><span class="c3">e</span><span> is evaluated to an object </span><span class="c3">o.</span><span> Then, the instance variable </span><span class="c3">v</span><span> of the object denoted by </span><span class="c5 c6">this</span><span> is bound to </span><span class="c3">o.</span><span> </span></p><p class="c2 c4"><span></span></p><p class="c2"><span>An initializer of the form </span><span class="c3">v = e</span><span> is equivalent to an initializer of the form </span><span class="c5 c6">this</span><span class="c3">.v = e.</span><span> </span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Execution of a superinitializer of the form </span><span class="c5 c6">super</span><span class="c3">(a</span><span class="c9 c3">1</span><span class="c3">, …, a</span><span class="c9 c3">n</span><span class="c3">, x</span><span class="c9 c3">n+1</span><span class="c3">: a</span><span class="c9 c3">n+1</span><span class="c3">, …, x</span><span class="c9 c3">n+k</span><span class="c3">: a</span><span class="c9 c3">n+k</span><span class="c3">) </span><span>(respectively </span><span class="c5 c6">super</span><span class="c3 c6">.id</span><span class="c3">(a</span><span class="c9 c3">1</span><span class="c3">, …, a</span><span class="c9 c3">n</span><span class="c3">, x</span><span class="c9 c3">n+1</span><span class="c3">: an+1, …, x</span><span class="c9 c3">n+k</span><span class="c3">: a</span><span class="c9 c3">n+k</span><span class="c3">)</span><span>)</span><span class="c3"> </span><span>proceeds as follows:</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>First, the argument list </span><span class="c3">(a</span><span class="c9 c3">1</span><span class="c3">, …, a</span><span class="c9 c3">n</span><span class="c3">, x</span><span class="c9 c3">n+1</span><span class="c3">: a</span><span class="c9 c3">n+1</span><span class="c3">, …, x</span><span class="c9 c3">n+k</span><span class="c3">: a</span><span class="c9 c3">n+k</span><span class="c3">)</span><span> is evaluated.</span></p><p class="c2"><span>Let </span><span class="c3">C</span><span> be the class in which the superinitializer appears and let </span><span class="c3">S</span><span> be the superclass of </span><span class="c3">C. </span><span> If </span><span class="c3">S</span><span> is </span><span class="c1"><a class="c8" href="#id.64iudgj9wjj1">generic</a></span><span>, let </span><span class="c3">U</span><span class="c9 c3">1</span><span class="c3">, ,.., U</span><span class="c9 c3">m</span><span class="c3"> </span><span>be the actual type arguments passed to </span><span class="c3">S</span><span> in the superclass clause of </span><span class="c3">C.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Then, the initializer list of the constructor </span><span class="c3">S</span><span> (respectively </span><span class="c3">S.id</span><span>) is </span><span>executed with respect</span><span> to the bindings that resulted from the evaluation of the argument list,  with </span><span class="c5 c6">this</span><span> bound to the current binding of </span><span class="c5 c6">this,</span><span> and  the type parameters (if any) of class </span><span class="c3">S</span><span> bound to the current binding of </span><span class="c3">U</span><span class="c9 c3">1</span><span class="c3">, ,.., U</span><span class="c9 c3">m</span><span>.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>It is a compile-time </span><span>error</span><span> if class </span><span class="c3">S</span><span> does not have a constructor named </span><span class="c3">S</span><span> (respectively </span><span class="c3">S.id</span><span>)</span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><a href="#" name="id.ue4n89yodj3k"></a><h4 class="c2"><a name="h.1t7lgvdmbwt9"></a><span>Factories</span></h4><p class="c2 c4"><span></span></p><p class="c2"><span>A </span><span class="c3">factory</span><span> is a constructor prefaced by the built-in identifier </span><span class="c5 c6">factory</span><span>. </span></p><p class="c2 c4"><span class="c19"></span></p><a href="#" name="id.xcry94lhv85u"></a><p class="c2"><span class="c5 c3">factoryConstructorSignature:</span><span class="c3"><br>      </span><span class="c5 c6">factory</span><span class="c3"> </span><span class="c0"><a class="c8" href="#id.xsv95i3z7eli">qualified</a></span><span class="c3">  (&#39;.&#39; </span><span class="c0"><a class="c8" href="#id.te0njh1fhw7g">identifier</a></span><span class="c3">)? </span><span class="c1 c3"><a class="c8" href="#id.6xer2paz3k7q">formalParameterList</a></span><span class="c3"><br>    ;</span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><p class="c2"><span>The </span><span class="c3">return type</span><span> of a factory whose signature is of the form </span><span class="c5 c3 c6">factory</span><span class="c3"> M </span><span>or the form </span><span class="c5 c3 c6">factory</span><span class="c3"> M.id </span><span>is </span><span class="c3">M </span><span>if </span><span class="c3">M</span><span> is not a generic type; otherwise the return type is </span><span class="c3">M &lt;T</span><span class="c18 c3">1</span><span class="c3">, …, T</span><span class="c18 c3">n</span><span class="c3">&gt;, </span><span>where </span><span class="c3">T</span><span class="c18 c3">1</span><span class="c3">, …, T</span><span class="c18 c3">n </span><span>are the type parameters of the enclosing class.</span></p><p class="c2"><span class="c11">We are guaranteed that </span><span class="c11 c3">M</span><span class="c11"> has </span><span class="c11 c3">n</span><span class="c11"> type parameters because an interface and its factory class must have the same number of type parameters.</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span>It is a static warning if </span><span class="c3">M.id</span><span> is not either:</span></p><ol class="c25" start="1"><li class="c7 c2"><span>A constructor name.</span></li><li class="c7 c2"><span>The name of a constructor of an interface that is in scope at the point where the factory is declared.</span></li></ol><p class="c2"><span class="c3 c14">We need not consider the case where the factory is named M. The rule below ensures that if the factory name is of the form M, it will meet the requirements above.  Note also that if the constructor id is undefined in M, it cannot be called, so its existence as a factory causes little harm.</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span>It is a compile-time error if </span><span class="c3">M </span><span>is not the  </span><span>name</span><span>  of the immediately enclosing class or the name of an interface in the enclosing lexical scope. </span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span>In checked mode, it is a </span><span>dynamic type error</span><span> if a factory returns an object whose type is not a subtype of its </span><span class="c1"><a class="c8" href="#id.93yudg3nk9o1">actual return type</a></span><span>.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c3 c14">It seems useless to allow a factory to </span><span class="c3 c14">return null</span><span class="c3 c14">. But it is more uniform to allow it, as the rules currently do.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c3 c14">Factories address classic weaknesses associated with constructors in other languages.</span></p><p class="c2"><span class="c3 c14">Factories can produce instances that are not freshly allocated: they can come from a cache. Likewise, factories can return instances of different classes. </span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><a href="#" name="id.okcph2t66jnm"></a><h4 class="c2"><a name="h.gk4elj1gohb4"></a><span>Constant Constructors</span></h4><p class="c2 c4"><span></span></p><p class="c2"><span>A </span><span class="c3">constant constructor</span><span> may be used to create compile-time constant </span><span>objects.</span><span> A constant constructor is prefixed by the reserved word </span><span class="c5 c6">const.</span><span> It is a compile-time error if a constant constructor has a body.</span></p><p class="c2 c4"><span></span></p><a href="#" name="id.v89lf7v68kxd"></a><p class="c2"><span class="c5 c3">constantConstructorSignature:</span><span class="c3"><br>      </span><span class="c5 c6">const</span><span class="c3"> </span><span class="c0"><a class="c8" href="#id.xsv95i3z7eli">qualified</a></span><span class="c3"> </span><span class="c1 c3"><a class="c8" href="#id.6xer2paz3k7q">formalParameterList</a></span><span class="c3"><br>    ;</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c11">All the work of a constant constructor must be handled via its initializers.</span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span>It is a compile-time error if a constant constructor is declared by a class that has a non-final instance variable. </span></p><p class="c2"><span class="c11">The above refers to both locally declared and inherited instance variables.</span></p><p class="c2"><span>Any expression that appears within the initializer list of a constant constructor must be a potentially constant expression, or a compile-time error occurs.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>A </span><span class="c3">potentially constant expression</span><span> is an expression </span><span class="c3">e</span><span> that would be a valid constant expression if all formal parameters of </span><span class="c3">e</span><span>’s immediately enclosing constant constructor were treated as compile-time constants that were guaranteed to evaluate to an integer, boolean or string value as required by their immediately enclosing superexpression.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c11">The difference between a potentially constant expression and a </span><span class="c1"><a class="c8" href="#id.hzs87hup8wb">compile-time constant</a></span><span class="c11"> expression deserves some explanation. </span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span class="c11">The key issue is whether one treats the formal parameters of a constructor as compile-time constants. </span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span class="c11">If a constant constructor is invoked from a constant object expression, the actual arguments will be required to be compile-time constants. Therefore, if we were assured that constant constructors were always invoked from constant object expressions, we could assume that the formal parameters of a constructor were compile-time constants.</span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span class="c11">However, constant constructors can also be invoked from </span><span class="c1"><a class="c8" href="#id.pp0ymlz8g03s">ordinary instance creation expressions</a></span><span class="c11">, and so the above assumption is not generally valid.</span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span class="c11">Nevertheless, the use of the formal parameters of a constant constructor within the constructor is of considerable utility. The concept of potentially constant expressions is introduced to facilitate limited use of such formal parameters. Specifically, we allow the usage of the formal parameters of a constant constructor for expressions that involve built-in operators, but not for constant objects, lists and maps. This allows for constructors such as:</span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span class="c5 c11 c6">class</span><span class="c11 c6"> C {</span></p><p class="c2"><span class="c11 c6">  </span><span class="c5 c11 c6">final</span><span class="c11 c6"> x; </span><span class="c5 c11 c6">final</span><span class="c11 c6"> y; </span><span class="c5 c11 c6">final</span><span class="c11 c6"> z;</span></p><p class="c2"><span class="c11 c6">  </span><span class="c5 c11 c6">const</span><span class="c11 c6"> C(p, q): x = q, y = p + 100, z = p + q;</span></p><p class="c2"><span class="c11 c6">}</span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span class="c11">The assignment to </span><span class="c11 c6">x</span><span class="c11"> is allowed under the assumption that </span><span class="c11 c6">q</span><span class="c11"> is a compile-time constant (even though </span><span class="c11 c6">q</span><span class="c11"> is not, in general a compile-time constant).  The assignment to </span><span class="c11 c6">y</span><span class="c11"> is similar, but raises additional questions. In this case, the superexpression of </span><span class="c11 c6">p</span><span class="c11"> is </span><span class="c11 c6">p + 100,</span><span class="c11"> and it requires that </span><span class="c11 c6">p</span><span class="c11"> be a numeric compile-time constant for the entire expression to be considered constant.  The wording of the specification allows us to assume that </span><span class="c11 c6">p</span><span class="c11"> evaluates to an integer. A similar argument holds for </span><span class="c11 c6">p</span><span class="c11"> and </span><span class="c11 c6">q</span><span class="c11"> in the assignment to </span><span class="c11 c6">z.</span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span class="c11">However, the following constructors are disallowed:</span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span class="c5 c11 c6">class</span><span class="c11 c6"> D {</span></p><p class="c2"><span class="c11 c6">  </span><span class="c5 c11 c6">final</span><span class="c11 c6"> w;</span></p><p class="c2"><span class="c11 c6">  </span><span class="c5 c11 c6">const</span><span class="c11 c6"> D.makeList(p): w = </span><span class="c5 c11 c6">const</span><span class="c11 c6"> </span><span class="c11 c6">[p];  // compile-time error</span></p><p class="c2"><span class="c5 c11 c6">  const</span><span class="c11 c6"> D.makeMap(p): w = </span><span class="c5 c11 c6">const</span><span class="c11 c6"> {“help”: p}; // compile-time error</span></p><p class="c2"><span class="c11 c6">  </span><span class="c5 c11 c6">const</span><span class="c11 c6"> D.makeC(p): w = </span><span class="c5 c11 c6">const</span><span class="c11 c6"> C(p, 12); // compile-time error</span></p><p class="c2"><span class="c11 c6">}</span></p><p class="c2 c4"><span class="c11 c6"></span></p><p class="c2"><span class="c11">The problem is not that the assignments to </span><span class="c11 c6">w</span><span class="c11"> are not potentially constant; they are.  However, all these run afoul of the rules for constant lists, maps and objects, all of which independently require their subexpressions to constant expressions.</span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span class="c3 c14">All of the illegal constructors of D above could not be sensibly invoked via </span><span class="c5 c3 c14 c6">new</span><span class="c3 c14">,</span><span class="c3 c14"> because an expression that must be constant cannot depend on a formal parameter, which may or may not be constant. In contrast, the legal examples make sense regardless of whether the constructor is invoked via </span><span class="c5 c3 c14 c6">const</span><span class="c3 c14"> or via </span><span class="c5 c3 c14 c6">new</span><span class="c3 c14">. </span></p><p class="c2 c4"><span class="c3 c14"></span></p><p class="c2"><span class="c3 c14">Careful readers will of course worry about cases where the actual arguments to </span><span class="c3 c14 c6">C()</span><span class="c3 c14"> are constants, but are not of appropriate type. This is precluded by the following rule, combined with the </span><span class="c13 c3"><a class="c8" href="#id.bfpdh2tlvt0v">rules for evaluating constant objects</a></span><span class="c3 c14">.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>When invoked from a constant object expression, a constant constructor must throw an exception if any of its actual parameters would be a value that would cause one of the potentially constant expressions within it to not be a valid compile-time constant.</span></p><p class="c2 c4"><span></span></p><a href="#" name="id.y3ufp36d01bv"></a><h3 class="c2"><a name="h.i641x57pmqjt"></a><span>Static Methods</span></h3><p class="c2 c4"><span></span></p><p class="c2"><span class="c3">Static methods</span><span> are </span><span class="c1"><a class="c8" href="#kix.v3h5pp33ioek">functions</a></span><span> whose declarations are immediately contained within a class declaration and that are declared </span><span class="c5 c6">static</span><span>. The static methods of a class </span><span class="c3">C</span><span> are those static methods declared by </span><span class="c3">C</span><span>.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c3 c14">Inheritance of static methods has little utility in Dart. Static methods cannot be overridden. Any required static function can be obtained from its declaring library, and there is no need to bring it into scope via inheritance. Experience shows that developers are confused by the idea of inherited methods that are not instance methods.</span></p><p class="c2 c4"><span class="c3 c14"></span></p><p class="c2"><span class="c3 c14">Of course, the entire notion of static methods is debatable, but it is retained here because so many programmers are familiar with it. Dart static methods may be seen as functions of the enclosing library. </span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2 c4"><span></span></p><a href="#" name="id.4vjq3uijqjm"></a><h3 class="c2"><a name="h.1k2j0ywtrfjj"></a><span>Static Variables</span></h3><p class="c2 c4"><span></span></p><p class="c2"><span class="c3">Static variables</span><span> are </span><span class="c1"><a class="c8" href="#kix.6b1cgvgf1cyq">variables</a></span><span> whose declarations are immediately contained within a class declaration and that are declared </span><span class="c5 c6">static.</span><span> The static variables of a class </span><span class="c3">C</span><span> are those static variables declared by </span><span class="c3">C</span><span>.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>A static variable declaration of one of the forms </span><span class="c5 c3 c6">static</span><span> </span><span class="c3">T v;</span><span>, </span><span class="c5 c3 c6">static</span><span> </span><span class="c3">T v = e;</span><span>, </span><span class="c5 c3 c6">static</span><span>  </span><span class="c5 c3 c6">const</span><span> </span><span class="c3">T v = e;  </span><span>or </span><span class="c5 c3 c6">static final</span><span> </span><span class="c3">T v = e; </span><span>always induces an implicit static </span><span class="c1"><a class="c8" href="#kix.wlocpej6rvqa">getter function</a></span><span> with signature</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c5 c3 c6">static</span><span class="c3"> T get v()</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>whose invocation evaluates as described </span><span class="c10"><a class="c8" href="#id.52me5qjdvzze">below</a></span><span class="c3">.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>A static variable declaration of one of the forms </span><span class="c5 c3 c6">static var</span><span> </span><span class="c3"> v;</span><span>, </span><span class="c5 c3 c6">static var </span><span class="c3"> v = e;</span><span> </span><span class="c5 c3 c6">static</span><span>  </span><span class="c5 c3 c6">const</span><span> </span><span class="c3">v = e;  or </span><span class="c5 c3 c6">static final</span><span> </span><span class="c3">v = e; </span><span>always induces an implicit static </span><span class="c1"><a class="c8" href="#kix.wlocpej6rvqa">getter function</a></span><span> with signature</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c5 c3 c6">static</span><span class="c3"> get v()</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>whose  invocation evaluates as described </span><span class="c10"><a class="c8" href="#id.52me5qjdvzze">below</a></span><span class="c3">.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>A non-final static variable declaration of the form </span><span class="c5 c3 c6">static</span><span> </span><span class="c3">T v;</span><span> or the form </span><span class="c5 c3 c6">static</span><span> </span><span class="c3">T v = e; </span><span>always induces an implicit static </span><span class="c1"><a class="c8" href="#kix.i4xvz9z9edz">setter function</a></span><span> with signature</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c5 c3 c6">static void</span><span class="c3"> set v(T x)</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>whose execution sets the value of </span><span class="c3">v</span><span> to the incoming argument </span><span class="c3">x.</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span>A non-final static variable declaration of the form </span><span class="c5 c3 c6">static var </span><span class="c3">v;</span><span> or the form </span><span class="c5 c3 c6">static var</span><span class="c3"> v = e; </span><span>always induces an implicit static </span><span class="c1"><a class="c8" href="#kix.i4xvz9z9edz">setter function</a></span><span> with signature</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c5 c3 c6">static </span><span class="c3">set v(x)</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>whose execution sets the value of </span><span class="c3">v</span><span> to the incoming argument </span><span class="c3">x.</span></p><p class="c2 c4"><span class="c3"></span></p><a href="#" name="id.52me5qjdvzze"></a><h4 class="c2"><a name="h.yl719jqc1vh1"></a><span>Evaluation of Static Variable Getters</span></h4><p class="c2 c4"><span class="c5 c24"></span></p><p class="c2 c4"><span class="c5 c24"></span></p><p class="c2"><span>Let </span><span class="c3">d</span><span> be the declaration of a static variable </span><span class="c3">v.</span><span> The implicit getter method of </span><span class="c3">v</span><span> executes as follows:</span></p><ol class="c25" start="1"><li class="c7 c2"><span>If </span><span class="c3">d</span><span> is of one of the forms </span><span class="c5 c3 c6">static var</span><span class="c3 c6"> v = e; , </span><span class="c5 c3 c6">static </span><span class="c3 c6">T v = e; , </span><span class="c5 c3 c6">static final</span><span class="c3 c6"> v = e;</span><span> or </span><span class="c5 c3 c6">static final</span><span class="c3 c6"> T v = e;</span><span> and no value has yet been stored into </span><span class="c3">v</span><span> then the initializer expression </span><span class="c3 c6">e</span><span> is evaluated. If the evaluation succeeded yielding an object </span><span class="c3">o</span><span>, let </span><span class="c3">r = o,</span><span> otherwise let </span><span class="c3">r = </span><span class="c3 c6">null</span><span class="c3">.</span><span> In any case, </span><span class="c3">r</span><span> is stored into </span><span class="c3">v.</span><span> The result of executing the getter is </span><span class="c3">r. </span></li><li class="c7 c2"><span>If </span><span class="c3">d</span><span> is of one of the forms </span><span class="c5 c3 c6">static const</span><span class="c3 c6"> v = e;</span><span> or </span><span class="c5 c3 c6">static const</span><span class="c3 c6"> T v = e;</span><span> the result of the getter is the value of the compile time constant </span><span class="c3 c6">e</span><span>. Otherwise</span></li><li class="c7 c2"><span>The result of executing the getter method is the value stored in </span><span class="c3">v.</span><span>  </span></li></ol><p class="c2 c4"><span class="c3"></span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><a href="#" name="id.7ugexyrtn1zr"></a><h3 class="c2"><a name="h.7crfigeelg47"></a><span>Superclasses</span></h3><p class="c2"><span>The </span><span class="c5 c6">extends</span><span> clause of a class </span><span class="c3">C</span><span> specifies its superclass. If no </span><span class="c5 c6">extends</span><span> clause is specified, then either:</span></p><ol class="c25" start="1"><li class="c7 c2"><span class="c3">C</span><span> is Object, which has no superclass. OR</span></li><li class="c7 c2"><span>The superclass of </span><span class="c3">C</span><span> is Object. </span></li></ol><p class="c2 c4"><span></span></p><p class="c2"><span>It is a compile-time error to specify an </span><span class="c5 c6">extends</span><span> clause for class </span><span class="c6">Object</span><span>.</span></p><p class="c2"><span class="c3"><br></span><a href="#" name="id.frtqvspfkgww"></a><span class="c5 c3">superclass:</span><span class="c3"><br>      </span><span class="c5 c6">extends</span><span class="c3"> </span><span class="c1 c3"><a class="c8" href="#id.qv2a3rupuer9">type</a></span><span class="c3"><br>    ;</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>It is a compile-time error if</span><span> t</span><span>he </span><span class="c5 c6">extends</span><span> clause of a class </span><span class="c3">C</span><span> includes a type expression that does not denote a class available in the lexical scope of </span><span class="c3">C.</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span class="c11">The type parameters of a generic class are available in the lexical scope of the superclass clause, potentially shadowing classes in the surrounding scope. The following code is therefore illegal and should cause a compile-time error:</span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span class="c11">class T{}</span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span class="c11">class G&lt;T&gt; extends T {} // Compilation error: Attempt to subclass a type variable</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span class="c3">A</span><span> class </span><span class="c3">S</span><span> is </span><span class="c3">a superclass of</span><span> a class </span><span class="c3">C</span><span> iff either:</span></p><ol class="c25" start="1"><li class="c7 c2"><span> </span><span class="c3">S</span><span> is the superclass of </span><span class="c3">C,</span><span> or</span><span class="c3"> </span></li><li class="c7 c2"><span class="c3">S</span><span> is a superclass of a class </span><span class="c3">S’ </span><span>and </span><span class="c3">S’</span><span> is a superclass of </span><span class="c3">C. </span></li></ol><p class="c2 c4"><span></span></p><p class="c2"><span>It is a compile-time error if a class </span><span class="c3">C</span><span> is a superclass of itself.</span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span class="c11"></span></p><a href="#" name="id.lodslm1bek9u"></a><h4 class="c2"><a name="h.n9p3c8rq84d5"></a><span>Inheritance and Overriding</span></h4><p class="c2 c4"><span></span></p><p class="c2"><span>A class </span><span class="c3">C</span><span> </span><span class="c3">inherits</span><span> any instance members of its superclass </span><span>that are not overridden by instance members declared in </span><span class="c3">C.</span><span> </span></p><p class="c2 c4"><span></span></p><p class="c2"><span>A class may override instance members that would otherwise have been inherited from its superclass. </span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Let </span><span class="c3">C</span><span> be a class declared in library </span><span class="c3">L</span><span> with superclass </span><span class="c3">S</span><span> and let </span><span class="c3">C</span><span> declare an instance member </span><span class="c3">m</span><span class="c3">,</span><span> an</span><span>d a</span><span>ssume </span><span class="c3">S </span><span>declares an instance member </span><span class="c3">m’ </span><span>with the same name as</span><span class="c3"> m. </span><span>Then </span><span class="c3">m overrides m’ </span><span>iff </span><span class="c3">m’</span><span> is </span><span class="c1"><a class="c8" href="#id.zeletzevxf8t">accessible</a></span><span> to</span><span class="c3"> L</span><span> and one of the following holds:</span></p><ol class="c25" start="1"><li class="c7 c2"><span class="c3">m</span><span> is an instance method.</span></li><li class="c7 c2"><span class="c3">m</span><span> is a getter and </span><span class="c3">m’</span><span> is a getter or a method.</span></li><li class="c7 c2"><span class="c3">m</span><span> is a setter and </span><span class="c3">m’</span><span> is a setter or a method.</span></li></ol><p class="c2"><span>Whether an override is legal or not is described elsewhere in this specification (see </span><span class="c10"><a class="c8" href="#id.6kuu1330zv2p">instance methods</a></span><span>, </span><span class="c10"><a class="c8" href="#id.oq9a3ejdhhkw">interface methods</a></span><span> and also </span><span class="c10"><a class="c8" href="#kix.wlocpej6rvqa">getters</a></span><span> and </span><span class="c10"><a class="c8" href="#kix.i4xvz9z9edz">setters</a></span><span>). </span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c11">For example</span><span class="c11"> getters and setters may not legally override methods </span><span class="c11">and vice versa.  </span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span class="c3 c14">It is nevertheless convenient to define the override relation between members in this way, so that we can concisely describe the illegal cases.</span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span class="c11">Note that instance variables do not participate in the override relation, but the getters and setters they induce do. Also, getters don’t override setters and vice versa.  Finally, static members never override anything.</span></p><p class="c2 c4"><span></span></p><a href="#" name="id.c8755sosjkuz"></a><h3 class="c2"><a name="h.pbz42oyr5t19"></a><span>Superinterfaces</span></h3><p class="c2"><span>A class has a set of direct superinterfaces. This set includes the interface of its superclass and the interfaces specified in the the </span><span class="c5 c6">implements</span><span> clause of the class.</span></p><p class="c2 c4"><span class="c3"></span></p><a href="#" name="id.5h6h28b15vp8"></a><p class="c2"><span class="c5 c3">interfaces:</span><span class="c3"><br>      </span><span class="c5 c6">implements</span><span class="c3"> </span><span class="c1 c3"><a class="c8" href="#id.adfwlw3tslsh">typeList</a></span><span class="c3"><br>    ;<br></span></p><p class="c2 c4"><span></span></p><p class="c2"><span>It is a compile-time error if</span><span> </span><span>the </span><span class="c5 c6">implements</span><span> clause of a class </span><span class="c3">C</span><span> includes a type expression that does not denote a </span><span>class or interface</span><span> available in the lexical scope of </span><span class="c3">C. </span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c11">In particular, one cannot inherit from a type </span><span class="c11">variable</span><span class="c11">. </span></p><p class="c2 c4"><span></span></p><p class="c2"><span>It is a compile-time error if the </span><span class="c5 c6">implements</span><span> clause of a class includes type </span><span class="c5 c6">Dynamic</span><span>.</span></p><p class="c2"><span>It is a compile-time </span><span>error</span><span> if a </span><span>type </span><span class="c3">T</span><span class="c3"> </span><span>appears more than once in the </span><span class="c5 c6">implements</span><span> clause of  a class.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c3 c14">One might argue that it is harmless to repeat a type in this way, so why make it an error? The issue is not so much that the situation described in program source is erroneous, but that it is pointless. As such, it is an indication that the programmer may very well have meant to say something else - and that is a mistake that should be called to her or his attention.  Nevertheless, we could simply issue a warning; and perhaps we should and will. That said, problems like these are local and easily corrected on the spot, so we feel justified in taking a harder line. </span></p><p class="c2 c4"><span></span></p><p class="c2"><span>It is a compile-time error if the interface induced by a class </span><span class="c3">C</span><span> is a superinterface of itself.</span></p><p class="c2 c4"><span class="c3 c14"></span></p><p class="c2"><span class="c11">A class does not inherit members from its superinterfaces.</span><span> </span><span class="c11">However, its implicit interface does.</span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><a href="#" name="id.obndo59vaebw"></a><h2 class="c2"><a name="h.l2scqcqw64rv"></a><span>Interfaces</span></h2><p class="c2"><span>An </span><span class="c3">interface</span><span> defines how one may interact with an object. An </span><span>interface</span><span> </span><span>has</span><span> methods, getters, setters and constructors, and a set of superinterfaces.</span></p><p class="c2 c4"><span></span></p><a href="#" name="id.w0vyfr90e2bg"></a><p class="c2"><span class="c5 c3">interfaceDefinition:</span><span class="c3"><br>      </span><span class="c5 c6">interface</span><span class="c3"> </span><span class="c0"><a class="c8" href="#id.te0njh1fhw7g">identifier</a></span><span class="c3"> </span><span class="c0"><a class="c8" href="#id.p9q99pefxn6v">typeParameters</a></span><span class="c3">? superinterfaces?<br>      factorySpecification? &#39;{&#39; (interfaceMemberDefinition)* &#39;}&#39;<br>    ;<br></span></p><p class="c2 c4"><span></span></p><a href="#" name="id.qttyvdh7z3r7"></a><p class="c2"><span class="c5 c3">interfaceMemberDefinition:</span><span class="c3"><br>      </span><span class="c5 c6">static</span><span class="c6"> final</span><span class="c3"> type? initializedIdentifierList &#39;;&#39;<br>    | functionSignature &#39;;&#39;<br>    | constantConstructorSignature &#39;;&#39;<br>    | namedConstructorSignature &#39;;&#39;<br>    | </span><span class="c0"><a class="c8" href="#id.utm3o466r3od">getterSignature</a></span><span class="c3"> &#39;;&#39;</span></p><p class="c2"><span class="c3">    | </span><span class="c0"><a class="c8" href="#id.qdrk084cdrn3">setterSignature</a></span><span class="c3"> &#39;;&#39;<br>    | operatorSignature &#39;;&#39;<br>    | </span><span class="c3">variableDeclaration</span><span class="c3"> &#39;;&#39;<br>    ;</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span> It is a compile-time error if any default values are specified in the signature of an interface method, getter, setter or constructor.</span></p><p class="c2 c4"><span></span></p><a href="#" name="id.oq9a3ejdhhkw"></a><h3 class="c2"><a name="h.m5evou6f8tgl"></a><span>Methods</span></h3><p class="c2"><span>An interface method declaration specifies a method signature but no body. </span></p><p class="c2 c4"><span></span></p><p class="c2"><span>It is a compile-time error if an interface method </span><span class="c3">m</span><span class="c9 c3">1</span><span> overrides an interface member </span><span class="c3">m</span><span class="c9 c3">2</span><span> and  </span><span class="c3">m</span><span class="c9 c3">1</span><span> has a different number of required parameters than </span><span class="c3">m</span><span class="c9 c3">2</span><span>. It is a compile-time error if an interface method </span><span class="c3">m</span><span class="c9 c3">1</span><span> overrides  an interface member </span><span class="c3">m</span><span class="c9 c3">2</span><span> and  </span><span class="c3">m</span><span class="c9 c3">1</span><span> does not declare all the named parameters declared by </span><span class="c3">m</span><span class="c9 c3">2</span><span> in the same order.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>It is a static warning if an interface method</span><span class="c3"> m</span><span class="c9 c3">1</span><span> overrides an interface method </span><span class="c3">m</span><span class="c9 c3">2</span><span> and the type of </span><span class="c3">m</span><span class="c9 c3">1</span><span> is not a subtype of the type of </span><span class="c3">m</span><span class="c9 c3">2</span><span>.</span></p><a href="#" name="id.1y49atuag13e"></a><h4 class="c2"><a name="h.rnrc3kvf8xpl"></a><span>Operators</span></h4><p class="c2"><span>Operators are instance methods with special names. Some, but not all, operators may be defined by user code, as described below.</span></p><p class="c2 c4"><span></span></p><a href="#" name="id.kws7dxd75e1i"></a><h3 class="c2"><a name="h.dkjessmm6dxp"></a><span>Getters and Setters</span></h3><p class="c2 c4"><span></span></p><p class="c2"><span>An interface may contain getter and/or setter signatures. These are subject to the same compile-time and static checking rules as getters and setters in classes.</span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><a href="#" name="id.5kvtnnyqvcjb"></a><h3 class="c2"><a name="h.v7d57wsbsfo"></a><span>Factories and Constructors</span></h3><p class="c2 c4"><span></span></p><p class="c2"><span>An interface may specify a </span><span class="c3">default factory class</span><span>, which is a class that will be used to provide instances when constructors are invoked via the interface.</span></p><p class="c2 c4"><span></span></p><a href="#" name="kix.tp956dn27zey"></a><p class="c2"><span class="c5 c3">factorySpecification:</span><span class="c3"><br>     </span><span class="c5 c6">default</span><span class="c3"> </span><span class="c0"><a class="c8" href="#id.xsv95i3z7eli">qualified</a></span><span class="c3"> </span><span class="c0"><a class="c8" href="#id.p9q99pefxn6v">typeParameters</a></span><span class="c3">?</span></p><p class="c2"><span class="c3">   ;<br></span></p><p class="c2 c4"><span></span></p><p class="c2"><span>An interface can specify the signatures of constructors that are used to provide objects that conform to the interface.  It is a compile-time error if an interface declares a constructor without declaring a factory class.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Let </span><span class="c3">I</span><span> be an interface named </span><span class="c3">N</span><span class="c9 c3">I</span><span> with factory class </span><span class="c3">F,</span><span> and let </span><span class="c3">N</span><span class="c9 c3">F</span><span> be the name of </span><span class="c3">F.</span><span> It is a compile-time error if </span><span class="c3">I</span><span> and </span><span class="c3">F</span><span> do not have the same number of type parameters. If</span><span class="c3"> I</span><span> has </span><span class="c3">n</span><span> type parameters, then the name of the </span><span class="c3">i</span><span>th type parameter of </span><span class="c3">I</span><span> must be identical to the name of the </span><span class="c3">i</span><span>th type parameter of </span><span class="c3">F</span><span>, for </span><span class="c3">1 &lt;= i &lt;= n, </span><span>or a compile-time error occurs.</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span class="c3 c14">The idea is that the type parameters of the factory class and the interface are identical, except that the factory’s type parameters can have tighter bounds.  This ensures that the actual type arguments in the instance creation expression can be directly passed to the constructor.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>A constructor</span><span class="c3"> k</span><span class="c9 c3">I</span><span> of interface </span><span class="c3">I</span><span> with name </span><span class="c3">N</span><span class="c9 c3">I </span><span class="c3">corresponds to a constructor</span><span> </span><span class="c3">k</span><span class="c9 c3">F</span><span> of its factory class </span><span class="c3">F</span><span> with name </span><span> </span><span class="c3">N</span><span class="c9 c3">F  </span><span>iff either:</span></p><ol class="c25" start="1"><li class="c7 c2"><span class="c3">F </span><span>does not implement </span><span class="c3">I </span><span>and </span><span class="c3">k</span><span class="c9 c3">I</span><span class="c3"> </span><span>and </span><span class="c3">k</span><span class="c9 c3">F</span><span class="c3"> </span><span>have the same name, OR</span></li></ol><ol class="c25" start="1"><li class="c7 c2"><span class="c3">F</span><span> implements </span><span class="c3">I </span><span>and either</span></li></ol><ol class="c34" start="1"><li class="c20 c2"><span class="c3">k</span><span class="c9 c3">I</span><span class="c3"> </span><span>is named </span><span class="c3">N</span><span class="c9 c3">I</span><span class="c3"> and k</span><span class="c9 c3">F </span><span>is named </span><span class="c3">N</span><span class="c9 c3">F</span><span class="c3">, </span><span>OR</span></li><li class="c20 c2"><span class="c3">k</span><span class="c9 c3">I</span><span class="c3"> </span><span>is named </span><span class="c3">N</span><span class="c9 c3">I</span><span class="c3">.id and k</span><span class="c9 c3">F </span><span>is named </span><span class="c3">N</span><span class="c9 c3">F</span><span class="c3">.id.</span></li></ol><p class="c2 c4"><span></span></p><p class="c2"><span>It is a compile-time error if an interface </span><span class="c3">I</span><span> declares a constructor </span><span class="c3">k</span><span class="c9 c3">I</span><span> and there is no constructor </span><span class="c3">k</span><span class="c9 c3">F </span><span>in the factory class </span><span class="c3">F</span><span> such that </span><span class="c3">k</span><span class="c9 c3">I  </span><span>corresponds to </span><span class="c3">k</span><span class="c9 c3">F</span><span class="c3">.</span></p><p class="c2"><span>Let </span><span class="c3">k</span><span class="c9 c3">I </span><span>be a constructor declared in an interface </span><span class="c3">I,</span><span> and let </span><span class="c3">k</span><span class="c9 c3">F</span><span> be its corresponding constructor. Then:</span></p><ol class="c25" start="1"><li class="c7 c2"><span>It is a compile-time error if </span><span class="c3">k</span><span class="c18 c3">I </span><span>and </span><span class="c3">k</span><span class="c18 c3">F </span><span>do not have the same number of required parameters.</span></li><li class="c7 c2"><span>It is a compile-time error if </span><span class="c3">k</span><span class="c18 c3">I </span><span>and </span><span class="c3">k</span><span class="c18 c3">F </span><span>do not have identically named optional parameters, declared in the same order.</span></li><li class="c7 c2"><span>It is a static type warning if the type of the </span><span class="c3">n</span><span>th required formal parameter of </span><span class="c3">k</span><span class="c18 c3">I</span><span> is not identical to the type of the </span><span class="c3">n</span><span>th required formal parameter of </span><span class="c3">k</span><span class="c18 c3">F</span><span>.</span></li><li class="c7 c2"><span>It is a static type warning if the types of named optional parameters with the same name differ between </span><span class="c3">k</span><span class="c18 c3">I</span><span class="c3"> and k</span><span class="c18 c3">F</span><span class="c3">.</span></li></ol><p class="c2 c4"><span class="c3"></span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span>If the default factory clause of </span><span class="c3">I</span><span> includes a list of type parameters </span><span class="c3">tps</span><span>, then </span><span class="c3">tps</span><span> must be identical to the type parameters given in the type declaration of </span><span class="c3">F,</span><span> or a compile-time error occurs.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c11">As an example, consider</span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span class="c11 c6">class HashMapImplementation&lt;K extends Hashable, V&gt; {...}</span></p><p class="c2 c4"><span class="c11 c6"></span></p><p class="c2"><span class="c11 c6">interface Map&lt;K, V&gt; default HashMapImplementation&lt;K, V&gt; { ... } // illegal</span></p><p class="c2 c4"><span class="c11 c6"></span></p><p class="c2"><span class="c11 c6">interface Map&lt;K, V&gt; default HashMapImplementation&lt;K extends Hashable, V&gt; { ... } </span></p><p class="c2"><span class="c11 c6">// legal</span></p><p class="c2 c4"><span class="c11 c6"></span></p><p class="c2 c4"><span></span></p><a href="#" name="id.1dtu82gkimcm"></a><h3 class="c2"><a name="h.6njjvzks70uf"></a><span>Superinterfaces</span></h3><p class="c2"><span>An interface has a set of direct superinterfaces. This set consists of the interfaces specified in the </span><span class="c5 c6">extends</span><span> clause of the interface.</span></p><p class="c2 c4"><span></span></p><a href="#" name="id.6oihpoq6otb9"></a><p class="c2"><span class="c5 c3">superinterfaces:</span><span class="c3"><br>      </span><span class="c5 c6">extends</span><span class="c3"> typeList<br>    ;<br></span></p><p class="c2"><span>An interface </span><span class="c3">J</span><span> is a superinterface of an interface </span><span class="c3">I</span><span> iff either </span><span class="c3">J</span><span> is a direct superinterface of </span><span class="c3">I</span><span> or </span><span class="c3">J</span><span> is a superinterface of a direct superinterface of </span><span class="c3">I.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>It is a compile-time error if  the </span><span class="c5 c6">extends</span><span> clause of an interface </span><span class="c3">I</span><span> includes a type expression that does not denote a class or interface available in the lexical scope of </span><span class="c3">I.</span></p><p class="c2"><span>It is a compile-time error if the </span><span class="c5 c6">extends</span><span> clause of an interface includes type </span><span class="c5 c6">Dynamic</span><span>.</span></p><p class="c2"><span>It is a compile-time error if an interface is a </span><span>superinterface</span><span> of itself.</span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2 c4"><span class="c3"></span></p><a href="#" name="id.dob88ttl6bd0"></a><h4 class="c2"><a name="h.n9p3c8rq84d5"></a><span>Inheritance and Overriding</span></h4><p class="c2 c4"><span></span></p><p class="c2"><span>An interface </span><span class="c3">I</span><span> </span><span class="c3">inherits</span><span> any instance members of its superinterfaces that are not overridden by members declared in </span><span class="c3">I.</span><span> </span></p><p class="c2 c4"><span></span></p><p class="c2"><span>However, if there </span><span>are multiple members </span><span class="c3">m</span><span class="c9 c3">1</span><span class="c3">, …,  m</span><span class="c9 c3">k</span><span> with the same name </span><span class="c3">n</span><span> that would be inherited (because identically named members existed in several superinterfaces) then at most one member is inherited. If the static types </span><span class="c3">T</span><span class="c9 c3">1</span><span class="c3">, …,  T</span><span class="c9 c3">k </span><span>of the members </span><span class="c3">m</span><span class="c9 c3">1</span><span class="c3">, …,  m</span><span class="c9 c3">k </span><span>are not identical, then there must be a member </span><span class="c3">m</span><span class="c9 c3">x</span><span> such that </span><span class="c3">T</span><span class="c9 c3">x</span><span class="c3"> &lt;: T</span><span class="c9 c3">i</span><span class="c3">, 1 &lt;= x &lt;= k</span><span> for all  </span><span class="c3">i, 1 &lt;= i &lt;=  k, </span><span>or a static type warning occurs. The member that is inherited is </span><span class="c3">m</span><span class="c9 c3">x</span><span class="c3">,</span><span> if it exists; otherwise:</span></p><ol class="c25" start="1"><li class="c7 c2"><span>If all of </span><span class="c3">m</span><span class="c9 c3">1</span><span class="c3">, …,  m</span><span class="c9 c3">k</span><span> have the same number </span><span class="c3">r</span><span> of required parameters and the same set of named parameters </span><span class="c3">s</span><span>, then </span><span class="c3">I </span><span>has a method named </span><span class="c3">n</span><span>, with r required parameters of type </span><span class="c5 c6">Dynamic,</span><span> named parameters </span><span class="c3">s</span><span> of type </span><span class="c5 c6">Dynamic</span><span> and  return type </span><span class="c5 c6">Dynamic.</span><span>  </span></li><li class="c7 c2"><span>Otherwise none of the members  </span><span class="c3">m</span><span class="c9 c3">1</span><span class="c3">, …,  m</span><span class="c9 c3">k</span><span> is inherited</span><span class="c3">.</span></li></ol><p class="c2 c4"><span class="c3 c14"></span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c11">The only situation where the runtime would be concerned with this would be during reflection if a mirror attempted to obtain the signature of an interface member. </span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span class="c3 c14">The current solution is a tad complex, but is robust in the face of type annotation changes.  Alternatives: (a) No member is inherited in case of conflict. (b) The first m is selected (based on order of superinterface list) (c) Inherited member chosen at random.  </span></p><p class="c2 c4"><span class="c3 c14"></span></p><p class="c2"><span class="c3 c14">(a) means that the presence of an inherited member of an interface varies depending on type signatures.  (b) is sensitive to irrelevant details of the declaration and (c) is liable to give unpredictable results between implementations or even between different compilation sessions.</span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2 c4"><span></span></p><p class="c2"><span>An interface may override instance members that would otherwise have been inherited from its superinterfaces. </span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Let </span><span class="c3">I</span><span> be an interface declared in library </span><span class="c3">L</span><span> with superinterface </span><span class="c3">S</span><span>, and let </span><span class="c3">I</span><span> declare an instance member </span><span class="c3">m,</span><span> and  assume </span><span class="c3">S </span><span>declares an instance member </span><span class="c3">m’ </span><span>with the same name as</span><span class="c3"> m. </span><span>Then </span><span class="c3">m overrides m’ </span><span>iff </span><span class="c3">m’</span><span> is </span><span class="c1"><a class="c8" href="#id.zeletzevxf8t">accessible</a></span><span> to </span><span class="c3">L</span><span> and one of the following holds:</span></p><ol class="c25" start="4"><li class="c7 c2"><span class="c3">m</span><span> is an instance method.</span></li><li class="c7 c2"><span class="c3">m</span><span> is a getter and </span><span class="c3">m’</span><span> is a getter or a method.</span></li><li class="c7 c2"><span class="c3">m</span><span> is a setter and </span><span class="c3">m’</span><span> is a setter or a method.</span></li></ol><p class="c2"><span>Whether an override is legal or not is described elsewhere in this specification (see </span><span class="c10"><a class="c8" href="#id.6kuu1330zv2p">instance methods</a></span><span>, </span><span class="c10"><a class="c8" href="#id.oq9a3ejdhhkw">interface methods</a></span><span> and also </span><span class="c10"><a class="c8" href="#kix.wlocpej6rvqa">getters</a></span><span> and </span><span class="c10"><a class="c8" href="#kix.i4xvz9z9edz">setters</a></span><span>). </span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><a href="#" name="id.64iudgj9wjj1"></a><h2 class="c2"><a name="h.dkzw3xyky3rs"></a><span>Generics</span></h2><p class="c2"><span>A </span><span class="c1"><a class="c8" href="#id.o6h4ul6q3sru">class</a></span><span> declaration,  </span><span class="c1"><a class="c8" href="#id.obndo59vaebw">interface</a></span><span> declaration or type alias </span><span class="c3">G</span><span> may be </span><span class="c3">generic</span><span>, that is, </span><span class="c3">G </span><span>may have formal type parameters declared. A generic declaration induces a family of declarations, one for each set of actual type parameters provided in the program. </span></p><p class="c2 c4"><span></span></p><a href="#" name="kix.bn2soknq8e18"></a><p class="c2"><span class="c5 c3">typeParameter:</span><span class="c3"><br>     </span><span class="c0"><a class="c8" href="#id.te0njh1fhw7g">identifier</a></span><span class="c3"> (</span><span class="c5 c6">extends</span><span class="c3"> </span><span class="c0"><a class="c8" href="#id.qv2a3rupuer9">type</a></span><span class="c3">)?<br>    ;</span></p><p class="c2 c4"><span></span></p><a href="#" name="id.p9q99pefxn6v"></a><p class="c2"><span class="c5 c3">typeParameters:</span><span class="c3"><br>     &#39;&lt;&#39; </span><span class="c0"><a class="c8" href="#kix.bn2soknq8e18">typeParameter</a></span><span class="c3"> (&#39;,&#39; </span><span class="c0"><a class="c8" href="#kix.bn2soknq8e18">typeParameter</a></span><span class="c3">)* &#39;&gt;&#39;<br>    ;<br></span></p><p class="c2 c4"><span></span></p><p class="c2"><span>A type parameter </span><span class="c3">T</span><span> may be suffixed with an </span><span class="c5 c6">extends</span><span> clause that specifies the </span><span class="c3">upper bound</span><span> for </span><span class="c3">T.</span><span> If no extends clause is present, the upper bound is </span><span class="c6">Object</span><span class="c6">.</span><span> It is a static type warning if a type variable is a supertype of its upper bound.</span></p><p class="c2 c4"><span class="c19"></span></p><p class="c2"><span>The type parameters of a generic declaration </span><span class="c3">G</span><span> are in scope in the bounds of all of the type parameters of </span><span class="c3">G. </span><span>The type parameters of a generic class or interface declaration</span><span> </span><span class="c3">G</span><span> are also  in scope in the </span><span class="c5 c6">extends</span><span> and </span><span class="c5 c6">implements</span><span> clauses of </span><span class="c3">G</span><span> (if these exist) and in the non-static members of </span><span class="c3">G.</span><span> </span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c11">Because type parameters are in scope in their bounds, we support F-bounded quantification (</span><span class="c11">if you don&#39;t know what that is, don&#39;t ask</span><span class="c11">). This enables typechecking code such as:</span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span class="c5 c11 c6">interface</span><span class="c11 c6"> Ordered&lt;T&gt; {</span></p><p class="c2"><span class="c11 c6">  </span><span class="c5 c11 c6">operator</span><span class="c11 c6"> &gt; (T x);</span></p><p class="c2"><span class="c11 c6">}</span></p><p class="c2 c4"><span class="c11 c6"></span></p><p class="c2"><span class="c5 c11 c6">class</span><span class="c11 c6"> Sorter&lt;T </span><span class="c5 c11 c6">extends</span><span class="c11 c6"> Ordered&lt;T&gt;&gt; {</span></p><p class="c2"><span class="c11 c6">   sort(List&lt;T&gt; l) { … l[n] &lt; l[n+1] …}</span></p><p class="c2"><span class="c11 c6">}</span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span class="c11">Even where type parameters are in scope there are </span><span class="c11">numerous restrictions</span><span class="c11"> at this time:</span></p><ol class="c25" start="1"><li class="c7 c2"><span class="c11">A type parameter cannot be used to name a constructor in an </span><span class="c1"><a class="c8" href="#id.hvkbnlui8uvu">instance creation expression</a></span><span class="c11">.</span></li><li class="c7 c2"><span class="c11">A type parameter </span><span class="c11">cannot </span><span class="c11">be</span><span class="c11"> used as an </span><span class="c1"><a class="c8" href="#id.ayq1ul833tkz">identifier  expression</a></span><span class="c11">. </span></li><li class="c7 c2"><span class="c11">A type parameter cannot be used as a superclass or superinterface.</span></li></ol><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span class="c11">The normative versions of these are given in the appropriate sections of this specification. Some of these restrictions may be lifted in the future.</span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><a href="#" name="id.5cg9qz6trgbb"></a><h2 class="c2"><a name="h.dz8ekoegseec"></a><span>Expressions</span></h2><p class="c2"><span>An </span><span class="c3">expression</span><span> is a fragment of Dart code that can be evaluated at run time to yield a </span><span class="c3">value</span><span>,</span><span> which is always an object. Every expression has an associated </span><span class="c1"><a class="c8" href="#id.hiljskbmppmb">static type</a></span><span>. Every value has an associated </span><span class="c1"><a class="c8" href="#id.xmnezjjgjrld">dynamic type</a></span><span>.</span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><a href="#" name="id.1u3vxuwrz6py"></a><p class="c2"><span class="c5 c3">expression</span><span class="c5 c3">:<br></span><span class="c3">      </span><span class="c0"><a class="c8" href="#kix.3nqu822r00nf">assignableExpression</a></span><span class="c3"> </span><span class="c0"><a class="c8" href="#id.gs625gfxuh9m">assignmentOperator</a></span><span class="c3"> </span><span class="c0"><a class="c8" href="#id.1u3vxuwrz6py">expression</a></span><span class="c3"><br>    | </span><span class="c0"><a class="c8" href="#id.u42blbh7fdm7">conditionalExpression</a></span><span class="c3"> </span><span class="c0"><a class="c8" href="#id.6dmpu4rs8im6">cascadeSection</a></span><span class="c3">*<br>    ;<br></span></p><p class="c2"><span class="c3"><br><br></span><a href="#" name="id.k68gukuq6cj9"></a><span class="c5 c3">expressionWithoutCascade:</span><span class="c3"><br>      </span><span class="c0"><a class="c8" href="#kix.3nqu822r00nf">assignableExpression</a></span><span class="c3"> </span><span class="c0"><a class="c8" href="#id.gs625gfxuh9m">assignmentOperator</a></span><span class="c3"> </span><span class="c0"><a class="c8" href="#id.k68gukuq6cj9">expressionWithoutCascade</a></span><span class="c3"><br>    | </span><span class="c0"><a class="c8" href="#id.u42blbh7fdm7">conditionalExpression</a></span><span class="c3"><br>    ;<br></span></p><a href="#" name="id.8a2tqk43n0f2"></a><p class="c2"><span class="c5 c3">expressionList:</span><span class="c3"><br>      </span><span class="c0"><a class="c8" href="#id.1u3vxuwrz6py">expression</a></span><span class="c3"> (&#39;,&#39; </span><span class="c0"><a class="c8" href="#id.1u3vxuwrz6py">expression</a></span><span class="c3">)*<br>    ;</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span class="c3"><br></span><a href="#" name="kix.37v9da65ia6t"></a><span class="c5 c3">primary:</span><span class="c3"><br>      </span><span class="c10"><a class="c8" href="#id.wwq4i2tyv7sn">thisExpression</a></span><span class="c3"><br>    | </span><span class="c5 c6">super</span><span class="c3"> </span><span class="c0"><a class="c8" href="#kix.sozsnkf6qfzk">assignableSelector</a></span><span class="c3"><br>    | </span><span class="c0"><a class="c8" href="#id.p3fm2ke402rw">functionExpression</a></span><span class="c3"><br>    | </span><span class="c0"><a class="c8" href="#id.88dsnjlmlm9c">literal</a></span><span class="c3"><br>    | </span><span class="c0"><a class="c8" href="#id.te0njh1fhw7g">identifier</a></span><span class="c3"><br>    | </span><span class="c0"><a class="c8" href="#id.a0815nq10roy">newExpression</a></span><span class="c3"><br>    | </span><span class="c0"><a class="c8" href="#id.py555jou6no8">constObjectExpression</a></span><span class="c3"><br>    | &#39;(&#39; </span><span class="c0"><a class="c8" href="#id.1u3vxuwrz6py">expression</a></span><span class="c3"> &#39;)&#39;<br>    ;</span></p><p class="c2 c4"><span class="c3"><br></span></p><a href="#" name="id.hzs87hup8wb"></a><h3 class="c2"><a name="h.9asvt38phduq"></a><span>Constants</span></h3><p class="c2"><span>A constant expression is an expression whose value can never change, and that can be evaluated entirely at compile time. </span></p><p class="c2 c4"><span></span></p><p class="c2"><span>A constant expression is one of the following:</span></p><ol class="c25" start="1"><li class="c7 c2"><span>A literal </span><span class="c1"><a class="c8" href="#id.qjvme5fkz60x">number</a></span><span>.</span></li><li class="c7 c2"><span>A literal </span><span class="c1"><a class="c8" href="#id.qyrl5513vmyg">boolean</a></span><span>.</span></li><li class="c7 c2"><span>A literal </span><span class="c1"><a class="c8" href="#id.6fv1qfiad49o">string</a></span><span>  where any </span><span class="c10"><a class="c8" href="#id.4kp5eixbuz9v">interpolated expression</a></span><span> is a compile-time constant that evaluates to a numeric, string or boolean value. </span><span class="c3 c14">It would be tempting to allow string interpolation where the interpolated value is any compile-time constant.  However, this would require running the </span><span class="c3 c14 c6">toString()</span><span class="c3 c14"> method for constant objects, which could contain arbitrary code.</span></li><li class="c7 c2"><span class="c1 c6"><a class="c8" href="#id.y33m1d6n2h6f">null</a></span><span class="c6">.</span></li><li class="c7 c2"><span>A reference to a </span><span class="c10"><a class="c8" href="#kix.6b1cgvgf1cyq">constant variable</a></span><span>.</span></li><li class="c7 c2"><span>A </span><span class="c1"><a class="c8" href="#id.okcph2t66jnm">constant constructor</a></span><span> </span><span class="c1"><a class="c8" href="#id.bfpdh2tlvt0v">invocation</a></span><span>.</span></li><li class="c7 c2"><span>A constant </span><span class="c1"><a class="c8" href="#id.tlcxi4pl8sj4">list literal</a></span><span>.</span></li><li class="c7 c2"><span>A constant </span><span class="c1"><a class="c8" href="#id.riie55qjrb82">map literal</a></span><span>.</span></li><li class="c7 c2"><span>An expression of one of the forms </span><span class="c3">e</span><span class="c18 c3">1</span><span> == </span><span class="c3">e</span><span class="c9 c3">2</span><span>,</span><span class="c18"> </span><span class="c3">e</span><span class="c18 c3">1</span><span> != </span><span class="c3">e</span><span class="c9 c3">2</span><span class="c3">, e</span><span class="c9 c3">1</span><span> === </span><span class="c3">e</span><span class="c9 c3">2</span><span> or </span><span class="c3">e</span><span class="c9 c3">1</span><span> !== </span><span class="c3">e</span><span class="c9 c3">2</span><span class="c3"> ,</span><span>where </span><span class="c3">e</span><span class="c9 c3">1</span><span> and </span><span class="c3">e</span><span class="c9 c3">2</span><span> are constant expressions that evaluate to a </span><span>numeric, string or boolean value</span><span>.</span></li><li class="c7 c2"><span>An expression of one of the forms </span><span class="c3">!e,</span><span> </span><span class="c9 c3"> </span><span class="c3">e</span><span class="c18 c3">1</span><span> &amp;&amp; </span><span class="c3">e</span><span class="c9 c3">2</span><span class="c18 c3"> </span><span>or</span><span class="c18"> </span><span class="c3">e</span><span class="c18 c3">1</span><span> || </span><span class="c3">e</span><span class="c9 c3">2</span><span class="c3">, </span><span>where </span><span class="c3">e, e</span><span class="c9 c3">1</span><span> and </span><span class="c3">e</span><span class="c9 c3">2</span><span> are constant expressions that evaluate to a boolean value.</span></li><li class="c7 c2"><span>An expression of one of the forms</span><span class="c9 c3"> </span><span class="c3">~</span><span> </span><span class="c3">e</span><span>,</span><span class="c18"> </span><span class="c3">e</span><span class="c18 c3">1</span><span> ~/ </span><span class="c3">e</span><span class="c9 c3">2</span><span class="c3">, e</span><span class="c18 c3">1</span><span> ^ </span><span class="c3">e</span><span class="c9 c3">2</span><span>,</span><span class="c18"> </span><span class="c3">e</span><span class="c18 c3">1</span><span> &amp; </span><span class="c3">e</span><span class="c9 c3">2</span><span class="c3">, e</span><span class="c18 c3">1</span><span> | </span><span class="c3">e</span><span class="c9 c3">2</span><span>, </span><span class="c3">e</span><span class="c18 c3">1</span><span> &gt;&gt; </span><span class="c3">e</span><span class="c9 c3">2</span><span class="c18 c3"> </span><span>or</span><span class="c18"> </span><span class="c3">e</span><span class="c18 c3">1</span><span> &lt;&lt; </span><span class="c3">e</span><span class="c9 c3">2</span><span class="c3">, </span><span>where </span><span class="c3">e, e</span><span class="c9 c3">1</span><span> and </span><span class="c3">e</span><span class="c9 c3">2</span><span> are constant expressions that evaluate to an integer value.</span></li><li class="c7 c2"><span>An expression of the form</span><span class="c9 c3"> </span><span class="c3">e</span><span class="c18 c3">1</span><span> + </span><span class="c3">e</span><span class="c9 c3">2 </span><span>where </span><span class="c3">e</span><span class="c9 c3">1</span><span> and </span><span class="c3">e</span><span class="c9 c3">2</span><span> are constant expressions that both evaluate to a numeric value.</span></li><li class="c7 c2"><span>An expression of one of the forms</span><span class="c9 c3"> </span><span class="c3">-e</span><span>, </span><span class="c3">e</span><span class="c18 c3">1</span><span> - </span><span class="c3">e</span><span class="c9 c3">2</span><span class="c3">, e</span><span class="c18 c3">1</span><span> * </span><span class="c3">e</span><span class="c9 c3">2</span><span>,</span><span class="c18"> </span><span class="c3">e</span><span class="c18 c3">1</span><span> / </span><span class="c3">e</span><span class="c9 c3">2</span><span class="c3">, </span><span class="c3">e</span><span class="c18 c3">1</span><span> &gt;</span><span class="c3">e</span><span class="c9 c3">2</span><span>,</span><span class="c18"> </span><span class="c3">e</span><span class="c18 c3">1</span><span> &lt; </span><span class="c3">e</span><span class="c9 c3">2</span><span class="c3">, e</span><span class="c18 c3">1</span><span> &gt;= </span><span class="c3">e</span><span class="c9 c3">2</span><span>,</span><span class="c18"> </span><span class="c3">e</span><span class="c18 c3">1</span><span> &lt;= </span><span class="c3">e</span><span class="c9 c3">2</span><span class="c3"> </span><span>or </span><span class="c3">e</span><span class="c18 c3">1</span><span> % </span><span class="c3">e</span><span class="c9 c3">2</span><span>,</span><span class="c18"> </span><span class="c3"> </span><span>where </span><span class="c3">e</span><span>, </span><span class="c3">e</span><span class="c9 c3">1</span><span> and </span><span class="c3">e</span><span class="c9 c3">2</span><span> are constant expressions that evaluate to a numeric value.</span></li></ol><p class="c2 c4"><span></span></p><p class="c2"><span>It is a compile-time error if evaluation of a compile-time constant would raise an exception.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c11">The above is not dependent on program control-flow. The mere presence of a compile time constant whose evaluation would fail within a program is an error.  This also holds recursively: since compound constants are composed out of constants, if any subpart of a constant is would raise an exception when evaluated, that is an error.</span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span>It is a compile-time error if the value of a compile-time constant expression depends on itself.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c11">As an example, consider:</span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span class="c5 c11 c6">class</span><span class="c11 c6"> CircularConsts{ // Illegal program - mutually recursive compile-time constants</span></p><p class="c2"><span class="c11 c6">  </span><span class="c5 c11 c6">static</span><span class="c11 c6"> </span><span class="c5 c11 c6">final</span><span class="c11 c6"> i = j; // a compile-time constant</span></p><p class="c2"><span class="c11 c6">  </span><span class="c5 c11 c6">static</span><span class="c11 c6"> </span><span class="c5 c11 c6">final</span><span class="c11 c6"> j = i; // a compile-time constant</span></p><p class="c2"><span class="c11 c6">}</span></p><p class="c2 c4"><span class="c3 c14"></span></p><p class="c2 c4"><span class="c3 c14"></span></p><a href="#" name="id.88dsnjlmlm9c"></a><p class="c2"><span class="c5 c3">literal:</span><span class="c3"><br>      </span><span class="c0"><a class="c8" href="#id.kerf68lc6rxd">nullLiteral</a></span><span class="c3"><br>    | </span><span class="c0"><a class="c8" href="#id.bhttjpn562o">booleanLiteral</a></span><span class="c3"><br>    | </span><span class="c0"><a class="c8" href="#id.57n5jyggoz16">numericLiteral</a></span><span class="c3"><br>    | </span><span class="c0"><a class="c8" href="#id.evk894mdov9u">stringLiteral</a></span><span class="c3"><br>    | </span><span class="c0"><a class="c8" href="#id.yqueh2ebzths">mapLiteral</a></span><span class="c3"><br>    | </span><span class="c0"><a class="c8" href="#id.8u5sm21y6987">listLiteral</a></span><span class="c3"><br>    ;<br><br></span></p><a href="#" name="id.y33m1d6n2h6f"></a><h3 class="c2"><a name="h.gianetx6ltsy"></a><span>Null</span></h3><p class="c2"><span>The reserved word </span><span class="c5 c6">null</span><span> denotes the null object.</span></p><p class="c2"><span><br></span><a href="#" name="id.kerf68lc6rxd"></a><span class="c3">nullLiteral:</span><span class="c3"><br>      </span><span class="c5 c6">null</span></p><p class="c2"><span>;</span></p><p class="c2"><span>The null object is the sole instance of the built-in class </span><span class="c6">Null. </span><span>Attempting to instantiate Null causes a runtime error. It is a compile-time error for a class or interface attempt to extend or implement </span><span class="c6">Null.</span><span> Invoking a method on </span><span class="c5 c6">null</span><span> yields a </span><span class="c6">NullPointerException</span><span> unless the method is explicitly implemented by class </span><span class="c6">Null</span><span>.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>The static type of </span><span class="c5 c6">null</span><span> is bottom.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c3 c14">The decision to use bottom instead of </span><span class="c3 c14 c6">Null</span><span class="c3 c14"> allows </span><span class="c5 c3 c14 c6">null</span><span class="c3 c14"> to be be assigned everywhere without complaint by the static checker. </span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c11">Here is one way in which one might implement class Null:</span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span class="c11 c6">class Null {</span></p><p class="c2"><span class="c11 c6">   factory Null._() { throw &quot;cannot be instantiated&quot;; }</span></p><p class="c2"><span class="c11 c6">   </span><span class="c11 c6">noSuchMethod(InvocationMirror msg) {</span></p><p class="c2"><span class="c11 c6">      throw new NullPointerException();</span></p><p class="c2"><span class="c11 c6">   }</span></p><p class="c2 c4"><span class="c11 c6"></span></p><p class="c2"><span class="c11 c6">/* other methods, such as ==  */</span></p><p class="c2"><span class="c11 c6">}</span></p><p class="c2 c4"><span class="c11 c39"></span></p><p class="c2 c4"><span></span></p><a href="#" name="id.qjvme5fkz60x"></a><h3 class="c2"><a name="h.ofa8cxlvo8lw"></a><span>Numbers</span></h3><p class="c2 c4"><span></span></p><p class="c2"><span>A numeric literal is either a decimal or hexadecimal integer of arbitrary size, or a decimal double.</span></p><p class="c2 c4"><span></span></p><a href="#" name="id.57n5jyggoz16"></a><p class="c2"><span class="c5 c3">numericLiteral:</span><span class="c3"><br>       NUMBER<br>    | HEX_NUMBER<br>    ;</span></p><p class="c2 c4"><span class="c3"></span></p><a href="#" name="id.5qntm4tmtyju"></a><p class="c2"><span class="c5 c3">NUMBER:</span><span class="c3"><br>      &#39;+&#39;? DIGIT+ (&#39;.&#39; DIGIT+)? EXPONENT?<br>    | &#39;+&#39;? &#39;.&#39; DIGIT+ EXPONENT?<br>    ;<br></span></p><a href="#" name="id.4mskjmm2cajg"></a><p class="c2"><span class="c5 c3">EXPONENT:</span><span class="c3"><br>      (&#39;e&#39; | &#39;E&#39;) (&#39;+&#39; | &#39;-&#39;)? DIGIT+<br>    ;<br></span></p><p class="c2 c4"><span class="c3"></span></p><a href="#" name="id.1fvefff2yfdv"></a><p class="c2"><span class="c5 c3">HEX_NUMBER:</span><span class="c3"><br>      &#39;0x&#39; HEX_DIGIT+<br>    | &#39;0X&#39; HEX_DIGIT+<br>    ;<br><br> </span><a href="#" name="id.p2n864q7q3ax"></a><span class="c5 c3">HEX_DIGIT:</span><span class="c3"><br>      &#39;a&#39;..&#39;f&#39;<br>    | &#39;A&#39;..&#39;F&#39;<br>    | DIGIT<br>    ;<br></span></p><p class="c2"><span>If a numeric literal begins with the prefix ‘0x’, it is a</span><span class="c3"> hexadecimal integer literal,</span><span> which denotes the hexadecimal integer represented by the part of the literal following ‘0x’. Otherwise, if the numeric literal does not include a decimal point denotes an it is a </span><span class="c3">decimal integer literal,</span><span> which denotes a decimal integer.  Otherwise, the numeric literal is a </span><span class="c3">literal double</span><span> which denotes a 64 bit double precision floating point number as specified by the IEEE 754 standard. </span></p><p class="c2 c4"><span></span></p><p class="c2"><span>An integer literal or a literal double may optionally be prefixed by a plus sign (+). This </span><span>has no </span><span> semantic effect.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c3 c14">There is no unary plus operator in Dart. However, we allow a leading plus in decimal numeric literals for clarity and to provide some compatibility with Javascript.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c11">Integers are not restricted to a fixed range. Dart integers are true integers, not 32 bit or 64 bit or any other fixed range representation. Their size is limited only by the memory available to the implementation.</span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span>It is a compile-time error for a class or interface to attempt to extend or implement </span><span class="c6">int. </span><span>It is a compile-time error for a class or interface to attempt to extend or implement </span><span class="c6">double.</span><span> It is a compile-time error for any type other than the types </span><span class="c6">int</span><span> and </span><span class="c6">double</span><span> to attempt to extend or implement </span><span class="c6">num.</span><span class="c3"><br> </span></p><p class="c2"><span>An </span><span class="c3">integer literal</span><span> is either a hexadecimal integer literal or a  decimal integer literal.</span></p><p class="c2"><span>The static type of an integer literal is </span><span class="c6">int.</span><span> A </span><span class="c3">literal double</span><span> is a numeric literal that is not an integer literal. The static type of a literal double is </span><span class="c6">double.</span><span><br></span></p><a href="#" name="id.qyrl5513vmyg"></a><h3 class="c2"><a name="h.jitw991wrmh5"></a><span>Booleans</span></h3><p class="c2"><span>The reserved words </span><span class="c5 c6">true</span><span> and </span><span class="c5 c6">false</span><span> denote objects that represent the boolean values true and false respectively. They are the </span><span class="c3">boolean literals.</span></p><p class="c2 c4"><span></span></p><a href="#" name="id.bhttjpn562o"></a><p class="c2"><span class="c5 c3">booleanLiteral:</span><span class="c3"><br>      </span><span class="c5 c6">true</span><span class="c3"><br>    | </span><span class="c5 c6">false</span></p><p class="c2"><span class="c3">    ;</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span>Both  </span><span class="c5 c6">true</span><span> and </span><span class="c5 c6">false</span><span> are implement the built-in interface </span><span class="c6">bool.</span><span> They are the only two instances of </span><span class="c6">bool.</span><span> It is a compile-time error for a class or interface to attempt to extend or implement </span><span class="c6">bool.</span><span> </span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c11">It follows that the two boolean literals are the only two instances of </span><span class="c11 c6">bool.</span><span> </span></p><p class="c2 c4"><span></span></p><p class="c2"><span>The static type of a boolean literal is </span><span class="c6">bool.</span></p><p class="c2 c4"><span class="c19"></span></p><a href="#" name="id.luoug0f1vx2f"></a><h4 class="c2"><a name="h.qoglfpvek4rj"></a><span>Boolean Conversion</span></h4><p class="c2 c4"><span></span></p><p class="c2"><span class="c3">Boolean conversion</span><span> maps any object </span><span class="c3">o</span><span> into a boolean defined as </span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c6">(bool v){</span></p><p class="c2"><span class="c6">          </span><span class="c5 c6">assert</span><span class="c6">(v != </span><span class="c5 c6">null</span><span class="c6">);</span></p><p class="c2"><span class="c6">        </span><span class="c5 c6">return</span><span class="c6"> </span><span>v</span><span class="c5 c6"> </span><span class="c6">=== </span><span class="c5 c6">true</span><span class="c6">;</span></p><p class="c2"><span class="c6">}(o)</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c3 c14">Boolean conversion is used as part of control-flow constructs and boolean expressions.  Ideally, one would simply insist that control-flow decisions be based exclusively on booleans.  This is straightforward in a statically typed setting. In a dynamically typed language, it requires a dynamic check. Sophisticated virtual machines can minimize the penalty involved. </span><span class="c3 c14">Alas</span><span class="c3 c14">, Dart must be compiled into Javascript. Boolean conversion allows this to be done efficiently. </span></p><p class="c2 c4"><span class="c3 c14"></span></p><p class="c2"><span class="c3 c14">At the same time, this formulation differs radically from Javascript, where most numbers and objects are interpreted as </span><span class="c5 c3 c14 c6">true.</span><span class="c3 c14">  Dart’s approach prevents usages such  </span><span class="c5 c3 c14 c6">if</span><span class="c3 c14 c6"> (a-b) … ;</span><span class="c3 c14"> because it does not agree with the low level conventions whereby non-null objects or non-zero numbers are treated as </span><span class="c5 c3 c14 c6">true.</span><span class="c3 c14"> Indeed, there is no way to derive </span><span class="c5 c3 c14 c6">true</span><span class="c3 c14"> from a non-boolean object via boolean conversion, so this kind of low level hackery is nipped in the bud.</span></p><p class="c2 c4"><span class="c3 c14"></span></p><p class="c2"><span class="c3 c14">Dart also avoids the strange behaviors that can arise due to the interaction of boolean conversion with autoboxing in Javascript. A notorious example is the situation where </span><span class="c5 c3 c14 c6">false</span><span class="c3 c14"> can be interpreted as </span><span class="c5 c3 c14 c6">true.</span><span class="c3 c14"> In Javascript, booleans are not objects, and instead are autoboxed into objects where “needed”.  If </span><span class="c5 c3 c14 c6">false</span><span class="c3 c14"> gets autoboxed into an object, that object can be coerced into </span><span class="c5 c3 c14 c6">true</span><span class="c3 c14"> (as it is a non-null object). </span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><a href="#" name="id.6fv1qfiad49o"></a><h3 class="c2"><a name="h.fp52o176rzde"></a><span>Strings</span></h3><p class="c2 c4"><span></span></p><p class="c2"><span>A </span><span class="c3">string</span><span> is a sequence of valid unicode code points. </span></p><p class="c2 c4"><span></span></p><a href="#" name="id.evk894mdov9u"></a><p class="c2"><span class="c5 c3">stringLiteral:</span><span class="c3"><br>      &#39;@&#39;? MULTI_LINE_STRING<br>    | </span><span class="c3">SINGLE_LINE_STRING+</span><span class="c3"><br>    ;</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span>A string can be either a single line string or a multiline string. </span></p><p class="c2 c4"><span></span></p><a href="#" name="id.a307raw1rwqg"></a><p class="c2"><span class="c5 c3">SINGLE_LINE_STRING:</span><span class="c3"><br>      &#39;  &#39;&#39; &#39; STRING_CONTENT_DQ* &#39; &quot; &#39;<br>    | &#39; </span><span class="c3">&#39; &#39; </span><span class="c3">STRING_CONTENT_SQ* &#39; &#39; &#39;<br>    | &#39;@&#39; &#39; &#39; &#39; (~( &#39; &#39; &#39; | NEWLINE ))* &#39; &#39; &#39;<br>    | &#39;@&#39; &#39; &quot; &#39; (~( &#39; &quot; &#39; | NEWLINE ))* &#39; &quot; &#39;<br>    ;<br></span></p><p class="c2"><span>A single line string is delimited by either matching single quotes or matching double quotes. </span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c11">Hence, ‘abc’ and “abc” are both legal strings, as are ‘He said “To be or not to be” did he not?’  and “He said ‘To be or not to be’ didn’t he?”. However “This ‘ is not a valid string, nor is ‘this”.</span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span class="c11">The grammar ensures that a single line string cannot span more than one line of source code, unless it includes an interpolated expression that spans multiple lines.</span><span> </span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Adjacent single line strings are implicitly concatenated to form a single string literal.</span></p><p class="c2"><span class="c11">Here is an example</span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span class="c11">print(&quot;A string&quot; &quot;and then another&quot;); // prints: A stringand then another</span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c3 c14">Early versions of Dart used the operator + for string concatenation. However, this was  dropped, as it leads to puzzlers such as</span></p><p class="c2 c4"><span class="c3 c14"></span></p><p class="c2"><span class="c3 c14 c6">print(&quot;A simple sum: 2 + 2 = &quot; +</span></p><p class="c2"><span class="c3 c14 c6">            2 + 2);</span></p><p class="c2 c4"><span class="c3 c14"></span></p><p class="c2"><span class="c3 c14">which this prints  &#39;A simple sum: 2 + 2 = 22&#39; rather than &#39;A simple sum: 2 + 2 = 4&#39;.</span></p><p class="c2"><span class="c3 c14">Instead, the recommended Dart idiom is to use string interpolation.</span></p><p class="c2 c4"><span class="c3 c14"></span></p><p class="c2"><span class="c3 c14 c6">print(&quot;A simple sum: 2 + 2 =  ${2+2}&quot;);</span></p><p class="c2 c4"><span class="c3 c14"></span></p><p class="c2"><span class="c3 c14">String interpolation work well for most cases. The main situation where it is not fully satisfactory is for string literals that are too large to fit on a line. Multiline strings can be useful, but in some cases, we want to visually align the code. This can be expressed by writing smaller strings separated by whitespace, as shown here:</span></p><p class="c2 c4"><span class="c3 c14"></span></p><p class="c2"><span class="c3 c14">&#39;</span><span class="c3 c14 c6">Imagine this is a very long string that does not fit on a line. What shall we do? &#39;</span></p><p class="c2"><span class="c3 c14 c6">&#39;Oh what shall we do? &#39;</span></p><p class="c2"><span class="c3 c14 c6">&#39;We shall split it into pieces &#39;</span></p><p class="c2"><span class="c3 c14 c6">&#39;like so&#39;</span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2 c4"><span></span></p><a href="#" name="id.iin9r4eqf2b7"></a><p class="c2"><span class="c5 c3">MULTI_LINE_STRING</span><span class="c5 c3">:</span><span class="c3"><br>     &#39;</span><span class="c5 c3">&quot;&quot;&quot;</span><span class="c3">&#39;  (~ &#39;</span><span class="c5 c3">&quot;&quot;&quot;</span><span class="c3">&#39;)* &#39;</span><span class="c5 c3">&quot;&quot;&quot;</span><span class="c3">&#39;<br>    | &#39;</span><span class="c5 c3">&#39;&#39;&#39;</span><span class="c3">&#39; (~ &#39;</span><span class="c5 c3">&#39;&#39;&#39;</span><span class="c3">&#39;)* &#39;</span><span class="c5 c3">&#39;&#39;&#39;</span><span class="c3">&#39;<br>    ;<br></span></p><p class="c2 c4"><span class="c3"></span></p><a href="#" name="id.3nq8vkqtjqvz"></a><p class="c2"><span class="c5 c3">ESCAPE_SEQUENCE:</span></p><p class="c2"><span class="c3">     ‘\n’</span></p><p class="c2"><span class="c3">   | ‘\r’</span></p><p class="c2"><span class="c3">   | ‘\f’</span></p><p class="c2"><span class="c3">   | ‘\b’</span></p><p class="c2"><span class="c3">  | ‘\t’</span></p><p class="c2"><span class="c3">  | ‘\v’</span></p><p class="c2"><span class="c3">  | “\x’ HEX_DIGIT HEX_DIGIT</span></p><p class="c2"><span class="c3">  | ‘\u’ HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT</span></p><p class="c2"><span class="c3">  | ‘\u{‘ </span><span class="c3">HEX_DIGIT_SEQUENCE</span><span class="c3"> ‘}’</span></p><p class="c2"><span class="c3">  :</span></p><p class="c2 c4"><span class="c3"></span></p><a href="#" name="id.5gaf5oqxyhna"></a><p class="c2"><span class="c5 c3">HEX_DIGIT_SEQUENCE:</span></p><p class="c2"><span class="c3">     HEX_DIGIT HEX_DIGIT? HEX_DIGIT? HEX_DIGIT? HEX_DIGIT? HEX_DIGIT? </span></p><p class="c2"><span class="c3">    ;</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Multiline strings are delimited by either matching triples of single quotes or matching triples of double quotes.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Strings support escape sequences for special characters. The escapes are:</span></p><ol class="c25" start="1"><li class="c7 c2"><span> \n for newline, equivalent to \x0A.</span></li><li class="c7 c2"><span>\r for carriage return, equivalent to \x0D.</span></li><li class="c7 c2"><span>\f for form feed, equivalent to \x0C.</span></li><li class="c7 c2"><span>\b for backspace, equivalent to \x08.</span></li><li class="c7 c2"><span>\t for tab, equivalent to \x09.</span></li><li class="c7 c2"><span>\v for vertical tab, equivalent to \x0B.</span></li><li class="c7 c2"><span>\x</span><span class="c16 c3">HEX_DIGIT</span><span class="c9 c16 c3">1</span><span class="c16"> </span><span class="c16 c3">HEX_DIGIT</span><span class="c9 c16 c3">2</span><span>, equivalent to </span><span class="c16">\u{</span><span class="c16"> </span><span class="c16 c3">HEX_DIGIT</span><span class="c9 c16 c3">1</span><span class="c16"> </span><span class="c16 c3">HEX_DIGIT</span><span class="c9 c16 c3">2</span><span class="c16">}.</span></li><li class="c7 c2"><span>\u</span><span class="c16 c3">HEX_DIGIT</span><span class="c9 c16 c3">1</span><span class="c16"> </span><span class="c16 c3">HEX_DIGIT</span><span class="c9 c16 c3">2</span><span class="c16 c3"> HEX_DIGIT</span><span class="c9 c16 c3">3</span><span class="c16 c3"> HEX_DIGIT</span><span class="c9 c16 c3">4</span><span>, equivalent to </span><span class="c16">\u{ </span><span class="c16 c3">HEX_DIGIT</span><span class="c9 c16 c3">1</span><span class="c16"> </span><span class="c16 c3">HEX_DIGIT</span><span class="c9 c16 c3">2</span><span class="c16 c3"> HEX_DIGIT</span><span class="c9 c16 c3">3</span><span class="c16 c3"> HEX_DIGIT</span><span class="c9 c16 c3">4</span><span class="c16">}.</span></li><li class="c7 c2"><span>\u{</span><span class="c3">HEX_DIGIT_SEQUENCE</span><span>} </span><span class="c16">is the unicode scalar value represented by the </span><span class="c3">HEX_DIGIT_SEQUENCE</span><span class="c16">. It is a compile-time error if the value of the </span><span class="c3">HEX_DIGIT_SEQUENCE</span><span class="c16"> is not a valid unicode scalar value.</span></li><li class="c7 c2"><span>$ indicating the beginning of an interpolated expression.</span></li><li class="c7 c2"><span>Otherwise, \</span><span class="c3">k</span><span> indicates the character </span><span class="c3">k</span><span> for any </span><span class="c3">k</span><span> not in </span><span class="c3">{n, r, f, b, t, v, x, u}</span><span>.</span></li></ol><p class="c2"><span>It is a compile-time error if a string literal contains a character sequence of the form \x that is not followed by a sequence of two hexadecimal digits. It is a compile-time error if a string literal  contains a character sequence of the form \u that is not followed by either a sequence of four hexadecimal digits, or by curly brace delimited sequence of hexadecimal digits.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>However, any string may be prefixed with the character @, indicating that it is a </span><span class="c3">raw string,</span><span> in which case </span><span>no escapes</span><span> are recognized.</span><span class="c3"><br><br><br> </span></p><p class="c2 c4"><span class="c3"></span></p><a href="#" name="id.92eivgthr8m9"></a><p class="c2"><span class="c5 c3">STRING_CONTENT_DQ:</span><span class="c3"><br>      ~( &#39;</span><span class="c5 c3">\</span><span class="c3">&#39; | &#39;  </span><span class="c5 c3">&quot; </span><span class="c3"> &#39; | &#39;</span><span class="c5 c3">$</span><span class="c3">&#39; | NEWLINE )<br>    | &#39;</span><span class="c5 c3">\</span><span class="c3">&#39; ~( NEWLINE )<br>    | </span><span class="c3">STRING_INTERPOLATION</span><span class="c3"><br>    ;<br><br> </span><a href="#" name="id.kq4y2jlvvfaa"></a><span class="c5 c3">STRING_CONTENT_SQ:</span><span class="c3"><br>      ~( &#39;\&#39; | &#39;\&#39;&#39; | &#39;$&#39; | NEWLINE )<br>    | &#39;\&#39; ~( NEWLINE )<br>    | STRING_INTERPOLATION<br>    ;<br><br></span><a href="#" name="id.au65szsm2thq"></a><span class="c5 c3">NEWLINE:</span><span class="c3"><br>      \n<br>    | \r<br>    ;<br><br></span></p><p class="c2"><span>All string literals implement the built-in interface </span><span class="c6">String.</span><span> It is a compile-time error for a class or interface to attempt to extend or implement </span><span class="c6">String.</span><span> The static type of a string literal is </span><span class="c6">String.</span></p><p class="c2"><span class="c3"><br>    </span></p><a href="#" name="id.4kp5eixbuz9v"></a><h4 class="c2"><a name="h.us5hu2wpthk4"></a><span>String Interpolation</span></h4><p class="c2 c4"><span></span></p><p class="c2"><span>It is possible to embed expressions within string literals, such that the these expressions are evaluated, and the resulting values are converted into strings and concatenated with the enclosing string. This process is known as </span><span class="c3">string interpolation.</span></p><p class="c2 c4"><span class="c3"></span></p><a href="#" name="id.dajowkrascca"></a><p class="c2"><span class="c5 c3">STRING_INTERPOLATION:</span><span class="c3"><br>      &#39;$&#39; IDENTIFIER_NO_DOLLAR<br>    | &#39;$&#39; &#39;{&#39; </span><span class="c0"><a class="c8" href="#id.k68gukuq6cj9">expression </a></span><span class="c3">&#39;}&#39;<br>    ;<br></span></p><p class="c2"><span class="c11">The reader will note that the expression inside the interpolation could itself include strings, which could again be interpolated recursively. </span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2 c4"><span></span></p><p class="c2"><span>An unescaped $ character in a string signifies the beginning of an interpolated expression.  The $ sign may be followed by either:</span></p><ol class="c25" start="1"><li class="c7 c2"><span>A </span><span>single identifier </span><span class="c3">id</span><span> that must not contain the $ character. </span></li><li class="c7 c2"><span>An expression </span><span class="c3">e</span><span> delimited by curly braces.</span></li></ol><p class="c2 c4"><span></span></p><p class="c2"><span>The form </span><span class="c6">$id</span><span> is equivalent to the form </span><span class="c6">${id}</span><span>.  An interpolated string </span><span class="c3 c6">‘s</span><span class="c9 c3 c6">1</span><span class="c6">${</span><span class="c3 c6">e</span><span class="c6">}</span><span class="c3 c6">s</span><span class="c9 c3 c6">2</span><span class="c3 c6">’</span><span>  is equivalent to the concatenation of the strings </span><span>‘</span><span class="c3 c6">s</span><span class="c9 c3 c6">1</span><span class="c6">’</span><span>,</span><span class="c6"> </span><span class="c3 c6">e</span><span class="c6">.</span><span class="c6">toString</span><span class="c6">()</span><span> and </span><span class="c6">‘</span><span class="c3 c6">s</span><span class="c9 c3 c6">2</span><span class="c6">’.</span><span> </span><span>Likewise</span><span> an interpolated string </span><span class="c3 c6">“s</span><span class="c9 c3 c6">1</span><span class="c6">${</span><span class="c3 c6">e</span><span class="c6">}</span><span class="c3 c6">s</span><span class="c9 c3 c6">2</span><span class="c3 c6">’</span><span>” </span><span>is equivalent to the concatenation of  the strings “</span><span class="c3 c6">s</span><span class="c9 c3 c6">1</span><span class="c6">”</span><span>,</span><span class="c6"> </span><span class="c3 c6">e</span><span class="c6">.toString</span><span class="c6">()</span><span class="c6"> </span><span>and</span><span class="c6"> “</span><span class="c3 c6">s</span><span class="c9 c3 c6">2</span><span class="c6">”</span><span>.</span></p><p class="c2 c4"><span class="c6"></span></p><p class="c2 c4"><span class="c3 c14"></span></p><p class="c2 c4"><span></span></p><h3 class="c2"><a name="h.aj7d3xqsd3m5"></a><span>Lists</span></h3><p class="c2 c4"><span></span></p><p class="c2"><span>A</span><span class="c3"> list literal </span><span>denotes a list, which is an integer indexed collection of objects. </span></p><p class="c2 c4"><span></span></p><a href="#" name="id.8u5sm21y6987"></a><p class="c2"><span class="c5 c3">listLiteral:</span><span class="c3"><br>      </span><span class="c5 c6">const</span><span class="c6">?</span><span class="c3"> </span><span class="c0"><a class="c8" href="#id.okv2bn8j19mq">typeArguments</a></span><span class="c3">? &#39;[&#39; (</span><span class="c0"><a class="c8" href="#id.8a2tqk43n0f2">expressionList</a></span><span class="c3"> &#39;,&#39;?)? &#39;]&#39;<br>    ;<br></span></p><p class="c2"><span>A list may contain zero or more objects. The number of elements in a list is its </span><span class="c3">size.</span><span> A list has an associated set of indices.  An empty list has an empty set of indices. A non-empty list has the index set </span><span class="c3">{0 … n -1}</span><span> where </span><span class="c3">n</span><span> is the size of the list</span><span class="c3">.</span><span> It is a runtime error to attempt to access a list using an index that is not a member of its set of indices.</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span>If a list literal begins with the reserved word </span><span class="c5 c6">const</span><span>, it is a </span><span class="c3">constant list literal</span><span> and it is computed at compile-time. Otherwise, it is a </span><span class="c3">runtime list literal</span><span> and it is evaluated at runtime.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>It is a compile time error if an element of a constant list literal is not a compile-time constant. It is a compile time error if the type argument of a constant list literal </span><span>includes a type variable.</span></p><p class="c2"><span class="c3 c14">The binding of a type variable is not known at compile-time, so we cannot use type variables inside compile-time constants.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>The value of a constant list literal  </span><span class="c5 c6">const</span><span class="c3"> &lt;E&gt;[e</span><span class="c9 c3">1</span><span class="c3">... e</span><span class="c9 c3">n</span><span class="c3">]</span><span> is an object </span><span class="c3">a</span><span> that implements the built-in interface </span><span class="c3">List&lt;E&gt;</span><span class="c3">. </span><span>The </span><span class="c3">i</span><span>th element of </span><span class="c3">a</span><span> is </span><span class="c3">v</span><span class="c9 c3">i+1</span><span>, where </span><span class="c3">v</span><span class="c9 c3">i</span><span> is the value of the compile time expression </span><span class="c3">e</span><span class="c9 c3">i</span><span class="c3">.  </span><span>The value of a constant list literal  </span><span class="c5 c6">const</span><span class="c3"> [e</span><span class="c9 c3">1</span><span class="c3">... e</span><span class="c9 c3">n</span><span class="c3">]</span><span> is defined as the value of a constant list literal </span><span class="c5 c6">const</span><span class="c3"> &lt;Dynamic&gt;[e</span><span class="c9 c3">1</span><span class="c3">... e</span><span class="c9 c3">n</span><span class="c3">]</span><span>. It is a run-time error to attempt to modify a constant list literal.</span><span class="c11"> </span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Let </span><span class="c3">list</span><span class="c9 c3">1</span><span> = </span><span class="c5 c6">const</span><span class="c3"> &lt;V&gt;[e</span><span class="c9 c3">11</span><span class="c3">... e</span><span class="c9 c3">1n</span><span class="c3">] </span><span>and </span><span class="c3">list</span><span class="c9 c3">2</span><span> = </span><span class="c5 c6">const</span><span class="c3"> &lt;U&gt;[e</span><span class="c9 c3">21</span><span class="c3">... e</span><span class="c9 c3">2n</span><span class="c3">] </span><span>be two constant list literals and let the  elements of </span><span class="c3">list</span><span class="c9 c3">1</span><span> and </span><span class="c3">list</span><span class="c9 c3">2</span><span>  evaluate to  </span><span class="c3">o</span><span class="c9 c3">11</span><span class="c3">... o</span><span class="c9 c3">1n</span><span> and </span><span class="c3">o</span><span class="c9 c3">21</span><span class="c3">... o</span><span class="c9 c3">2n</span><span> respectively. Iff </span><span class="c3">o</span><span class="c9 c3">1i</span><span class="c6"> === </span><span class="c3">o</span><span class="c9 c3">2i</span><span> for </span><span class="c3">1 &lt;= i &lt;= n</span><span> and </span><span class="c3">V = U</span><span> then </span><span class="c3">list</span><span class="c9 c3">1</span><span> </span><span class="c6">===</span><span> </span><span class="c3">list</span><span class="c9 c3">2</span><span>. </span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c11">In other words, constant list literals are canonicalized.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>A runtime list literal </span><span class="c3">&lt;E&gt;[e</span><span class="c9 c3">1</span><span class="c3">... e</span><span class="c9 c3">n</span><span class="c3">]</span><span>  is evaluated as follows:</span></p><ol class="c25" start="1"><li class="c7 c2"><span>First, the expressions </span><span class="c3">e</span><span class="c9 c3">1</span><span class="c3">... e</span><span class="c9 c3">n</span><span> are evaluated in left to right order, yielding objects </span><span class="c3">o</span><span class="c9 c3">1</span><span class="c3">... o</span><span class="c9 c3">n</span><span>.</span></li><li class="c7 c2"><span>A fresh instance </span><span class="c3">a</span><span> </span><span>that implements the built-in interface </span><span class="c3">List</span><span class="c3 c6">&lt;E&gt;</span><span class="c3"> </span><span>is allocated. </span></li><li class="c7 c2"><span>The </span><span class="c3">i</span><span>th element of </span><span class="c3">a</span><span> is set to </span><span class="c3 c6">o</span><span class="c9 c3 c6">i+1</span><span>, </span><span class="c3">0 &lt;= i &lt;= n.</span></li><li class="c7 c2"><span>The result of the evaluation is </span><span class="c3">a.</span></li></ol><p class="c2 c4"><span></span></p><p class="c2"><span class="c11">Note that this specification does not specify an order in which the elements are set</span><span class="c11 c3">.</span><span class="c11"> This allows for parallel assignments into the list if an implementation so desires.  The order can only be observed in checked mode: if element </span><span class="c11 c3">i</span><span class="c11"> is not a subtype of the element type of the list, a dynamic type error will occur when </span><span class="c11 c3">a[i]</span><span class="c11"> is assigned </span><span class="c11 c3">o</span><span class="c9 c11 c3">i-1</span><span class="c11">. </span></p><p class="c2 c4"><span></span></p><p class="c2"><span>A runtime list literal  </span><span class="c3">[e</span><span class="c9 c3">1</span><span class="c3">... e</span><span class="c9 c3">n</span><span class="c3">]</span><span> is evaluated as  </span><span class="c3">&lt;Dynamic&gt;[e</span><span class="c9 c3">1</span><span class="c3">... e</span><span class="c9 c3">n</span><span class="c3">]</span><span>.</span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span class="c11">There is no restriction precluding nesting of list literals. It follows from the rules above that</span></p><p class="c2"><span class="c11 c6">&lt;List&lt;int&gt;&gt;[[1, 2, 3</span><span class="c11 c6">], [</span><span class="c11 c6">4, 5, 6]] </span><span class="c11">is a list with type parameter </span><span class="c11 c6">List&lt;int&gt;</span><span class="c11">, containing two lists with type parameter Dynamic. </span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span>The static type of a list literal of the form  </span><span class="c5 c6">const</span><span class="c3"> &lt;E&gt;[e</span><span class="c9 c3">1</span><span class="c3">... e</span><span class="c9 c3">n</span><span class="c3">]</span><span>  or the form </span><span class="c3">&lt;E&gt;[e</span><span class="c9 c3">1</span><span class="c3">... e</span><span class="c9 c3">n</span><span class="c3">]</span><span> is List</span><span class="c6">&lt;</span><span class="c3 c6">E</span><span class="c6">&gt;.</span><span> The static type a list literal of the form  </span><span class="c5 c6">const</span><span class="c3"> [e</span><span class="c9 c3">1</span><span class="c3">... e</span><span class="c9 c3">n</span><span class="c3">]</span><span>  or the form </span><span class="c3">[e</span><span class="c9 c3">1</span><span class="c3">... e</span><span class="c9 c3">n</span><span class="c3">]</span><span> is List</span><span class="c6">&lt;Dynamic&gt;.</span></p><p class="c2 c4"><span class="c6"></span></p><p class="c2"><span class="c3 c14">It is tempting to assume that the type of the list literal would be computed based on the types of its elements. However, for mutable lists this may be unwarranted. Even for constant lists, we found this behavior to be problematic. Since compile-time is often actually runtime, the runtime system must be able to perform a complex least upper bound computation to determine a reasonably precise type. It is better to leave this task to a tool in the IDE. It is also much more uniform (and therefore predictable and understandable) to insist that whenever types are unspecified they are assumed to be the unknown type Dynamic.</span></p><p class="c2 c4"><span></span></p><a href="#" name="id.riie55qjrb82"></a><h3 class="c2"><a name="h.1f7gnk1hnxaz"></a><span>Maps</span></h3><p class="c2 c4"><span></span></p><p class="c2"><span>A </span><span class="c3">map literal</span><span> denotes a </span><span class="c3">map</span><span> from strings to objects. </span></p><p class="c2 c4"><span></span></p><a href="#" name="id.yqueh2ebzths"></a><p class="c2"><span class="c5 c3">mapLiteral:</span><span class="c3"><br>     </span><span class="c5 c6">const</span><span class="c6">?</span><span class="c3"> </span><span class="c0"><a class="c8" href="#id.okv2bn8j19mq">typeArguments</a></span><span class="c3">? &#39;{&#39; (</span><span class="c0"><a class="c8" href="#id.pz53j3hd7ayc">mapLiteralEntry</a></span><span class="c3"> (&#39;,&#39; </span><span class="c0"><a class="c8" href="#id.pz53j3hd7ayc">mapLiteralEntry</a></span><span class="c3">)* &#39;,&#39;?)? &#39;}&#39;<br>    ;<br><br></span><a href="#" name="id.pz53j3hd7ayc"></a><span class="c5 c3">mapLiteralEntry:</span></p><p class="c2"><span class="c3">    </span><span class="c0"><a class="c8" href="#id.evk894mdov9u">stringLiteral</a></span><span class="c3"> &#39;:&#39; </span><span class="c0"><a class="c8" href="#id.k68gukuq6cj9">expression</a></span><span class="c3"><br>    ;<br></span></p><p class="c2"><span>A map literal consists of zero or more </span><span class="c3">entries</span><span>. Each entry has a </span><span class="c3">key,</span><span> which is a string literal, and a </span><span class="c3">value,</span><span> which is an object. </span></p><p class="c2"><span> </span></p><p class="c2"><span>If a map literal begins with the reserved word </span><span class="c5 c6">const</span><span>, it is a </span><span class="c3">constant map literal</span><span> and it is computed at compile-time. Otherwise, it is a run-time map literal and it is evaluated at run-time.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>It is a compile time error if either a key or a value of an entry in a constant map literal is not a compile-time constant. It is a compile time error if the type argument of a constant map literal includes a type variable. </span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><p class="c2"><span>The value of a constant map literal  </span><span class="c5 c6">const</span><span class="c3"> &lt;V&gt;{k</span><span class="c9 c3">1</span><span class="c3">:e</span><span class="c9 c3">1</span><span class="c3">... k</span><span class="c9 c3">n</span><span class="c3"> :e</span><span class="c9 c3">n</span><span class="c3">}</span><span> is an object </span><span class="c3">m</span><span> that implements the built-in interface </span><span class="c3">Map&lt;String, V&gt;. </span><span>The entries of </span><span class="c3">m</span><span> are </span><span class="c3">u</span><span class="c9 c3">i</span><span class="c3">:v</span><span class="c9 c3">i</span><span>, 1 &lt;= </span><span class="c3">i</span><span> &lt;= </span><span class="c3">n</span><span>, where </span><span class="c3">u</span><span class="c9 c3">i</span><span> is the value of the compile time expression </span><span class="c3">k</span><span class="c9 c3">i</span><span class="c3"> and</span><span class="c9 c3"> </span><span class="c3">v</span><span class="c9 c3">i</span><span> is the value of the compile time expression </span><span class="c3">e</span><span class="c9 c3">i</span><span class="c3">.  </span><span>The value of a constant map literal  </span><span class="c5 c6">const</span><span class="c3"> {k</span><span class="c9 c3">1</span><span class="c3">:e</span><span class="c9 c3">1</span><span class="c3">... k</span><span class="c9 c3">n</span><span class="c3"> :e</span><span class="c9 c3">n</span><span class="c3">} </span><span>is defined as the value of a constant map literal </span><span class="c5 c6">const</span><span class="c3"> &lt;Dynamic&gt;{k</span><span class="c9 c3">1</span><span class="c3">:e</span><span class="c9 c3">1</span><span class="c3">... k</span><span class="c9 c3">n</span><span class="c3"> :e</span><span class="c9 c3">n</span><span class="c3">}</span><span>.  It is a run-time error to attempt to modify a constant map literal.</span><span class="c11"> </span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c3 c14">As specified, a typed map literal takes only one type parameter. If we generalize literal maps so they can have keys that are not strings, we would need two parameters. </span><span class="c3 c14">The implementation currently insists on two parameters.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Let </span><span class="c3">map</span><span class="c9 c3">1</span><span> = </span><span class="c5 c6">const</span><span class="c3"> &lt;V&gt;{k</span><span class="c9 c3">11</span><span class="c3">:e</span><span class="c9 c3">11</span><span class="c3">... k</span><span class="c9 c3">1n</span><span class="c3"> :e</span><span class="c9 c3">1n</span><span class="c3">} </span><span>and </span><span class="c3">map</span><span class="c9 c3">2</span><span> </span><span>=</span><span> </span><span class="c5 c6">const</span><span class="c3"> &lt;U&gt;{k</span><span class="c9 c3">21</span><span class="c3">:e</span><span class="c9 c3">21</span><span class="c3">... k</span><span class="c9 c3">2n</span><span class="c3"> :e</span><span class="c9 c3">2n</span><span class="c3">} </span><span>be two constant map literals. Let the keys of </span><span class="c3">map</span><span class="c9 c3">1</span><span> and </span><span class="c3">map</span><span class="c9 c3">2 </span><span>evaluate to  </span><span class="c3">s</span><span class="c9 c3">11</span><span class="c3">... s</span><span class="c9 c3">1n</span><span class="c3">  and  s</span><span class="c9 c3">21</span><span class="c3">... s</span><span class="c9 c3">2n</span><span class="c3"> </span><span>respectively,</span><span class="c9 c3"> </span><span>and let the elements of </span><span class="c3">map</span><span class="c9 c3">1</span><span> and </span><span class="c3">map</span><span class="c9 c3">2 </span><span>evaluate to</span><span> </span><span class="c3">o</span><span class="c9 c3">11</span><span class="c3">... o</span><span class="c9 c3">1n</span><span> and </span><span class="c3">o</span><span class="c9 c3">21</span><span class="c3">... o</span><span class="c9 c3">2n</span><span class="c3"> </span><span>respectively. Iff </span><span class="c3">o</span><span class="c9 c3">1i</span><span class="c6"> === </span><span class="c3">o</span><span class="c9 c3">2i</span><span>  and </span><span class="c3">s</span><span class="c9 c3">1i</span><span class="c6"> === </span><span class="c3">s</span><span class="c9 c3">2i </span><span>for </span><span class="c3">1 &lt;= i &lt;= n, and V = U</span><span> then </span><span class="c3">map</span><span class="c9 c3">1</span><span> === </span><span class="c3">map</span><span class="c9 c3">2</span><span>. </span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c11">In other words, constant map literals are canonicalized.</span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><p class="c2"><span>A runtime map literal </span><span class="c3">&lt;V&gt;{k</span><span class="c9 c3">1</span><span class="c3">:e</span><span class="c9 c3">1</span><span class="c3">... k</span><span class="c9 c3">n</span><span class="c3"> :e</span><span class="c9 c3">n</span><span class="c3">}</span><span>  is evaluated as follows:</span></p><ol class="c25" start="5"><li class="c7 c2"><span>First, the expressions </span><span class="c3">e</span><span class="c9 c3">1</span><span class="c3">...e</span><span class="c9 c3">n</span><span> are evaluated in left to right order, yielding objects </span><span class="c3">o</span><span class="c9 c3">1</span><span class="c3">... o</span><span class="c9 c3">n</span><span>. </span></li><li class="c7 c2"><span>A fresh instance </span><span class="c3">m</span><span> that implements the built-in interface </span><span class="c3 c6">Map&lt;String, V&gt;</span><span class="c3"> </span><span>is allocated. </span></li><li class="c7 c2"><span>Let </span><span class="c3">u</span><span class="c9 c3">i</span><span> be the value of the compile-time constant string specified by </span><span class="c3">k</span><span class="c9 c3">i</span><span class="c3">.</span><span> An entry with key </span><span class="c3">u</span><span class="c9 c3">i</span><span> and value </span><span class="c3">o</span><span class="c9 c3">i</span><span> is added to </span><span class="c3">m,</span><span> </span><span class="c3">0 &lt;= i &lt;= n</span><span>.</span></li><li class="c7 c2"><span>The result of the evaluation is </span><span class="c3">m.</span></li></ol><p class="c2 c4"><span></span></p><p class="c2"><span>A runtime map literal  </span><span class="c3">{k</span><span class="c9 c3">1</span><span class="c3">:e</span><span class="c9 c3">1</span><span class="c3">... k</span><span class="c9 c3">n</span><span class="c3"> :e</span><span class="c9 c3">n</span><span class="c3">}</span><span> is evaluated as  </span><span class="c3">&lt;Dynamic&gt;{k</span><span class="c9 c3">1</span><span class="c3">:e</span><span class="c9 c3">1</span><span class="c3">... k</span><span class="c9 c3">n</span><span class="c3"> :e</span><span class="c9 c3">n</span><span class="c3">}</span><span>.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>It is a static warning if the values of any two keys in a map literal are equal.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>A map literal is </span><span class="c3">ordered:</span><span> iterating over the keys and/or values of the maps always happens in the order the keys appeared in the source code.</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span class="c11">Of course,</span><span class="c11"> if a key repeats, the order is defined by first occurrence, but the value is defined by the last. </span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span>The static type of a map literal of the form  </span><span class="c5 c6">const</span><span class="c3"> &lt;V&gt;{k</span><span class="c9 c3">1</span><span class="c3">:e</span><span class="c9 c3">1</span><span class="c3">... k</span><span class="c9 c3">n</span><span class="c3"> :e</span><span class="c9 c3">n</span><span class="c3">}</span><span> or the form </span><span class="c3">&lt;V&gt;{k</span><span class="c9 c3">1</span><span class="c3">:e</span><span class="c9 c3">1</span><span class="c3">... k</span><span class="c9 c3">n</span><span class="c3"> :e</span><span class="c9 c3">n</span><span class="c3">} </span><span>is </span><span class="c6">Map&lt;String, </span><span class="c3 c6">V</span><span class="c6">&gt;.</span><span> The static type a map literal of the form  </span><span class="c5 c6">const</span><span class="c3"> {k</span><span class="c9 c3">1</span><span class="c3">:e</span><span class="c9 c3">1</span><span class="c3">... k</span><span class="c9 c3">n</span><span class="c3"> :e</span><span class="c9 c3">n</span><span class="c3">}</span><span> or the form </span><span class="c3">{k</span><span class="c3 c9">1</span><span class="c3">:e</span><span class="c9 c3">1</span><span class="c3">... k</span><span class="c9 c3">n</span><span class="c3"> :e</span><span class="c9 c3">n</span><span class="c3">} </span><span>is </span><span class="c6">Map&lt;String, Dynamic&gt;.</span></p><p class="c2 c4"><span></span></p><a href="#" name="id.kmutx51qdso8"></a><h3 class="c2"><a name="h.w0k5ugtz3rpv"></a><span>Function Expressions</span></h3><p class="c2 c4"><span></span></p><p class="c2"><span>A </span><span class="c3">function literal</span><span> is an object that encapsulates an executable unit of code. </span></p><p class="c2 c4"><span></span></p><a href="#" name="id.p3fm2ke402rw"></a><p class="c2"><span class="c5 c3">functionExpression:</span><span class="c3"><br>    (</span><span class="c0"><a class="c8" href="#id.mriqqq9dwbm5">returnType</a></span><span class="c3">? </span><span class="c0"><a class="c8" href="#id.te0njh1fhw7g">identifier</a></span><span class="c3">)? </span><span class="c0"><a class="c8" href="#id.6xer2paz3k7q">formalParameterList</a></span><span class="c3"> </span><span class="c0"><a class="c8" href="#id.airwihpzw070">functionExpressionBody</a></span><span class="c3"><br>    ;<br><br><br></span><a href="#" name="id.airwihpzw070"></a><span class="c5 c3">functionExpressionBody:</span><span class="c3"><br>      &#39;=&gt;&#39; </span><span class="c0"><a class="c8" href="#id.1u3vxuwrz6py">expression</a></span><span class="c3"><br>    | </span><span class="c0"><a class="c8" href="#kix.kx7urn183i41">block</a></span><span class="c3"><br>    ;</span></p><p class="c2"><span class="c3"><br></span><span> A function literal implements the built-in interface </span><span class="c6">Function.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>The static type of a function literal of the form </span><span class="c3">(T</span><span class="c9 c3">1 </span><span class="c3">a</span><span class="c9 c3">1</span><span class="c3">, …, T</span><span class="c9 c3">n </span><span class="c3">a</span><span class="c9 c3">n</span><span class="c3">, [T</span><span class="c9 c3">n+1  </span><span class="c3">x</span><span class="c9 c3">n+1</span><span class="c3"> = d</span><span class="c9 c3">1</span><span class="c3">, … ,T</span><span class="c9 c3">n+k</span><span class="c3"> x</span><span class="c9 c3">n+k</span><span class="c3"> = d</span><span class="c9 c3">k</span><span class="c3">]) =&gt; e</span><span> or the form </span><span class="c3">id(T</span><span class="c9 c3">1 </span><span class="c3">a</span><span class="c9 c3">1</span><span class="c3">, …, T</span><span class="c9 c3">n </span><span class="c3">a</span><span class="c9 c3">n</span><span class="c3">, [T</span><span class="c9 c3">n+1  </span><span class="c3">x</span><span class="c9 c3">n+1</span><span class="c3"> = d</span><span class="c9 c3">1</span><span class="c3">, …, T</span><span class="c9 c3">n+k</span><span class="c3"> x</span><span class="c9 c3">n+k</span><span class="c3"> = d</span><span class="c9 c3">k</span><span class="c3">]) =&gt; e </span><span>is </span><span class="c3">(T</span><span class="c9 c3">1</span><span class="c3">, …, T</span><span class="c9 c3">n</span><span class="c3">, [T</span><span class="c9 c3">n+1</span><span class="c3"> x</span><span class="c9 c3">n+1</span><span class="c3">, .., T</span><span class="c9 c3">n+k</span><span class="c3"> x</span><span class="c9 c3">n+k</span><span class="c3">]) →T</span><span class="c9 c3">0</span><span>, where </span><span class="c3">T</span><span class="c9 c3">0</span><span> is the static type of </span><span class="c3">e.</span><span> In any case where </span><span class="c3">T</span><span class="c9 c3">i</span><span class="c3"> ,1 &lt;= i &lt;= n,  </span><span>is not specified, it is considered to have been specified as </span><span class="c5 c6">Dynamic</span><span>.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>The static type of a function literal of the form </span><span class="c3">T</span><span class="c9 c3">0</span><span class="c3"> id(T</span><span class="c9 c3">1 </span><span class="c3">a</span><span class="c9 c3">1</span><span class="c3">, …, T</span><span class="c9 c3">n </span><span class="c3">a</span><span class="c9 c3">n</span><span class="c3">, [T</span><span class="c9 c3">n+1  </span><span class="c3">x</span><span class="c9 c3">n+1</span><span class="c3"> = d</span><span class="c9 c3">1</span><span class="c3">, …, T</span><span class="c9 c3">n+k</span><span class="c3"> x</span><span class="c9 c3">n+k</span><span class="c3"> = d</span><span class="c9 c3">k</span><span class="c3">]){s}</span><span> or the form </span><span class="c3">T</span><span class="c9 c3">0</span><span class="c3"> id(T</span><span class="c9 c3">1 </span><span class="c3">a</span><span class="c9 c3">1</span><span class="c3">, …, T</span><span class="c9 c3">n </span><span class="c3">a</span><span class="c9 c3">n</span><span class="c3">, [T</span><span class="c9 c3">n+1  </span><span class="c3">x</span><span class="c9 c3">n+1</span><span class="c3"> = d</span><span class="c9 c3">1</span><span class="c3">, …, T</span><span class="c9 c3">n+k</span><span class="c3"> x</span><span class="c9 c3">n+k</span><span class="c3"> = d</span><span class="c9 c3">k</span><span class="c3">]) =&gt; e </span><span>is </span><span class="c3">(T</span><span class="c9 c3">1</span><span class="c3">, …, T</span><span class="c9 c3">n</span><span class="c3">, [T</span><span class="c9 c3">n+1</span><span class="c3"> x</span><span class="c9 c3">n+1</span><span class="c3">, .., T</span><span class="c9 c3">n+k</span><span class="c3"> x</span><span class="c9 c3">n+k</span><span class="c3">]) →T</span><span class="c9 c3">0</span><span class="c3">.</span><span> In any case where </span><span class="c3">T</span><span class="c9 c3">i</span><span class="c3"> ,1 &lt;= i &lt;= n, </span><span>is not specified, it is considered to have been specified as </span><span class="c5 c6">Dynamic</span><span>.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>The static type of a function literal of the form </span><span class="c3">id(T</span><span class="c9 c3">1 </span><span class="c3">a</span><span class="c9 c3">1</span><span class="c3">, …, T</span><span class="c9 c3">n </span><span class="c3">a</span><span class="c9 c3">n</span><span class="c3">, [T</span><span class="c9 c3">n+1  </span><span class="c3">x</span><span class="c9 c3">n+1</span><span class="c3"> = d</span><span class="c9 c3">1</span><span class="c3">,… T</span><span class="c9 c3">n+k</span><span class="c3"> x</span><span class="c9 c3">n+k</span><span class="c3"> = d</span><span class="c9 c3">k</span><span class="c3">]){s}</span><span> or the form </span><span class="c3">(T</span><span class="c9 c3">1 </span><span class="c3">a</span><span class="c9 c3">1</span><span class="c3">, …, T</span><span class="c9 c3">n </span><span class="c3">a</span><span class="c9 c3">n</span><span class="c3">, [T</span><span class="c9 c3">n+1  </span><span class="c3">x</span><span class="c9 c3">n+1</span><span class="c3"> = d</span><span class="c9 c3">1</span><span class="c3">, …, T</span><span class="c9 c3">n+k</span><span class="c3"> x</span><span class="c9 c3">n+k</span><span class="c3"> = d</span><span class="c9 c3">k</span><span class="c3">]) {s} </span><span>is </span><span class="c3">(T</span><span class="c9 c3">1</span><span class="c3">, …, T</span><span class="c9 c3">n</span><span class="c3">, [T</span><span class="c9 c3">n+1</span><span class="c3"> x</span><span class="c9 c3">n+1</span><span class="c3">, .., T</span><span class="c9 c3">n+k</span><span class="c3"> x</span><span class="c9 c3">n+k</span><span class="c3">]) → </span><span class="c5 c6">Dynamic</span><span class="c3">.</span><span> In any case where </span><span class="c3">T</span><span class="c9 c3">i</span><span class="c3"> ,1 &lt;= i &lt;= n, </span><span>is not specified, it is considered to have been specified as </span><span class="c5 c6">Dynamic</span><span>.</span></p><p class="c2 c4"><span class="c3"><br></span></p><a href="#" name="id.v2khzso6nh04"></a><h3 class="c2"><a name="h.a02n00oljphq"></a><span>This</span></h3><p class="c2"><span>The reserved word </span><span class="c5 c6">this</span><span> denotes the target of the current instance member invocation.</span></p><p class="c2 c4"><span></span></p><a href="#" name="id.wwq4i2tyv7sn"></a><p class="c2"><span class="c5 c3">thisExpression:</span><span class="c3"><br>      </span><span class="c5 c6">this</span></p><p class="c2"><span class="c6">     ;</span></p><p class="c2 c4"><span class="c6"></span></p><p class="c2"><span>The static type of </span><span class="c5 c6">this</span><span> is the interface of the immediately enclosing class.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c11">We do not support self-types at this point. </span></p><p class="c2 c4"><span class="c6"></span></p><p class="c2"><span>It is a compile-time error </span><span class="c6">if </span><span class="c5 c6">this</span><span> appears in a top-level function or variable initializer,  in a factory constructor, or in a static method or variable initializer.</span><span class="c6"> </span></p><p class="c2 c4"><span></span></p><a href="#" name="id.hvkbnlui8uvu"></a><h3 class="c2"><a name="h.seezxc7foicl"></a><span>Instance Creation</span></h3><p class="c2 c4"><span></span></p><p class="c2"><span>Instance creation expressions invoke constructors to produce instances. </span></p><p class="c2 c4"><span></span></p><p class="c2"><span>It is a static warning to instantiate an </span><span class="c1"><a class="c8" href="#id.t8nep39l3cq0">abstract class</a></span><span>. </span></p><p class="c2 c4"><span></span></p><p class="c2"><span>It is a compile-time error if any of the type arguments to a constructor of a generic type invoked by a new expression or a constant object expression do not denote types in the enclosing lexical scope. It is a compile-time error if a constructor of a non-generic type invoked by a new expression or a constant object expression is passed any type arguments. It is a compile-time error if a constructor of a generic type with </span><span class="c3">n</span><span> type parameters invoked by a new expression or a constant object expression is passed </span><span class="c3">m</span><span> type arguments where </span><span class="c3">m != n</span><span>. </span></p><p class="c2 c4"><span></span></p><p class="c2"><span>It is a static type warning if any of the type arguments to a constructor of a generic type </span><span class="c3">G</span><span> invoked by a new expression or a constant object expression are not </span><span>subtypes of the bounds</span><span> of the corresponding formal type parameters of </span><span class="c3">G.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Let </span><span class="c3">I</span><span> be an </span><span class="c1"><a class="c8" href="#id.obndo59vaebw">interface type</a></span><span> with </span><span class="c1"><a class="c8" href="#id.5kvtnnyqvcjb">default factory</a></span><span> </span><span class="c3">F.</span><span> It is a static type warning if any of the type arguments to the  constructor of </span><span class="c3">I</span><span> invoked by a new expression or a constant object expression are not </span><span>subtypes of the bounds</span><span> of the corresponding formal type parameters of </span><span class="c3">F.</span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><a href="#" name="id.pp0ymlz8g03s"></a><h4 class="c2"><a name="h.twiod7rqtbah"></a><span>New</span></h4><p class="c2"><span>The </span><span class="c3">new expression</span><span> invokes a </span><span class="c1"><a class="c8" href="#id.yh8ud94ky84">constructor</a></span><span>.</span></p><p class="c2 c4"><span></span></p><a href="#" name="id.a0815nq10roy"></a><p class="c2"><span class="c5 c3">newExpression:</span></p><p class="c2 c35"><span class="c5 c6">new</span><span class="c3"> </span><span class="c0"><a class="c8" href="#id.qv2a3rupuer9">type</a></span><span class="c3"> (&#39;.&#39; </span><span class="c0"><a class="c8" href="#id.te0njh1fhw7g">identifier</a></span><span class="c3">)? </span><span class="c1 c3"><a class="c8" href="#kix.xl2ewwstkqba">arguments</a></span></p><p class="c2 c35"><span>;</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Let </span><span class="c3">e</span><span> be a new expression of the form </span><span class="c5 c6">new</span><span class="c3"> T.id(a</span><span class="c9 c3">1</span><span class="c3">, .., a</span><span class="c9 c3">n</span><span class="c3">,</span><span class="c9 c3"> </span><span class="c3">x</span><span class="c9 c3">n+1</span><span class="c3">: a</span><span class="c9 c3">n+1</span><span class="c3">, …, x</span><span class="c9 c3">n+k</span><span class="c3">: a</span><span class="c9 c3">n+k</span><span class="c3">) </span><span>or the form </span><span class="c5 c6">new</span><span class="c3"> T(a</span><span class="c9 c3">1</span><span class="c3">, .., a</span><span class="c9 c3">n</span><span class="c3">,</span><span class="c9 c3"> </span><span class="c3">x</span><span class="c9 c3">n+1</span><span class="c3">: a</span><span class="c9 c3">n+1</span><span class="c3">, …, x</span><span class="c9 c3">n+k</span><span class="c3">: a</span><span class="c9 c3">n+k</span><span class="c3">)</span><span>.</span><span class="c3"> </span><span>It is a compile-time error if </span><span class="c3">T</span><span> is not a class or interface accessible in the current scope, optionally followed by type arguments. </span></p><p class="c2 c4"><span></span></p><p class="c2"><span>If </span><span class="c3">e</span><span> is of the form </span><span class="c5 c6">new</span><span class="c3"> T.id(a</span><span class="c9 c3">1</span><span class="c3">, .., a</span><span class="c9 c3">n</span><span class="c3">,</span><span class="c9 c3"> </span><span class="c3">x</span><span class="c9 c3">n+1</span><span class="c3">: a</span><span class="c9 c3">n+1</span><span class="c3">, …, x</span><span class="c9 c3">n+k</span><span class="c3">: a</span><span class="c9 c3">n+k</span><span class="c3">) </span><span>it is a compile-time error if </span><span class="c3">T</span><span> is not a class or interface accessible in the current scope, optionally followed by type arguments.  It is a compile-time error if </span><span class="c3">T.id</span><span> is not the name of a constructor declared by the type </span><span class="c3">T.</span><span> If </span><span class="c3">e</span><span> of the form </span><span class="c5 c6">new</span><span class="c3"> T(a</span><span class="c9 c3">1</span><span class="c3">, .., a</span><span class="c9 c3">n</span><span class="c3">,</span><span class="c9 c3"> </span><span class="c3">x</span><span class="c9 c3">n+1</span><span class="c3">: a</span><span class="c9 c3">n+1</span><span class="c3">, …, x</span><span class="c9 c3">n+k</span><span class="c3">: a</span><span class="c9 c3">n+k</span><span class="c3">) </span><span>it is a compile-time error if the type </span><span class="c3">T </span><span>does not declare a constructor with the same name as the declaration of </span><span class="c3">T.</span><span> </span></p><p class="c2 c4"><span></span></p><p class="c2"><span>If </span><span class="c3">T</span><span> is a parameterized type </span><span class="c3">S&lt;U</span><span class="c9 c3">1</span><span class="c3">, ,.., U</span><span class="c9 c3">m</span><span class="c3">&gt;,</span><span> let </span><span class="c3">R = S.</span><span> </span><span class="c3"> </span><span>It is a compile time error if </span><span class="c3">S</span><span> is not a generic type with </span><span class="c3">m</span><span> type parameters. If </span><span class="c3">T</span><span> is not a parameterized type, let </span><span class="c3">R = T.</span></p><p class="c2"><span>If </span><span class="c3">R</span><span> is an interface, let </span><span class="c3">C </span><span>be the factory class of </span><span class="c3">R</span><span>. Otherwise let </span><span class="c3">C = R.</span><span> Furthermore, if </span><span class="c3">e</span><span> is of the form </span><span class="c5 c6">new</span><span class="c3"> T.id(a</span><span class="c9 c3">1</span><span class="c3">, .., a</span><span class="c9 c3">n</span><span class="c3">,</span><span class="c9 c3"> </span><span class="c3">x</span><span class="c9 c3">n+1</span><span class="c3">: a</span><span class="c9 c3">n+1</span><span class="c3">, …, x</span><span class="c9 c3">n+k</span><span class="c3">: a</span><span class="c9 c3">n+k</span><span class="c3">)</span><span> then let  </span><span class="c3">q </span><span>be the constructor of </span><span class="c3">C</span><span> that corresponds to the constructor </span><span class="c3">T.id, </span><span>otherwise let </span><span class="c3">q</span><span> be the constructor of </span><span class="c3">C</span><span> that corresponds to the constructor </span><span class="c3">T</span><span>. Finally, if </span><span class="c3">C</span><span> is generic but </span><span class="c3">T</span><span> is not a parameterized type, then for </span><span class="c3">1 &lt;= i &lt;= m, let V</span><span class="c9 c3">i</span><span class="c3"> = </span><span class="c5 c6">Dynamic</span><span>, otherwise let </span><span class="c3">V</span><span class="c9 c3">i</span><span class="c3"> = U</span><span class="c9 c3">i</span><span class="c3">. </span><span> </span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Evaluation of </span><span class="c3">e</span><span> proceeds as follows:</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>First, if </span><span class="c3">q</span><span> is a generative constructor, then:</span></p><p class="c2 c4"><span></span></p><p class="c2 c15"><span>If </span><span class="c3">R != C,</span><span> then let </span><span class="c3">W</span><span class="c9 c3">i</span><span> be the type parameters of </span><span class="c3">R</span><span> (if any) and let </span><span class="c3">D</span><span class="c9 c3">i</span><span> be the bounds of </span><span class="c3">W</span><span class="c9 c3">i</span><span class="c3">, 1 &lt;= i &lt;= m.</span><span> In checked mode, it is a dynamic type error if </span><span class="c3">V</span><span class="c9 c3">i</span><span class="c9"> </span><span>is not a subtype of  </span><span class="c3">[V</span><span class="c9 c3">1</span><span class="c3">,  ..., V</span><span class="c9 c3">m</span><span class="c3">/W</span><span class="c9 c3">1</span><span class="c3">,  ..., W</span><span class="c9 c3">m</span><span class="c3">]D</span><span class="c9 c3">i</span><span class="c3">, 1 &lt;= i &lt;= m.</span></p><p class="c2 c4"><span></span></p><p class="c2 c15"><span>Regardless of whether </span><span class="c3">R != C,</span><span> let </span><span class="c3">T</span><span class="c9 c3">i</span><span> be the type parameters of </span><span class="c3">C</span><span> (if any) and let </span><span class="c3">B</span><span class="c9 c3">i</span><span> be the bounds of </span><span class="c3">T</span><span class="c9 c3">i</span><span class="c3">, 1 &lt;= i &lt;= m.</span><span> It is a dynamic type error if, in checked mode, </span><span class="c3">V</span><span class="c9 c3">i</span><span class="c9"> </span><span>is not a subtype of  </span><span class="c3">[V</span><span class="c9 c3">1</span><span class="c3">,  ..., V</span><span class="c9 c3">m</span><span class="c3">/T</span><span class="c9 c3">1</span><span class="c3">,  ..., T</span><span class="c9 c3">m</span><span class="c3">]B</span><span class="c9 c3">i</span><span class="c3">, 1 &lt;= i &lt;= m.</span></p><p class="c2 c4"><span></span></p><p class="c2 c15"><span>A fresh instance,</span><span class="c3"> i,</span><span>  of class </span><span class="c3">C</span><span> is allocated. For each instance variable </span><span class="c3">f</span><span> of </span><span class="c3">i, </span><span> if the variable declaration of </span><span class="c3">f</span><span> has an initializer, then </span><span class="c3">f</span><span> is bound to that value (which is necessarily a compile-time constant). Otherwise </span><span class="c3">f</span><span> is bound to </span><span class="c5 c6">null.</span><span>  </span></p><p class="c2 c4 c35 c15"><span></span></p><p class="c2 c15"><span>Next, the argument list </span><span class="c3">(a</span><span class="c9 c3">1</span><span class="c3">, …, a</span><span class="c9 c3">n</span><span class="c3">, x</span><span class="c9 c3">n+1</span><span class="c3">: a</span><span class="c9 c3">n+1</span><span class="c3">, …, x</span><span class="c9 c3">n+k</span><span class="c3">: a</span><span class="c9 c3">n+k</span><span class="c3">)</span><span> is evaluated. Then, the initializer list of </span><span class="c3">q</span><span> is executed with respect to the bindings that resulted from the evaluation of the argument list, and with </span><span class="c5 c6">this</span><span> bound to </span><span class="c3">i</span><span> and  the type parameters (if any) of </span><span class="c3">C</span><span> bound to the actual type arguments </span><span class="c3">V</span><span class="c9 c3">1</span><span class="c3">, ,.., V</span><span class="c9 c3">m</span><span>. Finally, the body of </span><span class="c3">q </span><span>is executed with respect to the bindings that resulted from the evaluation of the argument list. The result of the evaluation of </span><span class="c3">e</span><span> is </span><span class="c3">i.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Otherwise, if </span><span class="c3">q</span><span> is a redirecting constructor, then:</span></p><p class="c2 c15"><span>The argument list </span><span class="c3">(a</span><span class="c9 c3">1</span><span class="c3">, …, a</span><span class="c9 c3">n</span><span class="c3">, x</span><span class="c9 c3">n+1</span><span class="c3">: a</span><span class="c9 c3">n+1</span><span class="c3">, …, x</span><span class="c9 c3">n+k</span><span class="c3">: a</span><span class="c9 c3">n+k</span><span class="c3">)</span><span> is evaluated. Then, the redirect clause of </span><span class="c3">q</span><span> is executed with respect to the bindings that resulted from the evaluation of the argument list and the type parameters (if any) of </span><span class="c3">C</span><span> bound to the actual type arguments </span><span class="c3">V</span><span class="c9 c3">1</span><span class="c3">, ,.., V</span><span class="c9 c3">m</span><span>.  resulting in an object </span><span class="c3">i</span><span> that is necessarily the result of another constructor call. The result of the evaluation of </span><span class="c3">e</span><span> is </span><span class="c3">i.</span></p><p class="c2 c4 c15"><span></span></p><p class="c2"><span>Otherwise, </span><span class="c3">q</span><span> is a factory constructor. Then:</span></p><p class="c2 c4"><span></span></p><p class="c2 c15"><span>If </span><span class="c3">R != C,</span><span> then let </span><span class="c3">W</span><span class="c9 c3">i</span><span> be the type parameters of </span><span class="c3">R</span><span> (if any) and let </span><span class="c3">D</span><span class="c9 c3">i</span><span> be the bounds of </span><span class="c3">W</span><span class="c9 c3">i</span><span class="c3">, 1 &lt;= i &lt;= m.</span><span> In checked mode, it is a dynamic type error if </span><span class="c3">V</span><span class="c9 c3">i</span><span class="c9"> </span><span>is not a subtype of  </span><span class="c3">[V</span><span class="c9 c3">1</span><span class="c3">,  ..., V</span><span class="c9 c3">m</span><span class="c3">/W</span><span class="c9 c3">1</span><span class="c3">,  ..., W</span><span class="c9 c3">m</span><span class="c3">]D</span><span class="c9 c3">i</span><span class="c3">, 1 &lt;= i &lt;= m.</span></p><p class="c2 c4"><span></span></p><p class="c2 c15"><span>Regardless of whether </span><span class="c3">R != C,</span><span> let </span><span class="c3">T</span><span class="c9 c3">i</span><span> be the type parameters of </span><span class="c3">C</span><span> (if any) and let </span><span class="c3">B</span><span class="c9 c3">i</span><span> be the bounds of </span><span class="c3">T</span><span class="c9 c3">i</span><span class="c3">, 1 &lt;= i &lt;= m.</span><span> In checked mode, it is a dynamic type error if </span><span class="c3">V</span><span class="c9 c3">i</span><span class="c9"> </span><span>is not a subtype of  </span><span class="c3">[V</span><span class="c9 c3">1</span><span class="c3">,  ..., V</span><span class="c9 c3">m</span><span class="c3">/T</span><span class="c9 c3">1</span><span class="c3">,  ..., T</span><span class="c9 c3">m</span><span class="c3">]B</span><span class="c9 c3">i</span><span class="c3">, 1 &lt;= i &lt;= m.</span></p><p class="c2 c4"><span></span></p><p class="c2 c15"><span>The argument list </span><span class="c3">(a</span><span class="c9 c3">1</span><span class="c3">, …, a</span><span class="c9 c3">n</span><span class="c3">, x</span><span class="c9 c3">n+1</span><span class="c3">: a</span><span class="c9 c3">n+1</span><span class="c3">, …, x</span><span class="c9 c3">n+k</span><span class="c3">: a</span><span class="c9 c3">n+k</span><span class="c3">)</span><span> is evaluated Then, the body of </span><span class="c3">k</span><span> is executed  with respect to the bindings that resulted from the evaluation of the argument list and the type parameters (if any) of </span><span class="c3">q</span><span> bound to the actual type arguments </span><span class="c3">V</span><span class="c9 c3">1</span><span class="c3">, ,.., V</span><span class="c9 c3">m</span><span> </span><span>resulting in an object </span><span class="c3">i.</span><span> The result of the evaluation of </span><span class="c3">e</span><span> is </span><span class="c3">i.</span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><p class="c2"><span>The static type of a new expression of either the form </span><span class="c5 c6">new</span><span class="c3"> T.id(a</span><span class="c9 c3">1</span><span class="c3">, .., a</span><span class="c9 c3">n</span><span class="c3">)</span><span> or the form </span><span class="c5 c6">new</span><span class="c3"> T(a</span><span class="c9 c3">1</span><span class="c3">, .., a</span><span class="c9 c3">n</span><span class="c3">)</span><span> is</span><span class="c3"> T.</span><span> It is a static warning if the static type of </span><span class="c3">a</span><span class="c9 c3">i</span><span class="c3">, 1 &lt;= i &lt;= n+ k </span><span>may not be assigned to the type of the corresponding formal parameter of the constructor </span><span class="c3">T.id</span><span> (respectively </span><span class="c3">T</span><span>).</span></p><p class="c2 c4"><span></span></p><a href="#" name="id.bfpdh2tlvt0v"></a><h4 class="c2"><a name="h.kk36x2av9f7f"></a><span>Const</span></h4><p class="c2"><span>A </span><span class="c3">constant object expression</span><span> invokes a </span><span class="c1"><a class="c8" href="#id.okcph2t66jnm">constant constructor</a></span><span>. </span></p><p class="c2 c4"><span></span></p><a href="#" name="id.py555jou6no8"></a><p class="c2"><span class="c5 c3">constObjectExpression:</span></p><p class="c2 c35"><span class="c5 c6">const</span><span class="c3"> </span><span class="c0"><a class="c8" href="#id.qv2a3rupuer9">type</a></span><span class="c3"> (&#39;.&#39; </span><span class="c0"><a class="c8" href="#id.te0njh1fhw7g">identifier</a></span><span class="c3">)? </span><span class="c0"><a class="c8" href="#kix.xl2ewwstkqba">arguments</a></span></p><p class="c2 c35"><span>;</span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Let </span><span class="c3">e</span><span> be a constant object expression of the form </span><span class="c5 c6">const</span><span class="c3"> T.id(a</span><span class="c9 c3">1</span><span class="c3">, .., a</span><span class="c9 c3">n</span><span class="c3">,</span><span class="c9 c3"> </span><span class="c3">x</span><span class="c9 c3">n+1</span><span class="c3">: a</span><span class="c9 c3">n+1</span><span class="c3">, …, x</span><span class="c9 c3">n+k</span><span class="c3">: a</span><span class="c9 c3">n+k</span><span class="c3">) </span><span>or the form </span><span class="c5 c6">const</span><span class="c3"> T(a</span><span class="c9 c3">1</span><span class="c3">, .., a</span><span class="c9 c3">n</span><span class="c3">,</span><span class="c9 c3"> </span><span class="c3">x</span><span class="c9 c3">n+1</span><span class="c3">: a</span><span class="c9 c3">n+1</span><span class="c3">, …, x</span><span class="c9 c3">n+k</span><span class="c3">: a</span><span class="c9 c3">n+k</span><span class="c3">)</span><span>.</span><span class="c3"> </span><span>It is a compile-time error if </span><span class="c3">T</span><span> is not a class or interface accessible in the current scope, optionally followed by type arguments.  It is a compile-time error if </span><span class="c3">T</span><span> includes any type variables.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>If </span><span class="c3">e</span><span> is of the form </span><span class="c5 c6">const</span><span class="c3"> T.id(a</span><span class="c9 c3">1</span><span class="c3">, .., a</span><span class="c9 c3">n</span><span class="c3">,</span><span class="c9 c3"> </span><span class="c3">x</span><span class="c9 c3">n+1</span><span class="c3">: a</span><span class="c9 c3">n+1</span><span class="c3">, …, x</span><span class="c9 c3">n+k</span><span class="c3">: a</span><span class="c9 c3">n+k</span><span class="c3">)</span><span> it is a compile-time error if </span><span class="c3">T</span><span> is not a class or interface accessible in the current scope, optionally followed by type arguments. </span><span class="c3"> </span><span>It is a compile-time error if </span><span class="c3">T.id</span><span> is not the name of a constant constructor declared by the type </span><span class="c3">T.</span><span> If </span><span class="c3">e</span><span> of the form </span><span class="c5 c6">const</span><span class="c3"> T(a</span><span class="c9 c3">1</span><span class="c3">, .., a</span><span class="c9 c3">n</span><span class="c3">,</span><span class="c9 c3"> </span><span class="c3">x</span><span class="c9 c3">n+1</span><span class="c3">: a</span><span class="c9 c3">n+1</span><span class="c3">, …, x</span><span class="c9 c3">n+k</span><span class="c3">: a</span><span class="c9 c3">n+k</span><span class="c3">) </span><span>it is a compile-time error if the type </span><span class="c3">T </span><span>does not declare a </span><span class="c1"><a class="c8" href="#id.okcph2t66jnm">constant constructor</a></span><span> with the same name as the declaration of </span><span class="c3">T.</span><span> </span></p><p class="c2 c4"><span></span></p><p class="c2"><span>In all of the above cases, it is a compile-time error if </span><span class="c3">a</span><span class="c9 c3">i</span><span class="c3">, 1 &lt; = i &lt;= n + k,</span><span> is not a compile-time constant expression.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>If </span><span class="c3">T</span><span> is a parameterized type </span><span class="c3">S&lt;U</span><span class="c9 c3">1</span><span class="c3">, ,.., U</span><span class="c9 c3">m</span><span class="c3">&gt;,</span><span> let </span><span class="c3">R = S; </span><span>It is a compile time error if </span><span class="c3">S</span><span> is not a generic type with </span><span class="c3">m</span><span> type parameters. If </span><span class="c3">T</span><span> is not a parameterized type, let </span><span class="c3">R = T.</span></p><p class="c2"><span>If </span><span class="c3">R</span><span> is an interface, let </span><span class="c3">C </span><span>be the factory class of </span><span class="c3">R</span><span>. Otherwise let </span><span class="c3">C = R.</span><span> Furthermore, if </span><span class="c3">e</span><span> is of the form </span><span class="c5 c6">const</span><span class="c3"> T.id(a</span><span class="c9 c3">1</span><span class="c3">, .., a</span><span class="c9 c3">n</span><span class="c3">,</span><span class="c9 c3"> </span><span class="c3">x</span><span class="c9 c3">n+1</span><span class="c3">: a</span><span class="c9 c3">n+1</span><span class="c3">, …, x</span><span class="c9 c3">n+k</span><span class="c3">: a</span><span class="c9 c3">n+k</span><span class="c3">)</span><span> then let  </span><span class="c3">k </span><span>be the constructor </span><span class="c3">C.id, </span><span>otherwise let </span><span class="c3">k</span><span> be the constructor </span><span class="c3">C</span><span>. Finally, if </span><span class="c3">C</span><span> is generic but </span><span class="c3">T</span><span> is not a parameterized type, then for </span><span class="c3">1 &lt;= i &lt;= m, let V</span><span class="c9 c3">i</span><span class="c3"> = </span><span class="c5 c6">Dynamic</span><span>, otherwise let </span><span class="c3">V</span><span class="c9 c3">i</span><span class="c3"> = U</span><span class="c9 c3">i</span><span class="c3">. </span><span> </span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Evaluation of </span><span class="c3">e</span><span> proceeds as follows:</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>First, if </span><span class="c3">e</span><span> is of the form </span><span class="c5 c6">const</span><span class="c3"> T.id(a</span><span class="c9 c3">1</span><span class="c3">, .., a</span><span class="c9 c3">n</span><span class="c3">,</span><span class="c9 c3"> </span><span class="c3">x</span><span class="c9 c3">n+1</span><span class="c3">: a</span><span class="c9 c3">n+1</span><span class="c3">, …, x</span><span class="c9 c3">n+k</span><span class="c3">: a</span><span class="c9 c3">n+k</span><span class="c3">)</span><span> then let </span><span class="c3">i</span><span> be the value of the expression </span><span class="c5 c6">new</span><span class="c3"> T.id(a</span><span class="c9 c3">1</span><span class="c3">, .., a</span><span class="c9 c3">n</span><span class="c3">,</span><span class="c9 c3"> </span><span class="c3">x</span><span class="c9 c3">n+1</span><span class="c3">: a</span><span class="c9 c3">n+1</span><span class="c3">, …, x</span><span class="c9 c3">n+k</span><span class="c3">: a</span><span class="c9 c3">n+k</span><span class="c3">)</span><span>. Otherwise, </span><span class="c3">e</span><span> must be of the form  </span><span class="c5 c6">const</span><span class="c3"> T(a</span><span class="c9 c3">1</span><span class="c3">, .., a</span><span class="c9 c3">n</span><span class="c3">,</span><span class="c9 c3"> </span><span class="c3">x</span><span class="c9 c3">n+1</span><span class="c3">: a</span><span class="c9 c3">n+1</span><span class="c3">, …, x</span><span class="c9 c3">n+k</span><span class="c3">: a</span><span class="c9 c3">n+k</span><span class="c3">),</span><span> in which case let </span><span class="c3">i </span><span>be the result of evaluating</span><span class="c3"> </span><span class="c5 c6">new</span><span class="c3"> T(a</span><span class="c9 c3">1</span><span class="c3">, .., a</span><span class="c9 c3">n</span><span class="c3">,</span><span class="c9 c3"> </span><span class="c3">x</span><span class="c9 c3">n+1</span><span class="c3">: a</span><span class="c9 c3">n+1</span><span class="c3">, …, x</span><span class="c9 c3">n+k</span><span class="c3">: a</span><span class="c9 c3">n+k</span><span class="c3">) </span><span class="c5">. </span><span>Then:</span></p><ol class="c25" start="1"><li class="c7 c2"><span>If during execution of the program, a constant object expression has already evaluated to an instance </span><span class="c3">j</span><span> of class </span><span class="c3">C</span><span> with type arguments </span><span class="c3">V</span><span class="c9 c3">i</span><span class="c3"> 1 &lt;= i &lt;= m,</span><span> then:</span><span class="c3"> </span></li></ol><ol class="c34" start="1"><li class="c20 c2"><span>For each instance variable </span><span class="c3">f</span><span> of </span><span class="c3">i,</span><span> let </span><span class="c3">v</span><span class="c9 c3">if</span><span> be the value of the </span><span class="c3">f</span><span> in </span><span class="c3">i,</span><span> and let </span><span class="c3">v</span><span class="c9 c3">jf</span><span> be the value of the field </span><span class="c3">f</span><span> in </span><span class="c3">j.</span><span> If  </span><span class="c3">v</span><span class="c9 c3">if</span><span class="c6">  === </span><span class="c3">v</span><span class="c9 c3">jf</span><span class="c3"> </span><span>for all fields </span><span class="c3">f</span><span> in </span><span class="c3">i, </span><span>then the value of </span><span class="c3">e </span><span>is </span><span class="c3">j, </span><span>otherwise the value of </span><span class="c3">e</span><span> is </span><span class="c3">i.</span></li></ol><ol class="c25" start="2"><li class="c2 c7"><span>Otherwise the value of </span><span class="c3">e</span><span> is </span><span class="c3">i.</span></li></ol><p class="c2"><span> </span></p><p class="c2"><span class="c11">In other words, constant objects are canonicalized.  In order to determine if an object is actually new, one has to compute it; then it can be compared to any cached instances. If an equivalent object exists in the cache, we throw away the newly created object and use the cached one. Objects are equivalent if they have identical fields and identical type arguments. Since the constructor cannot induce any side effects, the execution of the constructor is unobservable.  The constructor need only be executed once per call site, at compile-time.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>The static type of a constant object expression of either the form </span><span class="c5 c6">const</span><span class="c3"> T.id(a</span><span class="c9 c3">1</span><span class="c3">, .., a</span><span class="c9 c3">n</span><span class="c3">)</span><span> or the form </span><span class="c5 c6">const</span><span class="c3"> T(a</span><span class="c9 c3">1</span><span class="c3">, .., a</span><span class="c9 c3">n</span><span class="c3">)</span><span> is</span><span class="c3"> T.</span><span> It is a static warning if the static type of </span><span class="c3">a</span><span class="c9 c3">i</span><span class="c3">, 1 &lt;= i &lt;= n+ k </span><span>may not be assigned to the type of the corresponding formal parameter of the constructor </span><span class="c3">T.id</span><span> (respectively </span><span class="c3">T</span><span>).</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>It is a compile-time error if evaluation of a constant object results in an uncaught exception being thrown.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c11">To see how such situations might arise, consider the following examples:</span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span class="c5 c11 c6">class</span><span class="c11 c6"> A {</span></p><p class="c2"><span class="c11 c6">   </span><span class="c5 c11 c6">static final</span><span class="c11 c6"> x;</span></p><p class="c2"><span class="c11 c6">   </span><span class="c5 c11 c6">const</span><span class="c11 c6"> A(</span><span class="c5 c11 c6">var</span><span class="c11 c6"> p): p = x * 10;</span></p><p class="c2"><span class="c11 c6">}</span></p><p class="c2 c4"><span class="c11 c6"></span></p><p class="c2"><span class="c5 c11 c6">const</span><span class="c11 c6"> A(“x”); //compile-time error</span></p><p class="c2"><span class="c5 c11 c6">const</span><span class="c11 c6"> A(5); // legal</span></p><p class="c2 c4"><span class="c11 c6"></span></p><p class="c2"><span class="c5 c11 c6">class</span><span class="c11 c6"> IntPair {</span></p><p class="c2"><span class="c11 c6">   </span><span class="c5 c6 c11">const</span><span class="c11 c6"> IntPair(this.x, this.y);</span></p><p class="c2"><span class="c11 c6">   </span><span class="c5 c11 c6">final</span><span class="c11 c6"> int x;</span></p><p class="c2"><span class="c11 c6">   </span><span class="c5 c11 c6">final</span><span class="c11 c6"> int y;</span></p><p class="c2"><span class="c11 c6">   </span><span class="c5 c11 c6">operator</span><span class="c11 c6"> *(v) =&gt; new IntPair(x*v, y*v);</span></p><p class="c2"><span class="c11 c6">}</span></p><p class="c2 c4"><span class="c11 c6"></span></p><p class="c2"><span class="c5 c11 c6">const</span><span class="c11 c6"> A(</span><span class="c5 c11 c6">const</span><span class="c11 c6"> IntPair(1, 2)); // compile-time error: illegal in a subtler way</span></p><p class="c2 c4"><span class="c11 c6"></span></p><p class="c2"><span class="c11">Due to the rules governing constant constructors, evaluating the constructor A() with the argument </span><span class="c11 c6">“x”</span><span class="c11"> or the argument </span><span class="c5 c11 c6">const</span><span class="c11 c6"> IntPair(1, 2) </span><span class="c11">would cause it to throw an exception, resulting in a compile-time error.</span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><a href="#" name="id.x6lx0jb4kti5"></a><h3 class="c2"><a name="h.w9xbbkh4rog6"></a><span>Spawning an Isolate</span></h3><p class="c2 c4"><span></span></p><p class="c2"><span>Spawning an isolate is accomplished via what is syntactically an ordinary library call, invoking the instance method </span><span class="c6">spawn()</span><span> defined in class </span><span class="c6">Isolate.</span><span> However, such calls  have the  semantic effect of creating a new isolate with its own memory and thread of control.</span></p><a href="#" name="id.hu9dfddw6bhy"></a><h3 class="c2"><a name="h.b7g4ujn98rce"></a><span>Property Extraction</span></h3><p class="c2"><span>Property extraction allows for a member of an object to be concisely extracted from the object.</span></p><p class="c2"><span>If </span><span class="c3">o</span><span> is an object, and if </span><span class="c3">m</span><span> is the name of a method member of </span><span class="c3">o</span><span>, then </span><span class="c3">o.m</span><span> is defined to be equivalent to </span><span class="c3">(r</span><span class="c9 c3">1</span><span class="c3">, .., r</span><span class="c9 c3">n</span><span class="c3">, [p</span><span class="c9 c3">1</span><span class="c3"> = d</span><span class="c9 c3">1</span><span class="c3">, …, p</span><span class="c9 c3">k</span><span class="c3"> = d</span><span class="c9 c3">k</span><span class="c3">]){</span><span class="c5 c3 c6">return</span><span class="c3"> o.m(r</span><span class="c9 c3">1</span><span class="c3">, .., r</span><span class="c9 c3">n</span><span class="c3">, p</span><span class="c9 c3">1</span><span class="c3">, .., p</span><span class="c9 c3">k</span><span class="c3">);}</span><span> if </span><span class="c3">m</span><span> has required parameters </span><span class="c3">r</span><span class="c9 c3">1</span><span class="c3">, …, r</span><span class="c9 c3">n</span><span class="c3">,</span><span> and named parameters </span><span class="c3">p</span><span class="c9 c3">1</span><span class="c3"> .. p</span><span class="c9 c3">k</span><span class="c3"> </span><span>with defaults</span><span class="c3"> d</span><span class="c9 c3">1</span><span class="c3">, …, d</span><span class="c9 c3">k</span><span class="c3">. </span><span>Otherwise, if </span><span class="c3">m </span><span>is the name of a getter member of </span><span class="c3">o </span><span>(declared implicitly or explicitly) then </span><span class="c3">o.m</span><span> evaluates to the result of invoking the getter.</span></p><p class="c2"><span class="c11">Observations:</span></p><ol class="c26" start="1"><li class="c7 c2"><span class="c11">One cannot extract a getter or a setter.</span></li><li class="c7 c2"><span class="c11">One can tell whether one implemented a property via a method or via field/getter, which means that one has to plan ahead as to what construct to use, and that choice is reflected in the interface of the class. </span><span class="c19"> </span></li></ol><p class="c2 c4"><span></span></p><a href="#" name="id.o7xycf4osas8"></a><h3 class="c2"><a name="h.y92yhnm0wxy7"></a><span>Function Invocation</span></h3><p class="c2"><span>Function invocation occurs in the following cases: when a </span><span class="c1"><a class="c8" href="#kix.5k4ge149hokr">function expression is invoked,</a></span><span> when a </span><span class="c1"><a class="c8" href="#kix.uf8pv9cr3nu2">method is invoked</a></span><span> or when a constructor is invoked (either via </span><span class="c1"><a class="c8" href="#id.hvkbnlui8uvu">instance creation</a></span><span> , </span><span class="c1"><a class="c8" href="#id.joo06zfmou7z">constructor redirection</a></span><span> or super initialization). The various kinds of function invocation differ as to how the function to be invoked, </span><span class="c3">f,</span><span>  is determined as well as whether </span><span class="c5 c6">this</span><span> is bound. Once </span><span class="c3">f</span><span> has been determined, the formal parameters of </span><span class="c3">f </span><span>are bound to the corresponding actual arguments. The body of </span><span class="c3">f</span><span> is then executed with the aforementioned bindings. Execution of the body terminates when the first of the following occurs;</span></p><ol class="c25" start="1"><li class="c7 c2"><span>An uncaught exception is thrown </span></li><li class="c7 c2"><span>A return statement immediately nested in the body of </span><span class="c3">f </span><span>is executed.</span></li><li class="c7 c2"><span>The last statement of the body completes execution. </span></li></ol><p class="c2 c4"><span class="c3"><br></span></p><a href="#" name="id.ildrdt8gs2av"></a><h4 class="c2"><a name="h.3tizygdkqnej"></a><span>Actual Argument List Evaluation</span></h4><p class="c2"><span>Function invocation involve evaluation of the list of actual arguments to the function and binding of the results to the function’s formal parameters.</span></p><p class="c2 c4"><span></span></p><a href="#" name="kix.xl2ewwstkqba"></a><p class="c2"><span class="c5 c3">arguments:</span><span class="c3"><br>      &#39;(&#39; </span><span class="c1 c3"><a class="c8" href="#id.yhq3xin4zid1">argumentList</a></span><span class="c3">? &#39;)&#39;<br>    ;<br><br></span><a href="#" name="kix.ych6gak590r1"></a><span class="c5 c3">argumentList:</span><span class="c3"><br>      </span><span class="c1 c3"><a class="c8" href="#id.7mx0z515yx51">namedArgument</a></span><span class="c3"> (&#39;,&#39; </span><span class="c1 c3"><a class="c8" href="#id.7mx0z515yx51">namedArgument</a></span><span class="c3">)*<br>    | </span><span class="c0"><a class="c8" href="#id.8a2tqk43n0f2">expressionList</a></span><span class="c3"> (&#39;,&#39; </span><span class="c1 c3"><a class="c8" href="#id.7mx0z515yx51">namedArgument</a></span><span class="c3">)*<br>    ;<br><br></span><a href="#" name="kix.7a3j6nl17wrf"></a><span class="c5 c3">namedArgument:</span><span class="c3"><br>      label </span><span class="c0"><a class="c8" href="#id.1u3vxuwrz6py">expression</a></span><span class="c3"><br>    ;<br></span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Evaluation of an actual argument list of the form (</span><span class="c3">a</span><span class="c9 c3">1</span><span class="c3"> .. a</span><span class="c9 c3">m</span><span class="c3">, q</span><span class="c9 c3">1</span><span class="c3">: a</span><span class="c9 c3">m+1</span><span class="c3">, …, q</span><span class="c9 c3">l</span><span class="c3">: a</span><span class="c9 c3">m+l</span><span>) proceeds as follows:</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>The arguments </span><span class="c3">a</span><span class="c9 c3">1</span><span class="c3">, …, a</span><span class="c9 c3">m+l</span><span class="c3"> </span><span>are evaluated in the order they appear in the program, yielding objects </span><span class="c3">o</span><span class="c9 c3">1</span><span class="c3"> .. o</span><span class="c9 c3">m+l</span><span>.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c11">Simply stated, an argument list consisting of </span><span class="c11 c3">m</span><span class="c11"> positional arguments and </span><span class="c11 c3">l</span><span class="c11"> named arguments is evaluated from left to right. </span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><a href="#" name="id.p7pe6x2fs02j"></a><h4 class="c2"><a name="h.edxvczd1cw0f"></a><span>Binding Actuals to Formals</span></h4><p class="c2 c4"><span></span></p><p class="c2"><span>Let </span><span class="c3">f</span><span> be the function, let </span><span class="c3">p</span><span class="c9 c3">1</span><span class="c3">, …, p</span><span class="c9 c3">n</span><span> be the positional parameters of </span><span class="c3">f</span><span> and let </span><span class="c3">p</span><span class="c9 c3">n+1</span><span class="c3">, …, p</span><span class="c9 c3">n+k</span><span> be the named parameters declared by </span><span class="c3">f.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>An evaluated actual argument list </span><span class="c3">(o</span><span class="c9 c3">1</span><span class="c3">, …, o</span><span class="c9 c3">m+l</span><span class="c3">)</span><span> derived from an actual argument list of the form (</span><span class="c3">a</span><span class="c9 c3">1</span><span class="c3"> .. a</span><span class="c9 c3">m</span><span class="c3">, q</span><span class="c9 c3">1</span><span class="c3">: a</span><span class="c9 c3">m+1</span><span class="c3">, …, q</span><span class="c9 c3">l</span><span class="c3">: a</span><span class="c9 c3">m+l</span><span>) is bound to the formal parameters of </span><span class="c3">f</span><span> as follows:</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span class="c11">Again, we have an argument list consisting of </span><span class="c11 c3">m</span><span class="c11"> positional arguments and </span><span class="c11 c3">l </span><span class="c11">named arguments. We have a function with </span><span class="c11 c3">n</span><span class="c11"> required parameters and </span><span class="c11 c3">k</span><span class="c11"> named parameters. The number of positional arguments must be at least as large as the number of required parameters. All named arguments must have a corresponding named parameter. You may not provide the same parameter as both a positional and a named argument. If an optional parameter has no corresponding argument, it gets its default value. In checked mode, all arguments must belong to subtypes of the type of their corresponding formal.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>If  </span><span class="c3">m &lt; n, </span><span>a run-time error occurs. Furthermore, each </span><span class="c3">q</span><span class="c9 c3">i</span><span class="c3">, 1 &lt;= i &lt;= l,</span><span>  must be a member of the set {</span><span class="c3">p</span><span class="c9 c3">m+1</span><span class="c3">, …, p</span><span class="c9 c3">n+k</span><span>}</span><span> or a </span><span>run time error</span><span> occurs. Then </span><span class="c3">p</span><span class="c9 c3">i</span><span> is bound to the value of </span><span class="c3">o</span><span class="c9 c3">i</span><span>, </span><span class="c3">1 &lt;= i &lt;= m,</span><span> and</span><span class="c3"> q</span><span class="c9 c3">j</span><span> is bound to the value of </span><span class="c3">o</span><span class="c9 c3">m+j</span><span>, </span><span class="c3">1 &lt;= j &lt;= l</span><span>. All remaining formal parameters of </span><span class="c3">f</span><span> are bound to their default values. </span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c11">All of these remaining parameters are necessarily optional and thus have default values.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>In checked mode, it is a dynamic type error if </span><span class="c3">o</span><span class="c9 c3">i</span><span> </span><span>is not </span><span class="c5 c6">null</span><span> and the </span><span class="c1"><a class="c8" href="#id.93yudg3nk9o1">actual type</a></span><span> of </span><span class="c3">p</span><span class="c9 c3">i</span><span> is not a supertype of the type of </span><span class="c3">o</span><span class="c9 c3">i</span><span class="c3">, 1 &lt;= i &lt;= m</span><span>. It is a dynamic type error if, in checked mode, </span><span class="c3">o</span><span class="c9 c3">m+j</span><span> </span><span>is not </span><span class="c5 c6">null</span><span> and the </span><span class="c1"><a class="c8" href="#id.93yudg3nk9o1">actual type</a></span><span> of </span><span class="c3">q</span><span class="c9 c3">j</span><span> is not a supertype of the type of </span><span class="c3">o</span><span class="c9 c3">m+j</span><span>, </span><span class="c3">1 &lt;= j &lt;= l</span><span>. </span></p><p class="c2 c4"><span></span></p><p class="c2"><span>It is a compile-time error if </span><span class="c3">q</span><span class="c9 c3">i</span><span class="c3"> = q</span><span class="c9 c3">j</span><span class="c3"> </span><span>for any </span><span class="c3">i != j.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Let </span><span class="c3">T</span><span class="c9 c3">i</span><span> be the static type of </span><span class="c3">a</span><span class="c9 c3">i</span><span>, let </span><span class="c3">S</span><span class="c9 c3">i</span><span> be the type of </span><span class="c3">p</span><span class="c9 c3">i</span><span>, </span><span class="c3">1 &lt;= i &lt;= n+k</span><span> and let </span><span class="c3">S</span><span class="c9 c3">q</span><span> be the type of the named parameter </span><span class="c3">q</span><span> of </span><span class="c3">f</span><span>.  It is a static warning if </span><span class="c3">T</span><span class="c9 c3">j</span><span> may not be assigned to </span><span class="c3">S</span><span class="c9 c3">j</span><span>, </span><span class="c3">1 &lt;= j &lt;= m</span><span>.  It is a static warning if </span><span class="c3">m &lt; n</span><span> or if </span><span class="c3">m &gt; n + k</span><span>. Furthermore, each </span><span class="c3">q</span><span class="c9 c3">i</span><span class="c3">, 1 &lt;= i &lt;= l,</span><span>  must be a member of the set {</span><span class="c3">p</span><span class="c9 c3">m+1</span><span class="c3">, …, p</span><span class="c9 c3">n+k</span><span>}</span><span>  or a static warning occurs.  It is a static warning if </span><span class="c3">T</span><span class="c9 c3">j</span><span>  may not be assigned to </span><span class="c3">S</span><span class="c9 c3">r</span><span class="c3">,</span><span> where </span><span class="c3">r = j-m, m+1 &lt;= j &lt;= m+l.</span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><a href="#" name="id.umipgzep5jdf"></a><h4 class="c2"><a name="h.o9n2pv4hceh1"></a><span>Unqualified Invocation</span></h4><p class="c2 c4"><span></span></p><p class="c2"><span>An unqualified function invocation </span><span class="c3">i</span><span> has the form </span><span class="c3">id(a</span><span class="c9 c3">1</span><span class="c3">, …, a</span><span class="c9 c3">n</span><span class="c3">, </span><span class="c3">x</span><span class="c9 c3">n+1</span><span class="c3">: a</span><span class="c9 c3">n+1</span><span class="c3">, …, x</span><span class="c9 c3">n+k</span><span class="c3">: a</span><span class="c9 c3">n+k</span><span class="c3">),</span><span> where </span><span class="c3">id </span><span>is an identifier.</span><span class="c3"> </span><span> </span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c19">What about library prefixes?</span></p><p class="c2 c4"><span class="c19"></span></p><p class="c2"><span>If there exists a lexically visible declaration named </span><span class="c3">id,</span><span> let </span><span class="c3">f</span><span class="c9 c3">id</span><span> be the innermost such declaration. Then:</span></p><ol class="c25" start="1"><li class="c7 c2"><span> If </span><span class="c3">f</span><span class="c9 c3">id</span><span> is a local function, a library function, a library or static getter or a variable then </span><span class="c3">i</span><span> is interpreted as a </span><span class="c1"><a class="c8" href="#kix.5k4ge149hokr">function expression invocation</a></span><span class="c3">.</span></li><li class="c7 c2"><span>Otherwise, If </span><span class="c3">f</span><span class="c9 c3">id</span><span> is a static method of the enclosing class </span><span class="c3">C, i </span><span>is equivalent to the static method invocation </span><span class="c3">C.id(a</span><span class="c9 c3">1</span><span class="c3">, …, a</span><span class="c9 c3">n</span><span class="c3">, x</span><span class="c9 c3">n+1</span><span class="c3">: a</span><span class="c9 c3">n+1</span><span class="c3">, …, x</span><span class="c9 c3">n+k</span><span class="c3">: a</span><span class="c9 c3">n+k</span><span class="c3">).</span></li></ol><p class="c2 c4"><span></span></p><p class="c2"><span>Otherwise, </span><span class="c3">i </span><span>is equivalent to the ordinary method invocation </span><span class="c3">this.id(a</span><span class="c9 c3">1</span><span class="c3">, …, a</span><span class="c9 c3">n</span><span class="c3">, x</span><span class="c9 c3">n+1</span><span class="c3">: </span><span class="c3">a</span><span class="c9 c3">n+1</span><span class="c3">, …, x</span><span class="c9 c3">n+k</span><span class="c3">: a</span><span class="c9 c3">n+k</span><span class="c3">). </span></p><p class="c2 c4"><span class="c3"></span></p><a href="#" name="kix.5k4ge149hokr"></a><h4 class="c2"><a name="h.5l8tud6ne77w"></a><span>Function Expression Invocation</span></h4><p class="c2 c4"><span></span></p><p class="c2"><span>A function expression invocation </span><span class="c3">i</span><span> has the form </span><span class="c3">e</span><span class="c9 c3">f</span><span class="c3">(a</span><span class="c9 c3">1</span><span class="c3">, …, a</span><span class="c9 c3">n</span><span class="c3">, x</span><span class="c9 c3">n+1</span><span class="c3">: a</span><span class="c9 c3">n+1</span><span class="c3">, …, x</span><span class="c9 c3">n+k</span><span class="c3">: a</span><span class="c9 c3">n+k</span><span class="c3">),</span><span> where </span><span class="c3">e</span><span class="c9 c3">f</span><span class="c3"> </span><span>is an expression. If </span><span class="c3">e</span><span class="c9 c3">f </span><span>is an identifier </span><span class="c3">id,</span><span> then </span><span class="c3">id</span><span> must necessarily denote a local function, a library function, a library or static getter or a variable as described </span><span class="c1"><a class="c8" href="#id.umipgzep5jdf">above</a></span><span>, or </span><span class="c3">i</span><span> is not considered a function expression invocation. If </span><span class="c3">e</span><span class="c9 c3">f </span><span>is a property access expression, then </span><span class="c3">i</span><span> is treated as an </span><span class="c1"><a class="c8" href="#kix.dveayw720vs7">ordinary method invocation</a></span><span>. Otherwise:</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>A function expression invocation </span><span class="c3">i</span><span> of the form  </span><span class="c3">e</span><span class="c18 c3">f</span><span class="c3">(a</span><span class="c18 c3">1</span><span class="c3">, …, a</span><span class="c18 c3">n</span><span class="c3">, x</span><span class="c18 c3">n+1</span><span class="c3">: a</span><span class="c18 c3">n+1</span><span class="c3">, …, x</span><span class="c18 c3">n+k</span><span class="c3">: a</span><span class="c18 c3">n+k</span><span class="c3">)</span><span> is equivalent to the ordinary method invocation </span><span class="c3">e</span><span class="c18 c3">f</span><span class="c3">.call(a</span><span class="c18 c3">1</span><span class="c3">, …, a</span><span class="c18 c3">n</span><span class="c3">, x</span><span class="c18 c3">n+1</span><span class="c3">: a</span><span class="c18 c3">n+1</span><span class="c3">, …, x</span><span class="c18 c3">n+k</span><span class="c3">: a</span><span class="c18 c3">n+k</span><span class="c3">)</span><span>.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>It is a static type warning if the static type </span><span class="c3">F</span><span> of </span><span class="c3">e</span><span class="c9 c3">f</span><span> may not be assigned to a function type.  If </span><span class="c3">F</span><span> is not a function type, the static type of </span><span class="c3">i</span><span> is </span><span class="c5 c6">Dynamic</span><span>. Otherwise the static type of </span><span class="c3">i</span><span> is the declared return type of </span><span class="c3">F. </span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span class="c3"></span></p><a href="#" name="kix.1bfikjk2e9bd"></a><h3 class="c2"><a name="h.mwjqhj0r8mr"></a><span>Method Invocation</span></h3><p class="c2"><span>Method invocation can take several forms as specified below. </span></p><a href="#" name="kix.dveayw720vs7"></a><h4 class="c2"><a name="h.bq7ggoshcofg"></a><span>Ordinary Invocation</span></h4><p class="c2"><span>An ordinary method invocation </span><span class="c3">i</span><span> has the form </span><span class="c3">o.m(a</span><span class="c9 c3">1</span><span class="c3">, …, a</span><span class="c9 c3">n</span><span class="c3">, x</span><span class="c9 c3">n+1</span><span class="c3">: a</span><span class="c9 c3">n+1</span><span class="c3">, …, x</span><span class="c9 c3">n+k</span><span class="c3">: a</span><span class="c9 c3">n+k</span><span class="c3">). </span><span> </span></p><p class="c2 c4"><span></span></p><p class="c2"><span>The result of</span><span class="c3"> looking up a method m in object o with respect to library L</span><span> is the result of looking up method </span><span class="c3">m</span><span> in class </span><span class="c3">C</span><span> with respect to library </span><span class="c3">L,</span><span> where </span><span class="c3">C</span><span> is the class of </span><span class="c3">o.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>The result of </span><span class="c3">looking up method m in class C with respect to library L</span><span> is:</span></p><p class="c2 c4"><span></span></p><ol class="c25" start="1"><li class="c7 c2"><span>If </span><span class="c3">C</span><span> declares an instance method named </span><span class="c3">m</span><span> that is accessible to </span><span class="c3">L,</span><span>  then that method is the result of the lookup. Otherwise, if </span><span class="c3">C</span><span> has a superclass </span><span class="c3">S,</span><span> then the result of the lookup is the result of looking up method </span><span class="c3">m</span><span> in </span><span class="c3">S </span><span>with respect to </span><span class="c3">L. </span><span>Otherwise, we say that the lookup has failed.</span></li></ol><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Evaluation of an ordinary method invocation </span><span class="c3">i</span><span> of the form </span><span class="c3">o.m(a</span><span class="c9 c3">1</span><span class="c3">, …, a</span><span class="c9 c3">n</span><span class="c3">, x</span><span class="c9 c3">n+1</span><span class="c3">: a</span><span class="c9 c3">n+1</span><span class="c3">, …, x</span><span class="c9 c3">n+k</span><span class="c3">: a</span><span class="c9 c3">n+k</span><span class="c3">)</span><span> proceeds as follows:</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>First, the expression </span><span class="c3">o</span><span> is evaluated </span><span>to a value </span><span class="c3">v</span><span class="c9 c3">o</span><span class="c3">.</span><span> Next, the argument list </span><span class="c3">(a</span><span class="c9 c3">1</span><span class="c3">, …, a</span><span class="c9 c3">n</span><span class="c3">, x</span><span class="c9 c3">n+1</span><span class="c3">: a</span><span class="c9 c3">n+1</span><span class="c3">, …, x</span><span class="c9 c3">n+k</span><span class="c3">: a</span><span class="c9 c3">n+k</span><span class="c3">)</span><span> is evaluated yielding actual objects </span><span class="c3">o</span><span class="c9 c3">1</span><span class="c3">, …, o</span><span class="c9 c3">n+k</span><span>. Let </span><span class="c3">f </span><span>be the result of looking up method </span><span class="c3"> m</span><span> in </span><span class="c3">v</span><span class="c9 c3">o</span><span>  with respect to the current library </span><span class="c3">L.</span><span> If the method lookup succeeded,</span><span class="c3"> </span><span>the body of </span><span class="c3">f</span><span> is executed with respect to the bindings that resulted from the evaluation of the argument list, and with </span><span class="c5 c6">this</span><span> bound to </span><span class="c3">v</span><span class="c9 c3">o</span><span class="c3">. </span><span>The value of</span><span class="c3"> i </span><span>is the value returned after </span><span class="c3">f</span><span> is executed.</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span>If the method lookup has failed, then let </span><span class="c3">g </span><span>be the result of looking up getter </span><span class="c3">m</span><span> in </span><span class="c3">v</span><span class="c18 c3">o</span><span> with respect to </span><span class="c3">L.</span><span> If the getter lookup succeeded, let </span><span class="c3">v</span><span class="c18 c3">g</span><span> be the value of the getter invocation </span><span class="c3">o.m.</span></p><p class="c2"><span>Then the value of</span><span class="c3"> i </span><span>is the value of the method invocation </span><span class="c3">v</span><span class="c18 c3">g</span><span>.</span><span class="c5 c6">call</span><span class="c6">(</span><span class="c3">a</span><span class="c9 c3">1</span><span class="c3">, …, a</span><span class="c9 c3">n</span><span class="c3">, x</span><span class="c9 c3">n+1</span><span class="c3">: a</span><span class="c9 c3">n+1</span><span class="c3">, …, x</span><span class="c9 c3">n+k</span><span class="c3">: a</span><span class="c9 c3">n+k</span><span class="c6">)</span><span>. </span></p><p class="c2 c4"><span></span></p><p class="c2"><span>If getter lookup has also failed, then a new instance </span><span class="c3">im </span><span> of the predefined interface  </span><span class="c6">InvocationMirror</span><span>  is created </span><span>by calling its</span><span> factory constructor</span><span> with arguments </span><span class="c6">‘m’</span><span>,  </span><span class="c5 c6">this</span><span class="c6">,</span><span> </span><span class="c6">[</span><span class="c3">o</span><span class="c9 c3">1</span><span class="c3">, …, o</span><span class="c9 c3">n</span><span class="c6">] </span><span>and</span><span class="c6"> {</span><span class="c3">x</span><span class="c9 c3">n+1</span><span class="c3 c6">:</span><span class="c3">o</span><span class="c9 c3">n+1</span><span class="c3">, …, x</span><span class="c9 c3">n+k</span><span class="c3"> :</span><span class="c9 c3"> </span><span class="c3">o</span><span class="c9 c3">n+k</span><span class="c6">}. Then</span><span> </span><span>the method </span><span class="c6">noSuchMethod() </span><span>is looked up in </span><span class="c3 c6">o</span><span> and invoked with argument </span><span class="c3">im</span><span class="c6">,</span><span> and the result of this invocation is the result of evaluating </span><span class="c3">i</span><span>.</span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span class="c11">Notice that the wording carefully avoids re-evaluating the receiver </span><span class="c11 c3">o</span><span class="c11"> and the arguments </span><span class="c11 c3">a</span><span class="c9 c11 c3">i</span><span class="c11">. </span></p><p class="c2 c4"><span class="c19"></span></p><p class="c2"><span>Let </span><span class="c3">T</span><span> be the  static type of </span><span class="c3">o.</span><span> It is a static type warning if </span><span class="c3">T</span><span> does not have an </span><span class="c1"><a class="c8" href="#id.zeletzevxf8t">accessible</a></span><span>  instance member named </span><span class="c3">m.</span><span class="c19"> </span><span>If </span><span class="c3">T.m</span><span> exists, it is a static warning if the type </span><span class="c3">F</span><span> of </span><span class="c3">T.m</span><span> may not be assigned to a function type</span><span class="c3">.</span><span> If </span><span class="c3">T.m</span><span> does not exist, or if </span><span class="c3">F</span><span> is not a function type, the static type of </span><span class="c3">i</span><span> is </span><span class="c5 c6">Dynamic</span><span>. Otherwise the static type of </span><span class="c3">i</span><span> is the declared return type of </span><span class="c3">F. </span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2 c4"><span class="c3"></span></p><a href="#" name="id.as8nompbkrrt"></a><h4 class="c2"><a name="h.30hsq2v14fk2"></a><span>Cascaded Invocations</span></h4><p class="c2 c4"><span></span></p><p class="c2"><span class="c11">Cascades are not yet implemented; the precise details are therefore even more subject to change than usual.</span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span>A </span><span class="c3">cascaded method invocation</span><span> has the form </span><span class="c3">e..suffix </span><span>where </span><span class="c3">suffix</span><span> is a sequence of operator, method, getter or setter invocations.</span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><a href="#" name="kix.qgl5b37992c5"></a><p class="c2"><span class="c5 c3">cascadeSection:<br></span><span class="c3">     &#39;..&#39;  (assignableSelector </span><span class="c1 c3"><a class="c8" href="#kix.xl2ewwstkqba">arguments</a></span><span class="c3">*)+ (</span><span class="c0"><a class="c8" href="#id.gs625gfxuh9m">assignmentOperator</a></span><span class="c3"> </span><span class="c0"><a class="c8" href="#id.1u3vxuwrz6py">expression</a></span><span class="c3">)?<br>    ;</span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><p class="c2"><span>A cascaded method invocation expression of the form </span><span class="c3">e..suffix</span><span> is equivalent to the expression </span><span class="c3 c6">(t){t.suffix; </span><span class="c5 c3 c6">return</span><span class="c3 c6"> t;}(e).</span></p><p class="c2 c4"><span class="c19"></span></p><p class="c2 c4"><span class="c19"></span></p><p class="c2 c4"><span class="c19"></span></p><a href="#" name="id.fe2sq6esvhvp"></a><h4 class="c2"><a name="h.jwevbcchdb5f"></a><span>Static Invocation</span></h4><p class="c2 c4"><span></span></p><p class="c2"><span>A static method invocation </span><span class="c3">i</span><span> has the form </span><span class="c3">C.m(a</span><span class="c9 c3">1</span><span class="c3">, …, a</span><span class="c9 c3">n</span><span class="c3">, x</span><span class="c9 c3">n+1</span><span class="c3">: a</span><span class="c9 c3">n+1</span><span class="c3">, …, x</span><span class="c9 c3">n+k</span><span class="c3">: a</span><span class="c9 c3">n+k</span><span class="c3">). </span><span> It is a compile-time error if </span><span class="c3">C</span><span> does not denote a class in the current scope. It is a compile-time error if </span><span class="c3">C</span><span> does not declare a </span><span>static method or getter </span><span class="c3">m</span><span class="c3">.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c11">Note the requirement that C </span><span class="c5 c11">declare</span><span class="c11"> the method. This means that static methods declared in superclasses of </span><span class="c11 c3">C</span><span class="c11"> cannot be invoked via </span><span class="c11 c3">C.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Evaluation of </span><span class="c3">i</span><span> proceeds as follows:</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>First, if the member </span><span class="c3">m</span><span> declared by </span><span class="c3">C</span><span> is a getter, then </span><span class="c3">i</span><span> is equivalent to the expression </span><span class="c3">C.m.call(a</span><span class="c18 c3">1</span><span class="c3">, …, a</span><span class="c3 c18">n</span><span class="c3">, x</span><span class="c18 c3">n+1</span><span class="c3">: a</span><span class="c18 c3">n+1</span><span class="c3">, …, x</span><span class="c18 c3">n+k</span><span class="c3">: a</span><span class="c18 c3">n+k</span><span class="c3">)</span><span>.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Otherwise, let </span><span class="c3">f</span><span> be the method </span><span class="c3">m</span><span> declared in class </span><span class="c3">C. </span><span>Next, the argument list </span><span class="c3">(a</span><span class="c9 c3">1</span><span class="c3">, …, a</span><span class="c9 c3">n</span><span class="c3">, x</span><span class="c9 c3">n+1</span><span class="c3">: a</span><span class="c9 c3">n+1</span><span class="c3">, …, x</span><span class="c9 c3">n+k</span><span class="c3">: a</span><span class="c9 c3">n+k</span><span class="c3">)</span><span> is evaluated.</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span>The body of </span><span class="c3">f</span><span> is then executed with respect to the bindings that resulted from the evaluation of the argument list. The value of</span><span class="c3"> i </span><span>is the value returned after the body of </span><span class="c3">f</span><span> is executed.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>It is a static type warning if the type </span><span class="c3">F</span><span> of </span><span class="c3">C.m</span><span> may not be assigned to a function type.  If </span><span class="c3">F</span><span> is not a function type, the static type of </span><span class="c3">i</span><span> is </span><span class="c5 c6">Dynamic</span><span>.</span><span> Otherwise the static type of </span><span class="c3">i</span><span> is the declared return type of </span><span class="c3">F. </span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><a href="#" name="id.mmuk7ayxh6r9"></a><h4 class="c2"><a name="h.x8qjjxmvmrg9"></a><span>Super Invocation</span></h4><p class="c2 c4"><span></span></p><p class="c2"><span>A super method invocation has the form </span><span class="c5 c3 c6">super</span><span class="c3">.m(a</span><span class="c9 c3">1</span><span class="c3">, …, a</span><span class="c9 c3">n</span><span class="c3">, x</span><span class="c9 c3">n+1</span><span class="c3">: a</span><span class="c9 c3">n+1</span><span class="c3">, …, x</span><span class="c9 c3">n+k</span><span class="c3">: a</span><span class="c9 c3">n+k</span><span class="c3">).</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span>Evaluation of </span><span>a</span><span> super method invocation </span><span class="c3">i</span><span> of the form </span><span class="c5 c3 c6">super</span><span class="c3">.m(a</span><span class="c9 c3">1</span><span class="c3">, …, a</span><span class="c9 c3">n</span><span class="c3">, x</span><span class="c9 c3">n+1</span><span class="c3">: a</span><span class="c9 c3">n+1</span><span class="c3">, …, x</span><span class="c9 c3">n+k</span><span class="c3">: a</span><span class="c9 c3">n+k</span><span class="c3">)</span><span> proceeds as follows:</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>First, the argument list </span><span class="c3">(a</span><span class="c9 c3">1</span><span class="c3">, …, a</span><span class="c9 c3">n</span><span class="c3">, x</span><span class="c9 c3">n+1</span><span class="c3">:</span><span class="c3"> a</span><span class="c9 c3">n+1</span><span class="c3">, …, x</span><span class="c9 c3">n+k</span><span class="c3">: a</span><span class="c9 c3">n+k</span><span class="c3">)</span><span> is evaluated yielding actual objects </span><span class="c3">o</span><span class="c9 c3">1</span><span class="c3">, …, o</span><span class="c9 c3">n+k</span><span class="c3">.</span><span> Let </span><span class="c3">S</span><span> be the superclass of the class of </span><span class="c5 c3 c6">this</span><span> and let </span><span class="c3">f </span><span>be the result of looking up method </span><span class="c3">m</span><span> in </span><span class="c3">S</span><span> with respect to the current library </span><span class="c3">L.</span><span> If the method lookup succeeded,</span><span class="c3"> </span><span>the body of </span><span class="c3">f</span><span> is executed with respect to the bindings that resulted from the evaluation of the argument list, and with </span><span class="c5 c6">this</span><span> bound to the current value of </span><span class="c5 c6">this</span><span>. The value of</span><span class="c3"> i </span><span>is the value returned after </span><span class="c3">f</span><span> is executed.</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span>If the method lookup has failed, then let </span><span class="c3">g </span><span>be the result of looking up getter </span><span class="c3">m</span><span> in </span><span class="c3">v</span><span class="c18 c3">o</span><span> with respect to </span><span class="c3">L.</span><span> If the getter lookup succeeded, let </span><span class="c3">v</span><span class="c18 c3">g</span><span> be the value of the getter invocation </span><span class="c5">super</span><span class="c3">.m. </span><span>Then the value of</span><span class="c3"> i </span><span>is the value of the method invocation </span><span class="c3">v</span><span class="c18 c3">g</span><span>.</span><span class="c5 c6">call</span><span class="c6">(</span><span class="c3">a</span><span class="c9 c3">1</span><span class="c3">, …, a</span><span class="c9 c3">n</span><span class="c3">, x</span><span class="c9 c3">n+1</span><span class="c3">: a</span><span class="c9 c3">n+1</span><span class="c3">, …, x</span><span class="c9 c3">n+k</span><span class="c3">: a</span><span class="c9 c3">n+k</span><span class="c6">)</span><span>.</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span>If the getter lookup has also failed,  then a new instance </span><span class="c3">im </span><span> of the predefined interface  </span><span class="c6">InvocationMirror</span><span>  is created  </span><span>by calling its factory</span><span> constructor with arguments </span><span class="c6">‘m’</span><span>,  </span><span class="c5 c6">this</span><span class="c6">,</span><span> </span><span class="c6">[</span><span class="c3">e</span><span class="c9 c3">1</span><span class="c3">, …, e</span><span class="c9 c3">n</span><span class="c6">] </span><span>and</span><span class="c6"> {</span><span class="c3">x</span><span class="c9 c3">n+1</span><span class="c3 c6">:</span><span class="c3">e</span><span class="c9 c3">n+1</span><span class="c3">, …, x</span><span class="c9 c3">n+k</span><span class="c3"> :</span><span class="c9 c3"> </span><span class="c3">e</span><span class="c9 c3">n+k</span><span class="c6">}.</span><span> Then</span><span> the method </span><span class="c6">noSuchMethod() </span><span>is looked up in </span><span class="c3 c6">S</span><span> and invoked with argument </span><span class="c3">im</span><span class="c6">,</span><span> and the result of this invocation is the result of evaluating </span><span class="c3">i</span><span>.</span></p><p class="c2 c4"><span class="c19"></span></p><p class="c2"><span>It is a compile-time error if a super method invocation occurs in a top-level function or variable initializer, in class </span><span class="c6">Object,</span><span> in a factory constructor, </span><span>or in a static method or variable initializer.</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span>It is a static type warning if </span><span class="c3">S</span><span> does not have an </span><span class="c1"><a class="c8" href="#id.zeletzevxf8t">accessible</a></span><span> instance member named </span><span class="c3">m. </span><span>If </span><span class="c3">S.m</span><span> exists, it is a static warning if </span><span>the type </span><span class="c3">F</span><span> of </span><span class="c3">S.m</span><span> may not be assigned to a function type</span><span class="c3">.</span><span> If </span><span class="c3">S.m</span><span> does not exist, or if </span><span class="c3">F</span><span> is not a function type, the static type of </span><span class="c3">i</span><span> is </span><span class="c5 c6">Dynamic</span><span>. Otherwise the static type of </span><span class="c3">i</span><span> is the declared return type of </span><span class="c3">F. </span></p><p class="c2 c4"><span></span></p><a href="#" name="id.3drgiqgu864y"></a><h4 class="c2"><a name="h.4d637niex9m0"></a><span>Sending Messages</span></h4><p class="c2 c4"><span></span></p><p class="c2"><span>Messages are the sole means of communication among isolates. Messages are sent by invoking specific  methods in the Dart libraries; there is no specific syntax for sending a message. </span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c11">In other words, the methods supporting sending messages embody primitives of Dart that are not accessible to ordinary code, much like the methods that spawn isolates.</span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><a href="#" name="id.lharm2td3qkb"></a><h3 class="c2"><a name="h.qnxio27bibb"></a><span>Getter Invocation</span></h3><p class="c2 c4"><span></span></p><p class="c2"><span>A getter invocation provides access to the value of a property.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>The result of</span><span class="c3"> looking up a </span><span class="c1 c3"><a class="c8" href="#kix.wlocpej6rvqa">getter</a></span><span class="c3"> (respectively </span><span class="c1 c3"><a class="c8" href="#kix.i4xvz9z9edz">setter</a></span><span class="c3">) m in object o</span><span> </span><span class="c3">with respect to library L</span><span> is the result of looking up getter (respectively setter) </span><span class="c3">m</span><span> in class </span><span class="c3">C</span><span> with respect to </span><span class="c3">L,</span><span> where </span><span class="c3">C</span><span> is the class of </span><span class="c3">o.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>The result of </span><span class="c3">looking up getter (respectively setter) m in class C with respect to library L</span><span> is:</span></p><p class="c2 c4"><span></span></p><ol class="c25" start="2"><li class="c7 c2"><span>If </span><span class="c3">C</span><span> declares an instance  getter (respectively setter) named </span><span class="c3">m</span><span> that is accessible to </span><span class="c3">L,</span><span>  then that getter (respectively setter) is the result of the lookup. Otherwise, if </span><span class="c3">C</span><span> has a superclass </span><span class="c3">S,</span><span> then the result of the lookup is the result of looking up getter (respectively setter) </span><span class="c3">m</span><span> in </span><span class="c3">S</span><span> with respect to </span><span class="c3">L. </span><span>Otherwise, we say that the lookup has failed.</span></li></ol><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Evaluation of a getter invocation </span><span class="c3">i</span><span> of the form </span><span class="c3">e.m</span><span> proceeds as follows:</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>First, the expression </span><span class="c3">e</span><span> is evaluated to an object </span><span class="c3">o.</span><span> Then, the getter function </span><span class="c3">m</span><span> is looked up in </span><span class="c3">o </span><span>with respect to the current library,</span><span> and its body is executed with </span><span class="c5 c6">this</span><span> bound to </span><span class="c3">o</span><span>.  The value of the getter invocation expression is the result returned by the call to the getter function. </span></p><p class="c2 c4"><span></span></p><p class="c2"><span>If the getter lookup has failed, then a new instance </span><span class="c3">im </span><span> of the predefined interface  </span><span class="c6">InvocationMirror</span><span>  is created</span><span>, such that :</span></p><ol class="c25" start="1"><li class="c7 c2"><span class="c3 c6">im</span><span class="c6">.isGetter</span><span> evaluates to </span><span class="c5 c6">true</span><span>.</span></li><li class="c7 c2"><span class="c3 c6">im</span><span class="c6">.memberName</span><span> evaluates to ‘</span><span class="c6">m’</span><span>.</span></li><li class="c7 c2"><span class="c3 c6">im</span><span class="c6">.arguments.positionalArguments</span><span> evaluates to </span><span class="c6">[]</span><span>.</span></li><li class="c7 c2"><span class="c3 c6">im</span><span class="c6">.arguments.namedArguments</span><span> evaluates to </span><span class="c6">{}</span><span>.</span></li></ol><p class="c2 c4"><span></span></p><p class="c2"><span>Then</span><span> the method </span><span class="c6">noSuchMethod() </span><span>is looked up in </span><span class="c3 c6">o</span><span> and invoked with argument </span><span class="c3">im</span><span class="c6">,</span><span> and the result of this invocation is the result of evaluating </span><span class="c3">i</span><span>.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Let </span><span class="c3">T</span><span> be the  static type of </span><span class="c3">e.</span><span> It is a static type warning if </span><span class="c3">T</span><span> does not have a getter named </span><span class="c3">m.</span><span class="c19"> </span><span>The static type of </span><span class="c3">i</span><span> is the declared return type of </span><span class="c3">T.m,</span><span> if </span><span class="c3">T.m</span><span> exists; otherwise the static type of </span><span class="c3">i</span><span>  is </span><span class="c5 c6">Dynamic</span><span class="c6">.</span><span> </span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Evaluation of a getter invocation </span><span class="c3">i</span><span> of the form </span><span class="c3">C.m</span><span> proceeds as follows:</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>The getter function </span><span class="c3">C.m</span><span> is invoked. The value of </span><span class="c3">i</span><span> is the result returned by the call to the getter function. </span></p><p class="c2 c4"><span></span></p><p class="c2"><span>It is a compile-time error if there is no class </span><span class="c3">C</span><span> in the enclosing lexical scope of </span><span class="c3">i,</span><span> or if  </span><span class="c3">C</span><span> does not declare, implicitly or explicitly, a getter named </span><span class="c3">m.</span><span class="c19"> </span><span>The static type of </span><span class="c3">i</span><span> is the declared return type of </span><span class="c3">C.m</span><span class="c6">.</span><span> </span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Evaluation of a top-level getter invocation </span><span class="c3">i</span><span> of the form </span><span class="c3">m</span><span>, where </span><span class="c3">m</span><span> is an identifier, </span><span>proceeds as follows:</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>The getter function </span><span class="c3">m</span><span> is invoked. The value of </span><span class="c3">i</span><span> is the result returned by the call to the getter function.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c11">Note that the invocation is always defined. Per the rules for </span><span class="c10"><a class="c8" href="#id.ayq1ul833tkz">identifier references</a></span><span class="c11">, an identifier will not be treated as a top level getter invocation unless the getter </span><span class="c11 c3">i</span><span class="c11"> is defined. </span></p><p class="c2 c4"><span></span></p><p class="c2"><span>The static type of </span><span class="c3">i</span><span> is the declared return type of </span><span class="c3">m</span><span class="c6">.</span><span> </span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><a href="#" name="id.lc2fh7iv9xwt"></a><h3 class="c2"><a name="h.wkwl6fs6jml0"></a><span>Assignment</span></h3><p class="c2"><span>An assignment changes the value associated with a mutable variable or property.</span></p><p class="c2 c4"><span></span></p><a href="#" name="id.gs625gfxuh9m"></a><p class="c2"><span class="c5 c3">assignmentOperator:</span><span class="c3"><br>      &#39;=&#39;<br>    | </span><span class="c0"><a class="c8" href="#id.5bozvn25ytz">compoundAssignmentOperator</a></span><span class="c3"><br>    ;<br></span></p><p class="c2"><span>Evaluation of an assignment of the form </span><span class="c3">v = e</span><span> proceeds as follows:</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>If there is no </span><span>declaration </span><span class="c3">d</span><span> with name v in the lexical scope</span><span> enclosing the assignment, then the assignment is equivalent to the assignment </span><span class="c5 c6">this</span><span class="c3">.v = e.</span><span> Otherwise,  let </span><span class="c3">d</span><span> be the innermost declaration whose name is </span><span class="c3">v,</span><span> if it exists.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>If </span><span class="c3">d</span><span> is the declaration of a local or </span><span>library</span><span> variable, the expression </span><span class="c3">e</span><span> is evaluated to an object </span><span class="c3">o.</span><span> Then, the variable </span><span class="c3">v</span><span> is bound to </span><span class="c3">o.</span><span> The value of the assignment expression is</span><span class="c3"> o.</span><span> </span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Otherwise, if </span><span class="c3">d</span><span> is the declaration of a static variable in class </span><span class="c3">C,</span><span> then the assignment is equivalent to the assignment </span><span class="c3">C.v = e.</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span>Otherwise, the assignment is equivalent to the assignment </span><span class="c5 c6">this</span><span class="c3">.v = e.</span><span> </span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span>In checked mode, it is a dynamic type error if </span><span class="c3">o</span><span> is not </span><span class="c5 c6">null</span><span> and the interface induced by the class of </span><span class="c3">o</span><span> is not a subtype of the </span><span class="c1"><a class="c8" href="#id.93yudg3nk9o1">actual type</a></span><span> of </span><span class="c3">v</span><span>.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>It is a static type warning if the static type of </span><span class="c3">e</span><span> may not be assigned to the static type of </span><span class="c3">v.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Evaluation of an assignment of the form </span><span class="c3">C.v = e</span><span> proceeds as follows:</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>The expression </span><span class="c3">e</span><span> is evaluated to an object </span><span class="c3">o.</span><span> Then, the setter </span><span class="c3">C.v</span><span> is invoked with its formal parameter bound to o. The value of the assignment expression is</span><span class="c3"> o.</span><span> </span></p><p class="c2 c4"><span></span></p><p class="c2"><span>It is a compile-time error if there is no class </span><span class="c3">C</span><span> in the enclosing lexical scope of the assignment, or if </span><span class="c3">C</span><span> does not declare, implicitly or explicitly, a setter </span><span class="c3">v.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>In checked mode, it is a dynamic type error if </span><span class="c3">o</span><span> is not </span><span class="c5 c6">null</span><span> and the interface induced by the class of o is not a subtype of the static type of </span><span class="c3">C.v</span><span>.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>It is a static type warning if the static type of </span><span class="c3">e</span><span> may not be assigned to the static type of </span><span class="c3">C.v.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Evaluation of an assignment of the form </span><span class="c3">e</span><span class="c9 c3">1</span><span class="c3">.v = e</span><span class="c9 c3">2</span><span> proceeds as follows:</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>The expression </span><span class="c3">e</span><span class="c9 c3">1</span><span> is evaluated to an object </span><span class="c3">o</span><span class="c9 c3">1</span><span class="c3">.</span><span> Then, the expression </span><span class="c3">e</span><span class="c9 c3">2 </span><span class="c9"> </span><span>is evaluated to an </span><span>object </span><span class="c3">o</span><span class="c9 c3">2</span><span class="c3">.</span><span> Then, the setter </span><span class="c3">v</span><span> is looked up in </span><span class="c3">o</span><span class="c9 c3">1</span><span> with respect to the current library</span><span class="c3">,</span><span> and its body is executed with its formal parameter bound to </span><span class="c3">o</span><span class="c9 c3">2</span><span class="c3"> </span><span>and </span><span class="c5 c6">this</span><span> bound to </span><span class="c3">o</span><span class="c9 c3">2</span><span class="c3">.</span><span>  If the setter lookup has failed, then a new instance </span><span class="c3">im </span><span> of the predefined interface  </span><span class="c6">InvocationMirror</span><span> </span><span>is created, such that :</span></p><ol class="c25" start="5"><li class="c7 c2"><span class="c3 c6">im</span><span class="c6">.isSetter</span><span> evaluates to </span><span class="c5 c6">true</span><span>.</span></li><li class="c7 c2"><span class="c3 c6">im</span><span class="c6">.memberName</span><span> evaluates to ‘</span><span class="c6">v’</span><span>.</span></li><li class="c7 c2"><span class="c3 c6">im</span><span class="c6">.arguments.positionalArguments</span><span> evaluates to </span><span class="c6">[</span><span class="c3 c6">o</span><span class="c9 c3 c6">2</span><span class="c6">]</span><span>.</span></li><li class="c7 c2"><span class="c3 c6">im</span><span class="c6">.arguments.namedArguments</span><span> evaluates to </span><span class="c6">{}</span><span>.</span></li></ol><p class="c2 c4"><span></span></p><p class="c2"><span>Then</span><span> the method </span><span class="c6">noSuchMethod() </span><span>is looked up in </span><span class="c3 c6">o</span><span class="c9 c3 c6">1</span><span> with argument </span><span class="c3">im.</span><span> </span><span>The value of the assignment expression is </span><span class="c3">o</span><span class="c9 c3">2</span><span class="c3"> </span><span>irrespective of whether setter lookup has failed or succeeded.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>In checked mode, it is a dynamic type error if </span><span class="c3">o</span><span class="c9 c3">2</span><span> is not </span><span class="c5 c6">null</span><span> and the interface induced by the class of </span><span class="c3">o</span><span class="c9 c3">2</span><span> is not a subtype of the </span><span class="c1"><a class="c8" href="#id.93yudg3nk9o1">actual type</a></span><span> of </span><span class="c3 c6">e</span><span class="c9 c3 c6">1</span><span class="c3">.v</span><span>.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>It is a static type warning if the static type of </span><span class="c3 c6">e</span><span class="c9 c3 c6">2</span><span> may not be assigned to the static type of </span><span class="c3 c6">e</span><span class="c9 c3 c6">1</span><span class="c3">.v.</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span>Evaluation of an assignment of the form </span><span class="c3">e</span><span class="c9 c3">1</span><span class="c3">[e</span><span class="c9 c3">2</span><span class="c3">] = e</span><span class="c9 c3">3</span><span> is equivalent to the evaluation of the expression </span><span class="c3">(a, i, e){a.[]=(i, e); </span><span class="c5 c6">return</span><span class="c3"> e; } (e</span><span class="c9 c3">1</span><span class="c3">, e</span><span class="c9 c3">2</span><span class="c3">, e</span><span class="c9 c3">3</span><span class="c3">).</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><a href="#" name="id.jkue5mysxwsv"></a><h4 class="c2"><a name="h.ctjzifgzeqep"></a><span>Compound Assignment</span></h4><p class="c2 c4"><span></span></p><p class="c2"><span>A compound assignment of the form </span><span class="c3">v op= e</span><span> is equivalent to </span><span class="c3">v = v op e. </span><span>A compound assignment of the form </span><span class="c3">C.v op= e</span><span> is equivalent to </span><span class="c3">C.v = C.v op e. </span><span>A compound assignment of the form </span><span class="c3">e</span><span class="c9 c3">1</span><span class="c3">.v op= e</span><span class="c9 c3">2</span><span> is equivalent to</span><span> </span><span class="c3">((x) =&gt; x.v = x.v op e</span><span class="c9 c3">2</span><span class="c3">)(e</span><span class="c9 c3">1</span><span class="c3">)</span><span class="c3"> </span><span>where x is a variable that is not used in </span><span class="c3">e</span><span class="c9 c3">2</span><span class="c3">. </span><span>A compound assignment of the form </span><span class="c3">e</span><span class="c9 c3">1</span><span class="c3">[e</span><span class="c9 c3">2</span><span class="c3">] op=e</span><span class="c9 c3">3</span><span> is equivalent to </span><span class="c3">((a, i) =&gt; a[i] = a[i] op e</span><span class="c9 c3">3</span><span class="c3">)(e</span><span class="c9 c3">1</span><span class="c3">, e</span><span class="c9 c3">2</span><span class="c3">) </span><span>where </span><span class="c3">a </span><span>and </span><span class="c3">i </span><span>are a variables that are not used in </span><span class="c3">e</span><span class="c9 c3">3</span><span class="c3">.</span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><a href="#" name="id.5bozvn25ytz"></a><p class="c2"><span class="c5 c3">compoundAssignmentOperator:</span><span class="c3"><br>      ‘*=&#39;<br>    | &#39;/=&#39;<br>    | &#39;~/=&#39;<br>    | &#39;%=&#39;<br>    | &#39;+=&#39;<br>    | &#39;-=&#39;<br>    | &#39;&lt;&lt;=&#39;<br>    | &#39;&gt;&gt;=&#39;<br>    | &#39;&amp;=&#39;<br>    | &#39;^=&#39;<br>    | &#39;|=&#39;<br>    ;<br></span></p><a href="#" name="id.qbnp7zy55vr8"></a><h3 class="c2"><a name="h.fpalvmah8gsn"></a><span>Conditional</span></h3><p class="c2 c4"><span></span></p><p class="c2"><span>A </span><span class="c3">conditional expression</span><span> evaluates one of two expressions based on a boolean condition.</span></p><p class="c2 c4"><span></span></p><a href="#" name="id.u42blbh7fdm7"></a><p class="c2"><span class="c5 c3">conditionalExpression:</span><span class="c3"><br>     </span><span class="c0"><a class="c8" href="#id.c0s0d4oz9l0w">logicalOrExpression</a></span><span class="c3"> </span><span class="c3">(&#39;?&#39; </span><span class="c0"><a class="c8" href="#id.k68gukuq6cj9">expressionWithoutCascade</a></span><span class="c3"> &#39;:&#39; </span><span class="c0"><a class="c8" href="#id.k68gukuq6cj9">expressionWithoutCascade</a></span><span class="c3">)</span><span class="c3">?<br>    ;</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span>Evaluation of a conditional expression </span><span class="c3">c</span><span> of the form </span><span class="c3">e</span><span class="c9 c3">1</span><span class="c3"> ? e</span><span class="c9 c3">2</span><span class="c3"> : e</span><span class="c9 c3">3</span><span> proceeds as follows:</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>First, </span><span class="c3">e</span><span class="c9 c3">1</span><span> is evaluated to an object </span><span class="c3">o</span><span class="c9 c3">1</span><span class="c3">.</span><span> In checked mode, it is a dynamic type error if </span><span class="c3">o</span><span class="c9 c3">1</span><span> is not of type </span><span class="c6">bool. </span><span>Otherwise </span><span class="c3">o</span><span class="c9 c3">1</span><span> is then subjected to </span><span class="c1"><a class="c8" href="#id.luoug0f1vx2f">boolean conversion</a></span><span> producing an object </span><span class="c3">r. </span><span> </span><span>If </span><span class="c3">r </span><span>is </span><span class="c5 c6">true</span><span>, then the value of </span><span class="c3">c</span><span> is the result of evaluating the expression </span><span class="c3">e</span><span class="c9 c3">2</span><span class="c3">.</span><span> Otherwise the value of </span><span class="c3">c</span><span> is the result of evaluating the expression </span><span class="c3">e</span><span class="c9 c3">3</span><span class="c3">. </span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span class="c3"> </span><span>It is a static type warning if the type of </span><span class="c3">e</span><span class="c9 c3">1</span><span> may not be assigned to </span><span class="c6">bool.</span><span> </span><span class="c3"> </span><span>The static type of  </span><span class="c3">c</span><span> is the least upper bound of the static type of </span><span class="c3">e</span><span class="c9 c3">2</span><span> and the static type of </span><span class="c3">e</span><span class="c9 c3">3</span><span class="c3">.</span></p><p class="c2"><span> </span></p><a href="#" name="id.hlq4iia0hdjd"></a><h3 class="c2"><a name="h.33dew20hjpt"></a><span>Logical Boolean Expressions</span></h3><p class="c2 c4"><span></span></p><p class="c2"><span>The logical boolean expressions combine boolean objects using the boolean conjunction and disjunction operators.</span></p><p class="c2"><span class="c3"><br></span><a href="#" name="id.c0s0d4oz9l0w"></a><span class="c5 c3">logicalOrExpression:</span><span class="c3"><br>      </span><span class="c0"><a class="c8" href="#id.3dq31ctuko9q">logicalAndExpression</a></span><span class="c3"> (&#39;||&#39; </span><span class="c0"><a class="c8" href="#id.3dq31ctuko9q">logicalAndExpression</a></span><span class="c3">)*<br>    ;<br><br></span><a href="#" name="id.3dq31ctuko9q"></a><span class="c5 c3">logicalAndExpression:</span><span class="c3"><br>      </span><span class="c0"><a class="c8" href="#id.8ofycl50r6w5">bitwiseOrExpression</a></span><span class="c3"> (&#39;</span><span class="c3">&amp;&amp;&#39; </span><span class="c0"><a class="c8" href="#id.8ofycl50r6w5">bitwiseOrExpression</a></span><span class="c3">)*<br>    ;<br></span></p><p class="c2"><span>A </span><span class="c3">logical boolean expression</span><span> is </span><span>either a </span><span class="c1"><a class="c8" href="#id.5wxjf46dh7v0">bitwise expression</a></span><span>, or an invocation of a logical boolean operator on an expression </span><span class="c3">e</span><span class="c9 c3">1</span><span> with argument </span><span class="c3">e</span><span class="c9 c3">2</span><span>.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Evaluation of a logical boolean expression </span><span class="c3">b</span><span> of the form </span><span class="c3">e</span><span class="c9 c3">1</span><span class="c3"> || e</span><span class="c9 c3">2</span><span class="c3"> </span><span>causes the evaluation of </span><span class="c3">e</span><span class="c9 c3">1</span><span>; i</span><span>f </span><span class="c3">e</span><span class="c9 c3">1</span><span> evaluates to </span><span class="c5 c6">true</span><span>, the result of evaluating </span><span class="c3">b</span><span> is </span><span class="c5 c6">true</span><span>, otherwise </span><span class="c3">e</span><span class="c9 c3">2</span><span> is evaluated to an object </span><span class="c3">o,</span><span> which is then subjected to </span><span class="c1"><a class="c8" href="#id.luoug0f1vx2f">boolean conversion</a></span><span> producing a an object </span><span class="c3">r,</span><span> which is the value of </span><span class="c3">b. </span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Evaluation a logical boolean expression </span><span class="c3">b</span><span> of the form </span><span class="c3">e</span><span class="c9 c3">1</span><span class="c3"> &amp;&amp; e</span><span class="c9 c3">2</span><span class="c3"> </span><span>causes the evaluation </span><span class="c3">e</span><span class="c9 c3">1</span><span>; if </span><span class="c3">e</span><span class="c9 c3">1</span><span> does not evaluate to </span><span class="c5 c6">true</span><span>, the result of evaluating </span><span class="c3">b</span><span> is </span><span class="c5 c6">false</span><span>, otherwise </span><span class="c3">e</span><span class="c9 c3">2</span><span> is evaluated to an object </span><span class="c3">o,</span><span> which is then subjected to </span><span class="c1"><a class="c8" href="#id.luoug0f1vx2f">boolean conversion</a></span><span> producing an object </span><span class="c3">r,</span><span> which is the value of </span><span class="c3">b. </span></p><p class="c2 c4"><span class="c19"></span></p><p class="c2"><span>The static type of a logical boolean expression is </span><span class="c6">bool.</span></p><p class="c2 c4"><span></span></p><a href="#" name="id.5wxjf46dh7v0"></a><h3 class="c2"><a name="h.gxkncuzhsd9x"></a><span>Bitwise Expressions</span></h3><p class="c2 c4"><span></span></p><p class="c2"><span>Bitwise expressions invoke the bitwise operators on objects.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c3"><br></span><a href="#" name="id.8ofycl50r6w5"></a><span class="c5 c3">bitwiseOrExpression:</span><span class="c3"><br>      </span><span class="c0"><a class="c8" href="#id.ponnokpig962">bitwiseXorExpression</a></span><span class="c3"> (&#39;|&#39; </span><span class="c0"><a class="c8" href="#id.ponnokpig962">bitwiseXorExpression</a></span><span class="c3">)*<br>    | </span><span class="c6">super</span><span class="c3"> (&#39;|&#39; </span><span class="c0"><a class="c8" href="#id.ponnokpig962">bitwiseXorExpression</a></span><span class="c3">)+<br>    ;<br><br></span><a href="#" name="id.ponnokpig962"></a><span class="c5 c3">bitwiseXorExpression:</span><span class="c3"><br>      </span><span class="c0"><a class="c8" href="#id.6jqdarh7i55f">bitwiseAndExpression</a></span><span class="c3"> (&#39;^&#39; </span><span class="c0"><a class="c8" href="#id.6jqdarh7i55f">bitwiseAndExpression</a></span><span class="c3">)*<br>    | </span><span class="c6">super</span><span class="c3"> (&#39;^&#39; </span><span class="c0"><a class="c8" href="#id.6jqdarh7i55f">bitwiseAndExpression</a></span><span class="c3">)+<br>    ;<br><br></span><a href="#" name="id.6jqdarh7i55f"></a><span class="c5 c3">bitwiseAndExpression:</span><span class="c3"><br>      </span><span class="c0"><a class="c8" href="#id.t3kezrkaouv2">equalityExpression</a></span><span class="c3"> (&#39;&amp;&#39; </span><span class="c0"><a class="c8" href="#id.t3kezrkaouv2">equalityExpression</a></span><span class="c3">)*<br>    | </span><span class="c6">super</span><span class="c3"> (&#39;&amp;&#39; </span><span class="c0"><a class="c8" href="#id.t3kezrkaouv2">equalityExpression</a></span><span class="c3">)+</span></p><p class="c2 c4"><span class="c3"></span></p><a href="#" name="id.mp6goh4wcueb"></a><p class="c2"><span class="c5 c3">bitwiseOperator:</span><span class="c3"><br>      &#39;&amp;&#39;<br>    | &#39;^&#39;<br>    | &#39;|&#39;<br>    ;</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span>A </span><span class="c3">bitwise expression</span><span> is either an </span><span class="c1"><a class="c8" href="#id.i3yv71am0yah">equality expression</a></span><span>, or an invocation of a bitwise operator on either </span><span class="c5 c6">super</span><span> or an expression </span><span class="c3">e</span><span class="c9 c3">1</span><span>, with argument </span><span class="c3">e</span><span class="c9 c3">2</span><span>.</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span>A </span><span>bitwise expression </span><span>of the form  </span><span class="c3">e</span><span class="c9 c3">1</span><span class="c3"> op e</span><span class="c9 c3">2</span><span class="c3"> </span><span>is equivalent to the method invocation </span><span class="c3">e1.op(e2).</span></p><p class="c2"><span>A bitwise expression of the form</span><span>  </span><span class="c5 c3 c6">super</span><span class="c3"> op e</span><span class="c9 c3">2</span><span class="c3"> </span><span>is equivalent to the method invocation </span><span class="c5 c3 c6">super</span><span class="c3">.op(e</span><span class="c9 c3">2</span><span class="c3">).</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span class="c11">It should be obvious that the static type rules for these expressions are defined by the equivalence above - ergo, by the type rules for method invocation and the signatures of the operators on the type </span><span class="c11 c3">e</span><span class="c9 c11 c3">1</span><span class="c11 c3">.</span><span class="c11"> The same holds in similar situations throughout this specification.</span></p><p class="c2 c4"><span class="c3"></span></p><a href="#" name="id.i3yv71am0yah"></a><h3 class="c2"><a name="h.5kdfq4b9vyr1"></a><span>Equality</span></h3><p class="c2 c4"><span></span></p><p class="c2"><span>Equality expressions test objects for identity or equality.</span></p><p class="c2 c4"><span class="c3"></span></p><a href="#" name="id.t3kezrkaouv2"></a><p class="c2"><span class="c5 c3">equalityExpression:</span><span class="c3"><br>      relationalExpression (</span><span class="c0"><a class="c8" href="#id.udvn0y5cd5a9">equalityOperator</a></span><span class="c3"> </span><span class="c0"><a class="c8" href="#id.5ev8aeaipufa">relationalExpression</a></span><span class="c3">)?<br>    | </span><span class="c6">super</span><span class="c3"> equalityOperator relationalExpression<br>    ;<br></span></p><a href="#" name="id.udvn0y5cd5a9"></a><p class="c2"><span class="c5 c3">equalityOperator:</span><span class="c3"><br>      &#39;==&#39;<br>    | &#39;!=&#39;<br>    | &#39;===&#39;<br>    | &#39;!==&#39;<br>    ;</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span>An </span><span class="c3">equality expression</span><span> is either a </span><span class="c1"><a class="c8" href="#id.t07xpf1d6trb">relational expression</a></span><span>, or an invocation of an equality operator on  on either </span><span class="c5 c6">super</span><span> or an expression </span><span class="c3">e</span><span class="c9 c3">1</span><span>, with argument </span><span class="c3">e</span><span class="c9 c3">2</span><span>.</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span>Evaluation of an equality expression </span><span class="c3">ee</span><span> of the form </span><span class="c3">e</span><span class="c18 c3">1</span><span class="c3"> == e</span><span class="c18 c3">2</span><span class="c3"> </span><span>proceeds as follows:</span></p><ol class="c25" start="1"><li class="c7 c2"><span>The expression </span><span class="c3">e</span><span class="c18 c3">1</span><span> is evaluated to an object </span><span class="c3">o</span><span class="c18 c3">1</span><span>.</span></li><li class="c7 c2"><span>The expression </span><span class="c3">e</span><span class="c18 c3">2</span><span> is evaluated to an object </span><span class="c3">o</span><span class="c18 c3">2</span><span>.</span></li><li class="c7 c2"><span>If </span><span class="c3">o</span><span class="c18 c3">1</span><span class="c3"> === o</span><span class="c18 c3">2 </span><span>evaluates to </span><span class="c5 c6">true</span><span>, then </span><span class="c3">ee</span><span> evaluates to </span><span class="c5 c6">true</span><span>. Otherwise,</span></li><li class="c7 c2"><span>If either </span><span class="c3">o</span><span class="c18 c3">1</span><span> or </span><span class="c3">o</span><span class="c18 c3">2</span><span> is </span><span class="c6">null</span><span>, then </span><span class="c3">ee</span><span> evaluates to </span><span class="c5 c6">false</span><span>. Otherwise,</span></li><li class="c7 c2"><span class="c3">ee</span><span> is equivalent to the method invocation </span><span class="c3">o</span><span class="c18 c3">1</span><span class="c3">.</span><span class="c5 c3 c6">eq</span><span class="c3">(o</span><span class="c18 c3">2</span><span class="c3">).</span></li></ol><p class="c2 c4"><span class="c3"></span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span>Evaluation of an equality expression </span><span class="c3">ee</span><span> of the form </span><span class="c5 c3 c6">super</span><span class="c3"> == e </span><span>proceeds as follows:</span></p><ol class="c25" start="1"><li class="c7 c2"><span>The expression </span><span class="c3">e</span><span> is evaluated to an object </span><span class="c3">o</span><span>.</span></li><li class="c7 c2"><span>If </span><span class="c5 c6">this</span><span class="c3"> === o</span><span class="c18 c3"> </span><span>evaluates to </span><span class="c5 c6">true</span><span>, then </span><span class="c3">ee</span><span> evaluates to </span><span class="c5 c6">true</span><span>. Otherwise,</span></li><li class="c7 c2"><span>If either </span><span class="c5 c6">this</span><span> or </span><span class="c3">o</span><span> is </span><span class="c6">null</span><span>, then </span><span class="c3">ee</span><span> evaluates to </span><span class="c5 c6">false</span><span>. Otherwise,</span></li><li class="c7 c2"><span class="c3">ee</span><span> is equivalent to the method invocation </span><span class="c5 c3 c6">super</span><span class="c3">.</span><span class="c5 c3 c6">eq</span><span class="c3">(o).</span></li></ol><p class="c2 c4"><span class="c3"></span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span class="c11">As a result of the above definition, user defined </span><span class="c5 c11 c6">eq</span><span class="c11 c6">()</span><span class="c11"> methods can assume that their argument is not </span><span class="c5 c11 c6">this</span><span class="c11"> and is non-null, and avoid the standard boiler-plate prelude:</span></p><p class="c2"><span class="c11 c6"> if (this === arg) return true;</span></p><p class="c2"><span class="c11 c6"> if (null === arg) return false;</span></p><p class="c2 c4"><span class="c11 c6"></span></p><p class="c2"><span class="c11">Another implication is that there is never a need to use </span><span class="c11 c6">===</span><span class="c11"> to test against </span><span class="c11 c6">null,</span><span class="c11"> nor should anyone ever worry about whether to write </span><span class="c11 c6">null == e </span><span class="c11">or </span><span class="c11 c6">e = = null</span><span class="c11">.</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span>An equality expression of the form </span><span class="c3">e</span><span class="c9 c3">1</span><span class="c3"> != e</span><span class="c9 c3">2  </span><span>is equivalent to the expression </span><span class="c3">!(e</span><span class="c9 c3">1</span><span class="c3"> == e</span><span class="c9 c3">2 </span><span class="c3">). </span><span>An equality expression of the form  </span><span class="c5 c3 c6">super</span><span class="c3"> != e </span><span>is equivalent to the expression </span><span class="c3">!(</span><span class="c5 c3 c6">super</span><span class="c3"> </span><span class="c3">== e</span><span class="c3">)</span><span class="c3">).</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span>Evaluation of an equality expression </span><span class="c3">ee</span><span> of the form </span><span class="c3">e</span><span class="c9 c3">1</span><span class="c3"> === e</span><span class="c9 c3">2 </span><span>proceeds as follows:</span></p><p class="c2"><span>The expression </span><span class="c3">e</span><span class="c9 c3">1</span><span> is evaluated to an object </span><span class="c3">o</span><span class="c9 c3">1</span><span>; then the expression </span><span class="c3">e</span><span class="c9 c3">2</span><span> is evaluated to an object </span><span class="c3">o</span><span class="c9 c3">2</span><span>.  Next, if </span><span class="c3">o</span><span class="c9 c3">1</span><span> and </span><span class="c3">o</span><span class="c9 c3">2</span><span> are the same object, then </span><span class="c3">ee</span><span> evaluates to </span><span class="c5 c6">true,</span><span> otherwise </span><span class="c3">ee</span><span> evaluates to </span><span class="c5 c6">false. </span></p><p class="c2 c4"><span class="c5 c6"></span></p><p class="c2"><span>An equality expression of the form  </span><span class="c5 c3 c6">super</span><span class="c3"> === e</span><span class="c3"> </span><span>is equivalent to the expression </span><span class="c5 c3 c6">this </span><span class="c3">=== e.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>An equality expression of the form </span><span class="c3">e</span><span class="c9 c3">1</span><span class="c3"> !== e</span><span class="c9 c3">2  </span><span>is equivalent to the expression </span><span class="c3">!(e</span><span class="c9 c3">1</span><span class="c3"> === e</span><span class="c9 c3">2 </span><span class="c3">). </span><span>An equality expression of the form  </span><span class="c5 c3 c6">super</span><span class="c3"> !== e </span><span>is equivalent to the expression </span><span class="c3">!(</span><span class="c5 c3 c6">super</span><span class="c3"> === e).</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span>The static type of an equality expression is </span><span class="c6">bool.</span></p><p class="c2 c4"><span class="c6"></span></p><p class="c2 c4"><span class="c3"></span></p><a href="#" name="id.t07xpf1d6trb"></a><h3 class="c2"><a name="h.fmzbyxz4ly1c"></a><span>Relational Expressions</span></h3><p class="c2 c4"><span></span></p><p class="c2"><span>Relational expressions invoke the relational operators on objects.</span></p><p class="c2"><span class="c3"><br></span><a href="#" name="id.5ev8aeaipufa"></a><span class="c5 c3">relationalExpression:</span><span class="c3"><br>      shiftExpression (isOperator type | relationalOperator shiftExpression)?<br>    | </span><span class="c6">super</span><span class="c3"> relationalOperator shiftExpression<br>    ;</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span class="c3"><br></span><a href="#" name="id.dqm1hvagt3y5"></a><span class="c5 c3">relationalOperator:</span><span class="c3"><br>      &#39;&gt;=&#39;<br>    | &#39;&gt;&#39;<br>    | &#39;&lt;=&#39;<br>    | &#39;&lt;&#39;<br>    ;</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span>A </span><span class="c3">relational expression</span><span> is either a </span><span class="c1"><a class="c8" href="#id.dvp94fjydf3m">shift expression</a></span><span>, or an invocation of a relational operator on  on either </span><span class="c5 c6">super</span><span> or an expression </span><span class="c3">e</span><span class="c9 c3">1</span><span>, </span><span>with argument </span><span class="c3">e</span><span class="c9 c3">2</span><span>.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>A relational expression of the form  </span><span class="c3">e1 op e2 </span><span>is equivalent to the method invocation </span><span class="c3">e1.op(e2).</span></p><p class="c2"><span>A relational expression of the form  </span><span class="c5 c3 c6">super</span><span class="c3"> op e2 </span><span>is equivalent to the method invocation </span><span class="c5 c3 c6">super</span><span class="c3">.op(e2).</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><a href="#" name="id.dvp94fjydf3m"></a><h3 class="c2"><a name="h.jmq7bvufo5ez"></a><span>Shift</span></h3><p class="c2 c4"><span></span></p><p class="c2"><span class="c3">Shift expressions</span><span> invoke the shift operators on objects.</span></p><p class="c2"><span><br></span><a href="#" name="id.37ba2r89wwl"></a><span class="c5 c3">shiftExpression:</span><span class="c3"><br>      additiveExpression (shiftOperator additiveExpression)*<br>    | </span><span class="c6">super</span><span class="c3"> (shiftOperator additiveExpression)+<br>    ;</span></p><p class="c2 c4"><span class="c3"></span></p><a href="#" name="id.m87pll3ti0gq"></a><p class="c2"><span class="c5 c3">shiftOperator:</span><span class="c3"><br>      &#39;&lt;&lt;&#39;<br>    | &#39;&gt;&gt;&#39; <br>    ;<br></span></p><p class="c2"><span>A </span><span class="c3">shift expression</span><span> is either an </span><span class="c1"><a class="c8" href="#id.lw482t2ir5le">additive expression</a></span><span>, or an invocation of a shift operator on  on either </span><span class="c5 c6">super</span><span> or an expression </span><span class="c3">e</span><span class="c9 c3">1</span><span>, with argument </span><span class="c3">e</span><span class="c9 c3">2</span><span>.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>A shift expression of the form  </span><span class="c3">e1 op e2 </span><span>is equivalent to the method invocation </span><span class="c3">e1.op(e2).</span></p><p class="c2"><span>A shift expression of the form  </span><span class="c5 c3 c6">super</span><span class="c3"> op e2 </span><span>is equivalent to the method invocation </span><span class="c5 c3 c6">super</span><span class="c3">.op(e2).</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span class="c11">Note that this definition implies left-to-right evaluation order among shift expressions: </span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span class="c11 c3">e</span><span class="c9 c11 c3">1</span><span class="c11 c3"> &lt;&lt; e</span><span class="c9 c11 c3">2</span><span class="c11 c3"> &lt;&lt; e</span><span class="c9 c11 c3">3</span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span class="c11">is evaluated as  (</span><span class="c11 c3">e</span><span class="c9 c11 c3">1</span><span class="c11 c3"> &lt;&lt; e</span><span class="c9 c11 c3">2</span><span class="c11 c3"> ).&lt;&lt; (e</span><span class="c9 c11 c3">3</span><span class="c11">)  which is equivalent to (</span><span class="c11 c3">e</span><span class="c9 c11 c3">1</span><span class="c11 c3"> &lt;&lt; e</span><span class="c9 c11 c3">2</span><span class="c11 c3">) &lt;&lt; e</span><span class="c9 c11 c3">3</span><span class="c3 c29">.</span></p><p class="c2"><span class="c11">The same holds for additive and multiplicative expressions. </span></p><p class="c2 c4"><span class="c3"></span></p><a href="#" name="id.lw482t2ir5le"></a><h3 class="c2"><a name="h.7hq9zn6blrwm"></a><span>Additive Expressions</span></h3><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span class="c3">Additive expressions</span><span> invoke the addition operators on objects.</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span class="c3"><br></span><a href="#" name="id.8uueyjhsc89s"></a><span class="c5 c3">additiveExpression:</span><span class="c3"><br>      multiplicativeExpression (additiveOperator multiplicativeExpression)*<br>    | </span><span class="c6">super</span><span class="c3"> (additiveOperator multiplicativeExpression)+<br>    ;</span></p><p class="c2 c4"><span class="c3"></span></p><a href="#" name="id.zg2oy42p83ut"></a><p class="c2"><span class="c5 c3">additiveOperator:</span><span class="c3"><br>      &#39;+&#39;<br>    | &#39;-&#39;<br>    ;<br></span></p><p class="c2"><span>An </span><span class="c3">additive expression</span><span> is either a </span><span class="c1"><a class="c8" href="#id.ksyfp4fbik8u">multiplicative expression</a></span><span>, or an invocation of an additive operator on  on either </span><span class="c5 c6">super</span><span> or an expression </span><span class="c3">e</span><span class="c9 c3">1</span><span>, with argument </span><span class="c3">e</span><span class="c9 c3">2</span><span>.</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span>An additive expression of the form  </span><span class="c3">e1 op e2 </span><span>is equivalent to the method invocation </span><span class="c3">e1.op(e2).</span></p><p class="c2"><span>An additive expression of the form  </span><span class="c5 c3 c6">super</span><span class="c3"> op e2 </span><span>is equivalent to the method invocation </span><span class="c5 c3 c6">super</span><span class="c3">.op(e2).</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2 c4"><span class="c3"></span></p><a href="#" name="id.ksyfp4fbik8u"></a><h3 class="c2"><a name="h.uofn135f1hb3"></a><span>Multiplicative Expressions</span></h3><p class="c2 c4"><span></span></p><p class="c2"><span class="c3">Multiplicative expressions</span><span> invoke the multiplication operators on objects.</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span class="c3"><br></span><a href="#" name="id.9keimk8xamh7"></a><span class="c5 c3">multiplicativeExpression:</span><span class="c3"><br>      unaryExpression (multiplicativeOperator unaryExpression)*<br>    | </span><span class="c6">super</span><span class="c3"> (multiplicativeOperator unaryExpression)+<br>    ;<br></span></p><a href="#" name="id.q23phy16kl7s"></a><p class="c2"><span class="c5 c3">multiplicativeOperator:</span><span class="c3"><br>      &#39;*&#39;<br>    | &#39;</span><span class="c3">/</span><span class="c3">&#39;<br>    | &#39;</span><span class="c3">%</span><span class="c3">&#39;<br>    | &#39;</span><span class="c3">~/</span><span class="c3">&#39;<br>    ;</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2 c4"><span></span></p><p class="c2"><span>A </span><span class="c3">multiplicative expression</span><span> is either a </span><span class="c1"><a class="c8" href="#id.20somwjc6usp">unary expression</a></span><span>, or an invocation of a multiplicative operator on either </span><span class="c5 c6">super</span><span> or an expression </span><span class="c3">e</span><span class="c9 c3">1</span><span>, with argument </span><span class="c3">e</span><span class="c9 c3">2</span><span>.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>A multiplicative expression of the form  </span><span class="c3">e1 op e2 </span><span>is equivalent to the method invocation </span><span class="c3">e1.op(e2). </span><span>A multiplicative expression of the form  </span><span class="c5 c3 c6">super</span><span class="c3"> op e2 </span><span>is equivalent to the method invocation </span><span class="c5 c3 c6">super</span><span class="c3">.op(e2).</span></p><p class="c2 c4"><span class="c3"></span></p><h3 class="c2"><a name="h.nctl41fjp9vk"></a><span class="c3"><br></span><a href="#" name="id.20somwjc6usp"></a><span>Unary Expressions</span></h3><p class="c2 c4"><span></span></p><p class="c2"><span>Unary expressions invoke unary operators on objects.</span></p><p class="c2"><span><br></span><a href="#" name="id.ibekae2xw66d"></a><span class="c5 c3">unaryExpression:</span><span class="c3"><br>      prefixOperator unaryExpression<br>    | postfixExpression<br>    | unaryOperator </span><span class="c5 c6">super</span><span class="c3"><br>    | &#39;-&#39; </span><span class="c5 c6">super</span><span class="c3"> <br>    | incrementOperator assignableExpression<br>    ;<br></span></p><p class="c2"><span>A </span><span class="c3">unary expression</span><span> is either a </span><span class="c1"><a class="c8" href="#id.jzsb5y8clslk">postfix expression</a></span><span>, an invocation of a prefix operator on an expression </span><span class="c3">e,</span><span> or an invocation of a unary operator on either </span><span class="c5 c6">super</span><span> or an expression </span><span class="c3">e</span><span>.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>The expression </span><span class="c3">!e</span><span> is equivalent to the expression </span><span class="c3">e? </span><span class="c5 c3 c6">false</span><span class="c3">: </span><span class="c5 c3 c6">true</span><span class="c3">.</span></p><p class="c2"><span>Evaluation of an expression of the form </span><span class="c6">++</span><span class="c3 c6">e </span><span>is equivalent to </span><span class="c3 c6">e</span><span class="c6"> += 1.</span><span>  Evaluation of an expression of the form </span><span class="c6">--</span><span class="c3 c6">e</span><span> is equivalent to </span><span class="c3 c6">e</span><span class="c6"> -= 1.</span><span> </span></p><p class="c2 c4"><span></span></p><p class="c2"><span>The expression </span><span class="c3">-e</span><span> is equivalent to the method invocation </span><span class="c3">e.</span><span class="c5 c6">negate</span><span class="c3">().  </span><span>The expression </span><span class="c3">-</span><span class="c5 c6">super</span><span> is equivalent  to the method invocation </span><span class="c5 c6">super</span><span class="c3">.</span><span class="c5 c6">negate</span><span class="c3">().</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>A unary expression </span><span class="c3">u</span><span> of the form </span><span class="c3">op e</span><span> is equivalent to a method invocation  expression </span><span class="c3">e.op().</span></p><p class="c2"><span>An expression of the form </span><span class="c3">op </span><span class="c5 c6">super</span><span> is equivalent to the method invocation </span><span class="c5 c6">super</span><span class="c3">.op().</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span class="c3"></span></p><a href="#" name="id.jzsb5y8clslk"></a><h3 class="c2"><a name="h.h035ru2uchdu"></a><span>Postfix Expressions</span></h3><p class="c2 c4"><span></span></p><p class="c2"><span>Postfix expressions invoke the postfix operators on objects.</span></p><p class="c2"><span class="c3"><br></span><a href="#" name="id.v4mie360u0q2"></a><span class="c5 c3">postfixExpression:</span><span class="c3"><br>      assignableExpression postfixOperator<br>    | primary selector*<br>    ;</span></p><p class="c2 c4"><span class="c3"></span></p><a href="#" name="id.mdk3odnrh07m"></a><p class="c2"><span class="c5 c3">postfixOperator:</span><span class="c3"><br>      incrementOperator<br>    ;<br><br><br></span><a href="#" name="kix.yizwlgqjrpzw"></a><span class="c5 c3">selector:</span><span class="c3"><br>      assignableSelector<br>    | </span><span class="c1 c3"><a class="c8" href="#kix.xl2ewwstkqba">arguments</a></span><span class="c3"><br>    ;</span></p><p class="c2"><span class="c3"><br></span><a href="#" name="id.s3388kir88ok"></a><span class="c5 c3">incrementOperator:</span><span class="c3"><br>      &#39;++&#39;<br>    | &#39;--&#39;<br>    ;<br></span></p><p class="c2 c4"><span></span></p><p class="c2"><span>A </span><span class="c3">postfix expression</span><span> is either a primary expression, a function, method or getter invocation, or an invocation of a postfix operator on an expression </span><span class="c3">e</span><span>.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>A postfix expression of the form </span><span class="c3 c6">v</span><span class="c6">++</span><span>, where </span><span class="c3">v</span><span> is an identifier, is equivalent to </span><span class="c3">(){var r = v; v = r + 1; return r}().</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span class="c3 c14">The above ensures that if v is a field, the getter gets called exactly once. Likewise in the cases below. </span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span>A postfix expression of the form </span><span class="c3 c6">C.v </span><span class="c6">++</span><span> is equivalent to </span><span class="c3">(){var r = C.v; C.v = r + 1; return r}().</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>A postfix expression of the form </span><span class="c3">e</span><span class="c9 c3">1</span><span class="c3">.v</span><span class="c6">++</span><span> is equivalent to </span><span class="c3">(x){var r = x.v; x.v = r + 1; return r}(e</span><span class="c9 c3">1</span><span class="c3">).</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>A postfix expression of the form </span><span class="c3">e</span><span class="c9 c3">1</span><span class="c3">[e</span><span class="c9 c3">2</span><span class="c3">]</span><span class="c6">++</span><span> is equivalent to </span><span class="c3">(a, i){var r = a[i]; a[i] = r + 1; return r}(e</span><span class="c9 c3">1</span><span class="c3">, e</span><span class="c9 c3">2</span><span class="c3">)</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>A postfix expression of the form </span><span class="c3 c6">v--</span><span>, where </span><span class="c3">v</span><span> is an identifier, is equivalent to </span><span class="c3">(){var r = v; v = r - 1; return r}().</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span>A postfix expression of the form </span><span class="c3 c6">C.v--</span><span> is equivalent to </span><span class="c3">(){var r = C.v; C.v = r - 1; return r}().</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>A postfix expression of the form </span><span class="c3">e</span><span class="c9 c3">1</span><span class="c3">.v--</span><span> is equivalent to </span><span class="c3">(x){var r = x.v; x.v = r - 1; return r}(e</span><span class="c9 c3">1</span><span class="c3">).</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>A postfix expression of the form </span><span class="c3">e</span><span class="c9 c3">1</span><span class="c3">[e</span><span class="c9 c3">2</span><span class="c3">]</span><span class="c6">--</span><span> is equivalent to </span><span class="c3">(a, i){var r = a[i]; a[i] = r - 1; return r}(e</span><span class="c9 c3">1</span><span class="c3">, e</span><span class="c9 c3">2</span><span class="c3">)</span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><a href="#" name="id.i8uc5yxjszau"></a><h3 class="c2"><a name="h.dt5sshf3wb90"></a><span>Assignable Expressions</span></h3><p class="c2 c4"><span></span></p><p class="c2"><span>Assignable expressions are expressions that can appear on the left hand side of an assignment. This section describes how to evaluate these expressions when they do not constitute the complete left hand side of an assignment.</span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c3 c14">Of course, if assignable expressions always appeared </span><span class="c5 c3 c14">as</span><span class="c3 c14"> the left hand side, one would have no need for their value, and the rules for evaluating them would be unnecessary. However,  assignable expressions can be subexpressions of other expressions and therefore must be evaluated.</span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span class="c3"></span></p><a href="#" name="kix.3nqu822r00nf"></a><p class="c2"><span class="c5 c3">assignableExpression:</span><span class="c3"><br>      primary (arguments* assignableSelector)+<br>    | </span><span class="c5 c6">super</span><span class="c3"> assignableSelector<br>    | </span><span class="c0"><a class="c8" href="#id.te0njh1fhw7g">identifier</a></span><span class="c3"><br>    ;<br></span></p><a href="#" name="kix.sozsnkf6qfzk"></a><p class="c2"><span class="c5 c3">assignableSelector:</span><span class="c3"><br>      &#39;[&#39; </span><span class="c0"><a class="c8" href="#id.1u3vxuwrz6py">expression</a></span><span class="c3"> &#39;]&#39;<br>    | &#39;.&#39; </span><span class="c0"><a class="c8" href="#id.te0njh1fhw7g">identifier</a></span><span class="c3"><br>    ;<br></span></p><p class="c2"><span>An </span><span class="c3">assignable expression</span><span> is either:</span></p><ol class="c25" start="1"><li class="c7 c2"><span> An identifier. </span></li><li class="c7 c2"><span>An invocation of a method, getter or list access operator on</span><span> an expression </span><span class="c3">e</span><span>.</span></li><li class="c7 c2"><span>An invocation of a getter or list access operator on </span><span class="c5 c6">super</span><span>.</span></li></ol><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span>An assignable expression of the form </span><span class="c3">id</span><span> is evaluated as an </span><span class="c1"><a class="c8" href="#id.ayq1ul833tkz">identifier expression</a></span><span>.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>An assignable expression of the form </span><span class="c3">e.id(a</span><span class="c9 c3">1</span><span class="c3">, …, a</span><span class="c9 c3">n</span><span class="c3">)</span><span class="c3"> </span><span>is evaluated as a </span><span class="c1"><a class="c8" href="#kix.1bfikjk2e9bd">method invocation</a></span><span>.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>An assignable expression of the form </span><span class="c3">e.id </span><span>is evaluated as a </span><span class="c1"><a class="c8" href="#id.lharm2td3qkb">getter invocation</a></span><span>.</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span>An assignable expression of the form </span><span class="c3">e</span><span class="c9 c3">1</span><span class="c3">[e</span><span class="c9 c3">2</span><span class="c3">]</span><span> is evaluated as a </span><span class="c1"><a class="c8" href="#kix.1bfikjk2e9bd">method invocation</a></span><span> of the operator method </span><span class="c3">[]</span><span> on </span><span class="c3">e</span><span class="c9 c3">1 </span><span>with argument </span><span class="c3">e</span><span class="c9 c3">2</span><span class="c3">.</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span>An assignable expression of the form </span><span class="c5 c3 c6">super</span><span class="c3">.id </span><span>is evaluated as a </span><span class="c1"><a class="c8" href="#id.lharm2td3qkb">getter invocation</a></span><span>.</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span>An assignable expression of the form </span><span class="c5 c3 c6">super</span><span class="c3">[e</span><span class="c9 c3">2</span><span class="c3">]</span><span> is equivalent to the </span><span class="c1"><a class="c8" href="#kix.1bfikjk2e9bd">method invocation</a></span><span>  </span><span class="c5 c3 c6">super</span><span class="c6">.</span><span class="c3">[e</span><span class="c9 c3">2</span><span class="c3">].</span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span class="c3"></span></p><a href="#" name="id.ayq1ul833tkz"></a><h3 class="c2"><a name="h.igni7ynd65c8"></a><span>Identifier Reference</span></h3><p class="c2 c4"><span></span></p><p class="c2"><span>An </span><span class="c3">identifier expression</span><span> consists of a single identifier; it provides access to an object via an unqualified name.</span></p><p class="c2 c4"><span></span></p><a href="#" name="id.te0njh1fhw7g"></a><p class="c2"><span class="c5 c3">identifier:</span><span class="c3"><br>     </span><span class="c3">  IDENTIFIER</span></p><p class="c2"><span class="c3">    | BUILT_IN_IDENTIFIER</span></p><p class="c2"><span class="c3">    ;</span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><a href="#" name="id.m0fl3pkjxvo8"></a><p class="c2"><span class="c5 c3">IDENTIFIER_NO_DOLLAR:</span><span class="c3"><br>      IDENTIFIER_START_NO_DOLLAR IDENTIFIER_PART_NO_DOLLAR*<br>    ;<br><br></span><a href="#" name="id.8h9okiij55u5"></a><span class="c5 c3">IDENTIFIER:</span><span class="c3"><br>      IDENTIFIER_START IDENTIFIER_PART*<br>    ;<br><br></span><span class="c27 c3">    ;</span></p><p class="c2 c4"><span class="c27 c3"></span></p><a href="#" name="id.xz9q4hxlymsw"></a><p class="c2"><span class="c5 c3">BUILT_IN_IDENTIFIER:<br></span><span class="c3">      </span><span class="c5 c6">abstract</span><span class="c3"><br>    | </span><span class="c5 c6">assert</span></p><p class="c2"><span class="c5 c6">    </span><span class="c6">|</span><span class="c5 c6"> call</span></p><p class="c2"><span class="c5 c6">    </span><span>|</span><span class="c5 c6"> Dynamic</span><span class="c3"><br>    | </span><span class="c5 c6">factory</span><span class="c3"><br>    | </span><span class="c5 c6">get</span><span class="c3"><br>    | </span><span class="c5 c6">implements</span></p><p class="c2"><span class="c3">    | </span><span class="c5 c6">interface</span><span class="c3"><br>    | </span><span class="c5 c6">negate</span><span class="c3"><br>    | </span><span class="c5 c6">operator</span><span class="c3"><br>    | </span><span class="c5 c6">set</span><span class="c3"><br>    | </span><span class="c5 c6">static</span><span class="c3"><br>    | </span><span class="c5 c6">typedef</span><span class="c3"><br>    ;<br></span><span class="c3 c27"><br></span><span class="c3"><br> </span><a href="#" name="id.becabfpst9n7"></a><span class="c5 c3">IDENTIFIER_START:</span><span class="c3"><br>      IDENTIFIER_START_NO_DOLLAR<br>    | &#39;$&#39;<br>    ;<br><br></span><a href="#" name="id.dcqdfpfnuwcu"></a><span class="c5 c3">IDENTIFIER_START_NO_DOLLAR:</span><span class="c3"><br>      LETTER<br>    | &#39;_&#39;<br>    ;<br><br> </span><a href="#" name="id.mwwr4imbfjxy"></a><span class="c5 c3">IDENTIFIER_PART_NO_DOLLAR:</span><span class="c3"><br>      IDENTIFIER_START_NO_DOLLAR<br>    | DIGIT<br>    ;</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span class="c3"><br></span><a href="#" name="id.v0bgahf2n7x"></a><span class="c5 c3">IDENTIFIER_PART:</span><span class="c3"><br>      IDENTIFIER_START<br>    | DIGIT<br>    ;<br><br><br><br></span><a href="#" name="id.xsv95i3z7eli"></a><span class="c5 c3">qualified:</span><span class="c3"><br>      </span><span class="c0"><a class="c8" href="#id.te0njh1fhw7g">identifier</a></span><span class="c3"> (&#39;.&#39; </span><span class="c0"><a class="c8" href="#id.te0njh1fhw7g">identifier</a></span><span class="c3">)?<br>    ;</span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><p class="c2"><span>A built-in identifier is one of the identifiers produced by the production </span><span>BUILT_IN_IDENTIFIER. It is a compile-time error if a built-in identifier is used as the declared name of a class, interface, type variable or type alias. It is a compile-time error to use a built-in identifier other than   </span><span class="c5 c6">Dynamic </span><span>as a type annotation. It is a static warning if a built-in identifier is used as the name of a user-defined declaration, be it a variable, function, type or label, with the exception of user defined operators named </span><span class="c5 c6">negate</span><span> or </span><span class="c5 c6">call</span><span>.</span></p><p class="c2 c4"><span class="c6"></span></p><p class="c2"><span class="c3 c14">Built-in identifiers are identifiers that are used as keywords in Dart, but are not reserved words in Javascript. To minimize incompatibilities when porting Javascript code to Dart, we do not make these into reserved words. However, a built-in identifier may not be used to name a class or type.  In other words, they are treated as reserved words when used as types. This eliminates many confusing situations without causing compatibility problems.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Evaluation of an identifier expression </span><span class="c3">e</span><span> of the form </span><span class="c3">id</span><span> proceeds as follows:</span></p><p class="c2"><span>Let </span><span class="c3">d</span><span> be the innermost declaration in the enclosing lexical scope whose name is </span><span class="c3">id. </span><span>It is a compile-time error if </span><span class="c3">d</span><span> is a class, interface, type alias or type variable. If no such declaration exists in the lexical scope, let </span><span class="c3">d</span><span> be the declaration of the inherited </span><span>member</span><span> named </span><span class="c3">id</span><span> if it exists. </span></p><p class="c2 c4"><span></span></p><ol class="c25" start="1"><li class="c7 c2"><span>If </span><span class="c3">d</span><span> is a library variable then:</span></li></ol><ol class="c34" start="1"><li class="c20 c2"><span>If d is of one of the forms </span><span class="c5 c3 c6">var</span><span class="c3 c6"> v = e</span><span class="c18 c3 c6">i</span><span class="c3 c6">; , T </span><span class="c5 c3 c6">var</span><span class="c3 c6"> v = e</span><span class="c18 c3 c6">i</span><span class="c3 c6">; , </span><span class="c5 c3 c6">final</span><span class="c3 c6"> v = e</span><span class="c18 c3 c6">i</span><span class="c3 c6">;</span><span> </span><span class="c3 c6">,</span><span> </span><span class="c5 c3 c6">final</span><span class="c3 c6"> T v = e</span><span class="c18 c3 c6">i</span><span class="c3 c6">;</span><span> </span><span class="c6">,</span><span> </span><span class="c5 c3 c6">const</span><span class="c3 c6"> v = e</span><span class="c18 c3 c6">i</span><span class="c3 c6">;</span><span> or </span><span class="c5 c3 c6">const</span><span class="c3 c6"> T v = e</span><span class="c18 c3 c6">i</span><span class="c3 c6">;</span><span>  and no value has yet been stored into </span><span class="c3">v</span><span> then the initializer expression </span><span class="c3 c6">e</span><span class="c18 c3 c6">i</span><span> is evaluated. If the evaluation succeeded yielding an object </span><span class="c3">o</span><span>, let </span><span class="c3">r = o,</span><span> otherwise let </span><span class="c3">r = </span><span class="c3 c6">null</span><span class="c3">.</span><span> In any case, </span><span class="c3">r</span><span> is stored into </span><span class="c3">v.</span><span> The value of </span><span class="c3">e</span><span> is </span><span class="c3">r. </span></li><li class="c20 c2"><span>If </span><span class="c3">d</span><span> is of one of the forms </span><span class="c5 c3 c6">const</span><span class="c3 c6"> v = e;</span><span> or </span><span class="c5 c3 c6">const</span><span class="c3 c6"> T v = e;</span><span> the result of the getter is the value of the compile time constant </span><span class="c3 c6">e</span><span>. Otherwise</span></li><li class="c20 c2"><span class="c3">e</span><span> evaluates to the current binding of </span><span class="c3">id.</span><span>  </span><span class="c11">This case also applies if </span><span class="c11 c3">d</span><span class="c11"> is a library function declaration, as these are equivalent to function-valued variable declarations.</span></li></ol><ol class="c25" start="2"><li class="c7 c2"><span>If </span><span class="c3">d</span><span> is a local variable or formal parameter then </span><span class="c3">e</span><span> evaluates to the current binding of </span><span class="c3">id.</span><span>  </span><span class="c11">This case also applies if </span><span class="c11 c3">d</span><span class="c11"> is a local function declaration, as these are equivalent to function-valued variable declarations.</span></li></ol><ol class="c25" start="1"><li class="c7 c2"><span>If </span><span class="c3">d</span><span> is a static method, then </span><span class="c3">e</span><span> evaluates to the function defined by </span><span class="c3">d.</span></li><li class="c7 c2"><span>If </span><span class="c3">d</span><span> is the declaration of a static variable or static getter declared in class </span><span class="c3">C,</span><span> then </span><span class="c3">e</span><span> is equivalent to the </span><span class="c1"><a class="c8" href="#id.lharm2td3qkb">getter invocation</a></span><span> </span><span class="c3">C.id. </span></li><li class="c7 c2"><span>If </span><span class="c3">d</span><span> is the declaration of a top level getter, then </span><span class="c3">e</span><span> is equivalent to the </span><span class="c1"><a class="c8" href="#id.lharm2td3qkb">getter invocation</a></span><span> </span><span class="c3">id. </span></li><li class="c7 c2"><span>Otherwise </span><span class="c3">e</span><span> is equivalent to the </span><span class="c1"><a class="c8" href="#id.hu9dfddw6bhy">property extraction</a></span><span>  </span><span class="c5 c6">this</span><span class="c3">.id. </span></li></ol><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><a href="#" name="id.8l84oujmjm7p"></a><h3 class="c2"><a name="h.x0ar1hv8tolv"></a><span>Type Test</span></h3><p class="c2 c4"><span></span></p><p class="c2"><span>The </span><span class="c3">is-expression</span><span> tests if an object is a member of a type.</span></p><p class="c2 c4"><span></span></p><a href="#" name="id.j4kla99osbuu"></a><p class="c2"><span class="c5 c3">isOperator:</span><span class="c3"><br></span><span class="c5 c6">is</span><span class="c3"> </span><span class="c3">&#39;!&#39;</span><span class="c3">?<br>    ;<br></span></p><p class="c2"><span>Evaluation of the is-expression </span><span class="c3">e</span><span> </span><span class="c5 c6">is</span><span> </span><span class="c3">T</span><span> proceeds as follows:</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>The expression </span><span class="c3">e</span><span> is evaluated to a value </span><span class="c3">v.</span><span> Then, if the interface induced by the class of </span><span class="c3">v</span><span> is a subtype of </span><span class="c3">T,</span><span> the is-expression evaluates to </span><span class="c5 c6">true.</span><span> Otherwise it evaluates to </span><span class="c5 c6">false.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c11">It follows that </span><span class="c11 c3 c6">e</span><span class="c11 c6"> </span><span class="c5 c11 c6">is</span><span class="c11 c6"> </span><span class="c11 c6">Object</span><span class="c11"> is always true. This makes sense in a language where everything is an object. </span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span class="c11">Also note that </span><span class="c5 c11">null</span><span class="c11"> </span><span class="c5 c11 c6">is</span><span class="c11 c6"> </span><span class="c11 c3 c6">T</span><span class="c11 c6"> </span><span class="c11">is false unless </span><span class="c11 c3">T = </span><span class="c11 c6">Object</span><span class="c11">, </span><span class="c11 c3">T = </span><span class="c11 c6">Dynamic </span><span class="c11">or </span><span class="c11 c3">T = </span><span class="c11 c6">Null</span><span class="c11">. Since the class Null is not exported by the core library, the latter will not occur in user code. The former is useless, as is anything of the form </span><span class="c11 c3 c6">e</span><span class="c11 c6"> </span><span class="c5 c11 c6">is</span><span class="c11 c6"> Object.</span><span class="c11">  Users should test for a null value directly rather than via a type test on </span><span class="c11 c6">Object</span><span class="c11">.</span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span>The is-expression </span><span class="c3">e</span><span> </span><span class="c5 c6">is!</span><span> </span><span class="c3">T</span><span> is equivalent to the expression </span><span class="c6">!(</span><span class="c3 c6">e</span><span class="c6"> </span><span class="c5 c6">is</span><span class="c6"> </span><span class="c3 c6">T</span><span class="c6">).</span></p><p class="c2"><span>It is a run-time error if </span><span class="c3">T</span><span> does not denote a type available in the current lexical scope. It is a compile-time error if </span><span class="c3">T </span><span>is a parameterized type of the form </span><span class="c3">G&lt;T</span><span class="c9 c3">1</span><span class="c3">, .., T</span><span class="c9 c3">n</span><span class="c3">&gt;</span><span> and </span><span class="c3">G</span><span> is not a generic type with </span><span class="c3">n</span><span> type parameters.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Note, that, in checked mode, it is a dynamic type error if a malformed typed is used in a type test as specified </span><span class="c1"><a class="c8" href="#id.xmnezjjgjrld">below</a></span><span>.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>It is a static warning if </span><span class="c3">T</span><span> does not denote a type available in the current lexical scope. The static type of an is-expression is </span><span class="c6">bool.</span></p><p class="c2 c4"><span class="c19 c6"></span></p><a href="#" name="id.u641de9n8yy"></a><h2 class="c2"><a name="h.hqr7euivxf2k"></a><span>Statements</span></h2><p class="c2 c4"><span></span></p><a href="#" name="id.mfp056u1wxhj"></a><p class="c2"><span class="c5 c3">statements:</span><span class="c3"><br>      statement*<br>    ;<br></span></p><p class="c2 c4"><span class="c3"></span></p><a href="#" name="id.qxr443r6wu5w"></a><p class="c2"><span class="c5 c3">statement:</span><span class="c3"><br>      label* nonLabelledStatement<br>    ;<br><br></span><a href="#" name="id.2dzd2wull4bz"></a><span class="c5 c3">nonLabelledStatement:</span><span class="c3"><br>      </span><span class="c0"><a class="c8" href="#kix.kx7urn183i41">block</a></span><span class="c3"> </span></p><p class="c2"><span class="c3">    | initializedVariableDeclaration &#39;;&#39;<br>    | </span><span class="c0"><a class="c8" href="#id.j9iezeasgfnv">forStatement</a></span></p><p class="c2"><span class="c3">    | </span><span class="c0"><a class="c8" href="#id.b80lsgnffs3l">whileStatement</a></span><span class="c3"><br>    | </span><span class="c0"><a class="c8" href="#id.kghbfwy46xn3">doStatement</a></span><span class="c3"><br>    | </span><span class="c0"><a class="c8" href="#id.24iylhdjyza7">switchStatement</a></span></p><p class="c2"><span class="c3">    | </span><span class="c0"><a class="c8" href="#id.vkbrdfhx12yq">ifStatement</a></span><span class="c3"><br>    | </span><span class="c0"><a class="c8" href="#id.oz9orks2j6lc">tryStatement</a></span><span class="c3"><br>    | </span><span class="c0"><a class="c8" href="#id.xweryammo2zi">breakStatement</a></span><span class="c3"><br>    | </span><span class="c0"><a class="c8" href="#id.ia1g5wsdvip7">continueStatement</a></span></p><p class="c2"><span class="c3">    | </span><span class="c0"><a class="c8" href="#id.vdmucwmxk5sb">returnStatement</a></span><span class="c3"><br>    | </span><span class="c0"><a class="c8" href="#id.dllqbk7mcu19">throwStatement</a></span><span class="c3"><br>    | </span><span class="c0"><a class="c8" href="#id.g07b8yer9ws5">expressionStatement</a></span><span class="c3"><br>    | </span><span class="c0"><a class="c8" href="#id.rszxnavlorex">assertStatement</a></span><span class="c3"><br>    | functionSignature functionBody<br>    ;<br></span></p><p class="c2 c4"><span class="c3"></span></p><h3 class="c2"><a name="h.cl7xuoqlaaeh"></a><span>Blocks</span></h3><p class="c2 c4"><span></span></p><p class="c2"><span>A block statement supports sequencing of code.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Execution of a block statement </span><span class="c3">{s</span><span class="c9 c3">1</span><span class="c3"> …  s</span><span class="c9 c3">n</span><span class="c3">}</span><span> proceeds as follows:</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>For </span><span class="c3">i = 1 .. n,</span><span> </span><span class="c3">s</span><span class="c9 c3">i</span><span class="c9"> </span><span>is executed.</span></p><p class="c2 c4"><span></span></p><h3 class="c2"><a name="h.xqzpebdcgm4"></a><span>Expression Statements</span></h3><p class="c2 c4"><span></span></p><p class="c2"><span>An expression statement consists of an expression. </span></p><p class="c2 c4"><span></span></p><a href="#" name="id.g07b8yer9ws5"></a><p class="c2"><span class="c5 c3">expressionStatement:</span></p><p class="c2"><span class="c3">  </span><span class="c0"><a class="c8" href="#id.1u3vxuwrz6py">expression</a></span><span class="c3">? &#39;;&#39;<br></span></p><p class="c2"><span>Execution of an expression statement </span><span class="c3 c6">e</span><span class="c6">; </span><span>proceeds by evaluating </span><span class="c3">e.</span><span> <br></span><span class="c3"><br></span></p><a href="#" name="id.pj2yk2bhjoki"></a><h3 class="c2"><a name="h.w2e1gboc13um"></a><span>Variable Declaration</span></h3><p class="c2 c4"><span></span></p><p class="c2"><span>A </span><span class="c3">variable declaration statement</span><span> declares a new local variable.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>A variable declaration statement </span><span class="c3">T id;</span><span> or </span><span class="c3">T id = e;</span><span> </span><span>introduces a new variable </span><span class="c3">id</span><span> with static type </span><span class="c3">T</span><span> into the innermost enclosing scope</span><span>. A variable declaration statement </span><span class="c5 c6">var</span><span class="c3"> id;</span><span> or </span><span class="c5 c6">var</span><span class="c3"> id = e;</span><span> introduces a new variable named </span><span class="c3">id</span><span> with static type Dynamic into the innermost enclosing scope.</span></p><p class="c2"><span>In all cases, iff the variable declaration is prefixed with either the </span><span class="c5 c6">const</span><span>  or the </span><span class="c5 c6">final</span><span> modifier, the variable is marked as final. and iff the variable declaration is prefixed with the </span><span class="c5 c6">const</span><span>  modifier, the variable is marked as constant. </span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Executing a variable declaration statement </span><span class="c3">T id = e; </span><span>is equivalent to evaluating the assignment expression </span><span class="c3">id = e</span><span>, except that the assignment is considered legal even if the variable is final.   </span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c11">However, it is still illegal to assign to a final variable from within its initializer.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>A variable declaration statement of the form </span><span class="c3">T id;</span><span> is equivalent to </span><span class="c3">T id = null;</span><span>.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c11">This holds regardless of the type T. For example,</span><span class="c11 c6"> int i;</span><span class="c11"> does not cause </span><span class="c11 c6">i</span><span class="c11"> to be initialized to zero. Instead, </span><span class="c11 c6">i</span><span class="c11"> is initialized to </span><span class="c5 c11 c6">null</span><span class="c11">, just as if we had written </span><span class="c5 c11 c6">var</span><span class="c11 c6"> i;</span><span class="c11"> or </span><span class="c11 c6">Object i;</span><span class="c11"> or </span><span class="c11 c6">Collection&lt;String&gt; i;</span></p><p class="c2"><span class="c3 c14">To do otherwise would undermine the optionally typed nature of Dart, causing type annotations to modify program behavior.</span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><a href="#" name="id.bi8elx882av"></a><h3 class="c2"><a name="h.e62bkwgzzagn"></a><span>If</span></h3><p class="c2 c4"><span></span></p><p class="c2"><span>The </span><span class="c3">if statement</span><span> allows for conditional execution of statements.</span></p><p class="c2 c4"><span></span></p><a href="#" name="id.vkbrdfhx12yq"></a><p class="c2"><span class="c5 c3">ifStatement:</span><span class="c3"><br>      </span><span class="c5 c6">if</span><span class="c3"> &#39;(&#39; </span><span class="c0"><a class="c8" href="#id.1u3vxuwrz6py">expression</a></span><span class="c3"> &#39;)&#39; </span><span class="c0"><a class="c8" href="#id.qxr443r6wu5w">statement</a></span><span class="c3"> (</span><span class="c5 c6">else</span><span class="c3"> </span><span class="c0"><a class="c8" href="#id.qxr443r6wu5w">statement</a></span><span class="c3">)?<br>    ;<br></span></p><p class="c2"><span>Execution of an if statement of the form </span><span class="c5 c6">if</span><span class="c6">(</span><span class="c3">b</span><span class="c6">)</span><span class="c3"> s</span><span class="c9 c3">1</span><span class="c3"> </span><span class="c5 c6">else</span><span class="c6"> </span><span class="c3">s</span><span class="c9 c5 c3">2</span><span> proceeds as follows:</span></p><p class="c2"><span class="c3"> </span></p><p class="c2"><span>First, the expression </span><span class="c3">b </span><span>is evaluated to</span><span> </span><span>an object </span><span class="c3">o.</span><span> In checked mode, it is a dynamic type error if </span><span class="c3">o </span><span>is not of type </span><span class="c6">bool. </span><span>Otherwise, </span><span class="c3">o</span><span> is</span><span> then subjected to </span><span class="c1"><a class="c8" href="#id.luoug0f1vx2f">boolean conversion</a></span><span>, producing an object </span><span class="c3">r</span><span>. </span><span class="c3"> </span><span>If </span><span class="c3">r </span><span>is </span><span class="c5 c6">true</span><span>, then the statement </span><span class="c3">s</span><span class="c9 c3">1</span><span> is executed, otherwise statement </span><span class="c3">s</span><span class="c9 c3">2</span><span> is executed.</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span class="c3"> </span><span>It is a static type warning if the type of the expression </span><span class="c3">b</span><span> may not be assigned to bool. </span><span class="c3"> </span></p><p class="c2"><span class="c3">  </span></p><p class="c2"><span> An if statement of the form  </span><span class="c5 c6">if</span><span> </span><span class="c6">(</span><span class="c3">b</span><span class="c6">)</span><span class="c3"> s</span><span class="c9 c3">1</span><span> is equivalent to the if statement </span><span class="c5 c6">if</span><span class="c6">(</span><span class="c3">b</span><span class="c6">)</span><span class="c3"> s</span><span class="c9 c3">1</span><span class="c3"> </span><span class="c5 c6">else</span><span class="c6"> {}</span><span class="c3">.</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><a href="#" name="id.nleo13o1ua6q"></a><h3 class="c2"><a name="h.phf2izoilhq7"></a><span>For</span></h3><p class="c2 c4"><span></span></p><p class="c2"><span>The </span><span class="c3">for statement </span><span>supports iteration.</span></p><p class="c2 c4"><span></span></p><a href="#" name="id.j9iezeasgfnv"></a><p class="c2"><span class="c5 c3">forStatement:</span><span class="c3"><br>     </span><span class="c5 c6">for</span><span class="c3"> &#39;(&#39; forLoopParts &#39;)&#39; </span><span class="c0"><a class="c8" href="#id.qxr443r6wu5w">statement</a></span><span class="c3"><br>    ;</span></p><p class="c2"><span class="c3"><br></span><a href="#" name="id.ucs74xojg1ca"></a><span class="c5 c3">forLoopParts:</span><span class="c3"><br>      forInitializerStatement </span><span class="c0"><a class="c8" href="#id.1u3vxuwrz6py">expression</a></span><span class="c3">? &#39;;&#39; expressionList?<br>    | </span><span class="c1 c3"><a class="c8" href="#id.2xe95ykmes0u">declaredIdentifier</a></span><span class="c3"> </span><span class="c5 c6">in</span><span class="c3"> </span><span class="c0"><a class="c8" href="#id.1u3vxuwrz6py">expression</a></span><span class="c3"><br>    | </span><span class="c0"><a class="c8" href="#id.te0njh1fhw7g">identifier</a></span><span class="c3"> </span><span class="c5 c6">in</span><span class="c3"> </span><span class="c0"><a class="c8" href="#id.1u3vxuwrz6py">expression</a></span><span class="c3"><br>    ;<br><br></span><a href="#" name="id.318qfu71lbqa"></a><span class="c5 c3">forInitializerStatement:</span><span class="c3"><br>      initializedVariableDeclaration &#39;;&#39;<br>    | </span><span class="c0"><a class="c8" href="#id.1u3vxuwrz6py">expression</a></span><span class="c3">? &#39;;&#39;<br>    ;</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span>The for statement has two forms - the traditional for loop and the foreach statement.</span></p><p class="c2 c4"><span></span></p><a href="#" name="id.7ych0h3g6q1o"></a><h4 class="c2"><a name="h.30cq61pcbhlr"></a><span>For Loop</span></h4><p class="c2 c4"><span></span></p><p class="c2"><span>Execution of a for statement of the form  </span><span class="c5 c6">for</span><span class="c6"> (</span><span class="c5 c6">var</span><span class="c3 c6"> v = e</span><span class="c9 c3 c6">0 </span><span class="c3 c6">; c e</span><span class="c6">) </span><span class="c3 c6">s</span><span> proceeds as follows:</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>If </span><span class="c3">c</span><span> is empty let </span><span class="c3">c’</span><span> be true, otherwise let </span><span class="c3">c’</span><span> be </span><span class="c3">c. </span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span>First the variable declaration statement </span><span class="c5 c6">var</span><span class="c3 c6"> v = e</span><span class="c9 c3 c6">0 </span><span> is executed. Then:</span></p><ol class="c26" start="1"><li class="c7 c2"><span>If this is the first iteration of the for loop, let </span><span class="c3">v’</span><span> be </span><span class="c3">v.</span><span> Otherwise,  let </span><span class="c3">v’</span><span> be the variable </span><span class="c3">v’’</span><span> created in the previous execution of step 4.</span></li><li class="c7 c2"><span>The expression </span><span class="c3">[v’/v]c</span><span> is evaluated and subjected to boolean conversion. If the result is </span><span class="c5 c6">false</span><span>, the for loop completes. Otherwise, execution continues at step 3.</span></li><li class="c7 c2"><span>The statement </span><span class="c3">[v’/v]s</span><span> is executed.</span></li><li class="c7 c2"><span>Let v’’ be a fresh variable.  v’’ is bound to the value of v’.</span></li><li class="c7 c2"><span>The expression [v’’/v]e is evaluated, and the process recurses at step 1.</span></li></ol><p class="c2 c4"><span></span></p><p class="c2"><span class="c3 c14">The definition above is intended to prevent the common error where users create a closure inside a for loop, intending to close over the current binding of the loop variable, and find (usually after a painful process of debugging and learning) that all the created closures have captured the same value - the one current in the last iteration executed.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c3 c14">Instead, each iteration has its own distinct variable.  The first iteration uses the variable created by the initial declaration. The expression executed at the end of each iteration uses a fresh variable v’’, bound to the value of the current iteration variable, and then modifies $v’’ as required for the next iteration.</span></p><p class="c2 c4"><span></span></p><a href="#" name="id.w7rqryp9rxgm"></a><h4 class="c2"><a name="h.7l7e185heu0v"></a><span>Foreach</span></h4><p class="c2"><span>A for statement of the form  </span><span class="c5 c6">for</span><span class="c6"> (</span><span class="c3 c6">finalConstVarOrType</span><span class="c6"> id </span><span class="c5 c6">in</span><span class="c6"> </span><span class="c3 c6">e</span><span class="c6">) </span><span class="c3 c6">s</span><span> is equivalent to the following code:</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c6">var n0 = e.iterator();</span></p><p class="c2"><span class="c5 c6">while</span><span class="c6"> (n0.hasNext()) {</span></p><p class="c2"><span class="c6">   </span><span class="c3 c6">finalConstVarOrType</span><span class="c5 c6"> </span><span class="c6">id = n0.next();</span></p><p class="c2"><span class="c6">   s</span></p><p class="c2"><span class="c6">}</span></p><p class="c2"><span>where </span><span class="c6">n0</span><span> is an identifier that does not occur anywhere in the program.<br></span></p><a href="#" name="id.e6iow4tlr5al"></a><h3 class="c2"><a name="h.4t8k3tvkyul3"></a><span>While</span></h3><p class="c2 c4"><span></span></p><p class="c2"><span>The </span><span class="c3">while statement</span><span> supports conditional iteration, where the condition is evaluated prior to the loop.</span></p><p class="c2 c4"><span></span></p><a href="#" name="id.b80lsgnffs3l"></a><p class="c2"><span class="c5 c3">whileStatement:</span><span class="c3"><br>      </span><span class="c5 c6">while</span><span class="c3"> &#39;(&#39; </span><span class="c0"><a class="c8" href="#id.1u3vxuwrz6py">expression</a></span><span class="c3"> &#39;)&#39; </span><span class="c0"><a class="c8" href="#id.qxr443r6wu5w">statement</a></span><span class="c3">  </span></p><p class="c2"><span class="c3">;</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span>Execution of a while statement of the form </span><span class="c5 c6">while</span><span class="c3"> </span><span class="c6">(</span><span class="c3">e</span><span class="c6">)</span><span class="c3"> s</span><span class="c6">;</span><span> proceeds as follows: </span></p><p class="c2 c4"><span></span></p><p class="c2"><span>The expression </span><span class="c3">e</span><span> is evaluated to an object </span><span class="c3">o.</span><span> In checked mode, it is a dynamic type error if </span><span class="c3">o </span><span>is not of type </span><span class="c6">bool. </span><span>Otherwise, </span><span class="c3">o</span><span class="c6"> </span><span>is subjected to </span><span class="c1"><a class="c8" href="#id.luoug0f1vx2f">boolean conversion</a></span><span>, producing an object </span><span class="c3">r</span><span>.  If </span><span class="c3">r</span><span> is </span><span class="c5 c6">true</span><span>, then </span><span class="c3">s</span><span> is executed and then the while statement is re-executed recursively. If </span><span class="c3">r</span><span> is </span><span class="c5 c6">false</span><span>, execution of the while statement is complete.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>It is a static type warning if the type of </span><span class="c3">e </span><span>may not be assigned to </span><span class="c6">bool.</span><span> </span></p><p class="c2"><span> </span></p><a href="#" name="id.17r82ed5p6yq"></a><h3 class="c2"><a name="h.vj4ainfqsbwg"></a><span>Do</span></h3><p class="c2 c4"><span></span></p><p class="c2"><span>The </span><span class="c3">do statement</span><span> supports conditional iteration, where the condition is evaluated after the loop.</span></p><p class="c2 c4"><span></span></p><a href="#" name="id.kghbfwy46xn3"></a><p class="c2"><span class="c5 c3">doStatement:</span><span class="c3"><br>    </span><span class="c5 c6">do</span><span class="c3"> </span><span class="c0"><a class="c8" href="#id.qxr443r6wu5w">statement</a></span><span class="c3"> </span><span class="c5 c6">while</span><span class="c3"> &#39;(&#39; </span><span class="c0"><a class="c8" href="#id.1u3vxuwrz6py">expression</a></span><span class="c3"> &#39;)&#39; &#39;;&#39;<br>      ;<br></span></p><p class="c2"><span>Execution of a do statement of the form </span><span class="c5 c6">do</span><span class="c3"> s </span><span class="c5 c6">while</span><span class="c3"> </span><span class="c6">(</span><span class="c3">e</span><span class="c6">);</span><span> proceeds as follows: </span></p><p class="c2 c4"><span></span></p><p class="c2"><span>The statement s is executed. Then, the expression </span><span class="c3">e</span><span> is evaluated to an object </span><span class="c3">o.</span><span> In checked mode, it is a dynamic type error if </span><span class="c3">o </span><span>is not of type </span><span class="c6">bool. </span><span>Otherwise, </span><span class="c3">o</span><span class="c6"> </span><span>is then subjected to </span><span class="c1"><a class="c8" href="#id.luoug0f1vx2f">boolean conversion</a></span><span>, producing an object </span><span class="c3">r</span><span>. If </span><span class="c3">r</span><span> is </span><span class="c5 c6">false</span><span>, execution of the do statement is complete. If </span><span class="c3">r</span><span> is </span><span class="c5 c6">true</span><span>, then the do statement is re-executed recursively. </span></p><p class="c2 c4"><span></span></p><p class="c2"><span>It is a static type warning if the type of </span><span class="c3">e </span><span>not be assigned to </span><span class="c6">bool.</span><span>  </span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><a href="#" name="id.9tgfidrdlcan"></a><h3 class="c2"><a name="h.50ae78s6gbw2"></a><span>Switch</span></h3><p class="c2 c4"><span></span></p><p class="c2"><span>The </span><span class="c3">switch statement</span><span> supports dispatching control among a large number of cases.</span></p><p class="c2 c4"><span></span></p><a href="#" name="id.24iylhdjyza7"></a><p class="c2"><span class="c5 c3">switchStatement:</span><span class="c3"><br>      </span><span class="c5 c6">switch</span><span class="c3"> &#39;(&#39; </span><span class="c0"><a class="c8" href="#id.1u3vxuwrz6py">expression</a></span><span class="c3"> &#39;)&#39; &#39;{&#39; switchCase* defaultCase? &#39;}&#39;<br>    ;<br></span></p><p class="c2 c4"><span></span></p><a href="#" name="id.meo5bc6x9a9k"></a><p class="c2"><span class="c5 c3">switchCase:</span><span class="c3"><br>      label? (</span><span class="c5 c6">case</span><span class="c3"> </span><span class="c0"><a class="c8" href="#id.k68gukuq6cj9">expression</a></span><span class="c3"> &#39;:&#39;)+ </span><span class="c0"><a class="c8" href="#id.mfp056u1wxhj">statements</a></span><span class="c3"><br>    ;<br><br></span><a href="#" name="id.btml234onbwc"></a><span class="c5 c3">defaultCase:</span><span class="c3"><br>      label? (</span><span class="c5 c6">case</span><span class="c3"> </span><span class="c0"><a class="c8" href="#id.1u3vxuwrz6py">expression</a></span><span class="c3"> &#39;:&#39;)* </span><span class="c5 c6">default</span><span class="c3"> &#39;:&#39; </span><span class="c0"><a class="c8" href="#id.mfp056u1wxhj">statements</a></span><span class="c3"><br>    ;<br></span></p><p class="c2"><span>Execution of a switch statement </span><span class="c5 c6">switch</span><span class="c6"> (</span><span class="c3 c6">e</span><span class="c6">) { </span><span class="c5 c6">case</span><span class="c6"> </span><span class="c3 c6">e</span><span class="c9 c3 c6">1</span><span class="c6">: </span><span class="c3 c6">s</span><span class="c9 c3 c6">1</span><span class="c6"> … </span><span class="c5 c6">case</span><span class="c6"> </span><span class="c3 c6">e</span><span class="c9 c3 c6">n</span><span class="c6">: </span><span class="c3 c6">s</span><span class="c9 c3 c6">n</span><span class="c6"> </span><span class="c5 c6">default:</span><span class="c6"> </span><span class="c3 c6">s</span><span class="c9 c3 c6">n+1</span><span class="c6">}</span><span> proceeds as follows:</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>The statement </span><span class="c5 c6">var</span><span class="c6"> </span><span class="c3 c6">n</span><span class="c6"> = </span><span class="c3 c6">e</span><span class="c6">;</span><span> is evaluated, where </span><span class="c3">n</span><span> is a variable whose name is distinct from any other variable in the program.  Next, the case clause </span><span class="c5 c6">case</span><span class="c6"> </span><span class="c3 c6">e</span><span class="c9 c3 c6">1</span><span class="c6">: </span><span class="c3 c6">s</span><span class="c9 c3 c6">1</span><span> is executed if it exists. If </span><span class="c5 c6">case</span><span class="c6"> </span><span class="c3 c6">e</span><span class="c9 c3 c6">1</span><span class="c6">: </span><span class="c3 c6">s</span><span class="c9 c3 c6">1 </span><span>does not exist, then the default clause is executed by executing </span><span class="c3 c6">s</span><span class="c9 c3 c6">n+1</span><span class="c3 c6">.</span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Execution of a </span><span class="c5 c6">case</span><span> clause </span><span class="c5 c6">case</span><span class="c6"> </span><span class="c3 c6">e</span><span class="c9 c3 c6">k</span><span class="c6">: </span><span class="c3 c6">s</span><span class="c9 c3 c6">k</span><span class="c9 c6"> </span><span>of a</span><span> </span><span>switch statement </span><span class="c5 c6">switch</span><span class="c6"> (</span><span class="c3 c6">e</span><span class="c6">) { </span><span class="c5 c6">case</span><span class="c6"> </span><span class="c3 c6">e</span><span class="c9 c3 c6">1</span><span class="c6">: </span><span class="c3 c6">s</span><span class="c9 c3 c6">1</span><span class="c6"> … </span><span class="c5 c6">case</span><span class="c6"> </span><span class="c3 c6">e</span><span class="c9 c3 c6">n</span><span class="c6">: </span><span class="c3 c6">s</span><span class="c9 c3 c6">n</span><span class="c6"> </span><span class="c5 c6">default:</span><span class="c6"> </span><span class="c3 c6">s</span><span class="c9 c3 c6">n+1</span><span class="c6">} </span><span>proceeds as follows:</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>The expression </span><span class="c3 c6">e</span><span class="c9 c3 c6">k</span><span class="c6"> == </span><span class="c3 c6">n </span><span class="c9 c3 c6"> </span><span>is evaluated to a </span><span>value </span><span class="c3">v.</span><span> </span></p><p class="c2 c4"><span></span></p><p class="c2"><span>If </span><span class="c3">v</span><span> is </span><span class="c5 c6">false</span><span>, the following case,  </span><span class="c5 c6">case</span><span class="c6"> </span><span class="c3 c6">e</span><span class="c9 c3 c6">k+1</span><span class="c6">: </span><span class="c3 c6">s</span><span class="c9 c3 c6">k+1 </span><span>is executed if it exists. If </span><span class="c5 c6">case</span><span class="c6"> </span><span class="c3 c6">e</span><span class="c9 c3 c6">k+1</span><span class="c6">: </span><span class="c3 c6">s</span><span class="c9 c3 c6">k+1 </span><span>does not exist, then the </span><span class="c5 c6">default</span><span> clause is executed by executing </span><span class="c3 c6">s</span><span class="c9 c3 c6">n+1</span><span class="c3 c6">.</span></p><p class="c2"><span>If </span><span class="c3">v</span><span> is </span><span class="c5 c6">true</span><span>, then let </span><span class="c3">m</span><span> be the smallest non-negative integer such that </span><span class="c3">s</span><span class="c9 c3">k+m</span><span> is non-blank; the statement </span><span class="c3">s</span><span class="c9 c3">k+m</span><span> is executed.</span><span>  </span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c11">So, if </span><span class="c11 c3">s</span><span class="c9 c11 c3">k</span><span class="c11"> is non-blank, m = 0.  If the only non-blank statement is in the </span><span class="c5 c11 c6">default</span><span class="c11"> clause, then </span><span class="c11 c3">m = n + 1 - k. For example:</span></p><p class="c2 c4"><span class="c11 c3"></span></p><p class="c2"><span class="c16 c11 c6">main() {<br>  foo(message, value) {<br>    print(message);<br>    return value;<br>  }<br>  switch (1) {<br>    case foo(&#39;case 1&#39;, 1): // s1 is blank<br>    case foo(&#39;case 2&#39;, 2): // s2 is non-blank; m = 1<br>      print(&#39;hest&#39;);<br>  }<br>}<br><br></span><span class="c16 c11">Should print:</span><span class="c16 c11 c6"><br><br>case 1<br>hest</span></p><p class="c2 c4"><span class="c11 c3 c6"></span></p><p class="c2 c4"><span></span></p><p class="c2"><span>A switch statement </span><span class="c5 c6">switch</span><span class="c6"> (</span><span class="c3 c6">e</span><span class="c6">) { </span><span class="c5 c6">case</span><span class="c6"> </span><span class="c3 c6">e</span><span class="c9 c3 c6">1</span><span class="c6">: </span><span class="c3 c6">s</span><span class="c9 c3 c6">1</span><span class="c6"> … </span><span class="c5 c6">case</span><span class="c6"> </span><span class="c3 c6">e</span><span class="c9 c3 c6">n</span><span class="c6">: </span><span class="c3 c6">s</span><span class="c9 c3 c6">n</span><span class="c6">}</span><span> is equivalent to the switch statement </span><span class="c5 c6">switch</span><span class="c6"> (</span><span class="c3 c6">e</span><span class="c6">) { </span><span class="c5 c6">case</span><span class="c6"> </span><span class="c3 c6">e</span><span class="c9 c3 c6">1</span><span class="c6">: </span><span class="c3 c6">s</span><span class="c9 c3 c6">1</span><span class="c6"> … </span><span class="c5 c6">case</span><span class="c6"> </span><span class="c3 c6">e</span><span class="c9 c3 c6">n</span><span class="c6">: </span><span class="c3 c6">s</span><span class="c9 c3 c6">n</span><span class="c6"> </span><span class="c5 c6">default:</span><span class="c6"> </span><span class="c6">}</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>It is a static warning if the type of </span><span class="c3">e</span><span> may not be assigned to the type of </span><span class="c3">e</span><span class="c9 c3">k</span><span> for all 1 &lt;= </span><span class="c3">k</span><span> &lt;= </span><span class="c3">n</span><span>. </span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><a href="#" name="id.vlflmf5cnfa1"></a><h3 class="c2"><a name="h.jodos9r2r9lz"></a><span>Try</span></h3><p class="c2 c4"><span></span></p><p class="c2"><span>The </span><span class="c3">try statement</span><span> supports the definition of exception handling code in a structured way.</span></p><p class="c2 c4"><span></span></p><a href="#" name="id.oz9orks2j6lc"></a><p class="c2"><span class="c5 c3">tryStatement:</span><span class="c3"><br>      </span><span class="c5 c6">try</span><span class="c3"> </span><span class="c0"><a class="c8" href="#kix.kx7urn183i41">block</a></span><span class="c3"> (catchPart+ finallyPart? | finallyPart)<br>    ;<br><br></span><a href="#" name="id.d4869hyq37zh"></a><span class="c5 c3">catchPart:</span><span class="c3"><br>      </span><span class="c5 c6">catch</span><span class="c3"> &#39;(&#39; declaredIdentifier (&#39;,&#39; declaredIdentifier)? &#39;)&#39; </span><span class="c0"><a class="c8" href="#kix.kx7urn183i41">block</a></span><span class="c3"><br>    ;<br><br></span><a href="#" name="id.phpx3xnrkle9"></a><span class="c5 c3">finallyPart:</span><span class="c3"><br>      </span><span class="c5 c6">finally</span><span class="c3"> </span><span class="c0"><a class="c8" href="#kix.kx7urn183i41">block</a></span><span class="c3"><br>    ;<br></span></p><p class="c2"><span>A try statement consists of a block statement, followed by at least one of:</span></p><ol class="c26" start="1"><li class="c7 c2"><span>A set of </span><span class="c5 c6">catch</span><span> clauses, each of which specifies one or two exception parameters and a block statement.</span></li><li class="c7 c2"><span>A </span><span class="c5 c6">finally</span><span> clause, which consists of a block statement. </span></li></ol><p class="c2 c4"><span></span></p><p class="c2"><span>A </span><span class="c5 c6">catch</span><span> clause of one of the forms  </span><span class="c5 c6">catch</span><span class="c6"> (</span><span class="c3 c6">T</span><span class="c9 c3 c6">1</span><span class="c3 c6"> p</span><span class="c9 c3 c6">1</span><span class="c6">, </span><span class="c3 c6">T</span><span class="c9 c3 c6">2</span><span class="c3 c6"> p</span><span class="c9 c3 c6">2</span><span class="c6">) </span><span class="c3">s</span><span>, </span><span class="c5 c6">catch</span><span class="c6"> (</span><span class="c3 c6">T</span><span class="c9 c3 c6">1</span><span class="c3 c6"> p</span><span class="c9 c3 c6">1</span><span class="c6">, </span><span class="c5 c6">final</span><span class="c6"> </span><span class="c3 c6">p</span><span class="c9 c3 c6">2</span><span class="c6">) </span><span class="c3">s, </span><span class="c5 c6">catch</span><span class="c6"> (</span><span class="c3 c6">T</span><span class="c9 c3 c6">1</span><span class="c3 c6"> p</span><span class="c9 c3 c6">1</span><span class="c6">, </span><span class="c5 c6">final</span><span class="c6"> </span><span class="c3 c6">T</span><span class="c9 c3 c6">2</span><span class="c6"> </span><span class="c3 c6">p</span><span class="c9 c3 c6">2</span><span class="c6">) </span><span class="c3">s, </span><span class="c5 c6">catch</span><span class="c6"> (</span><span class="c3 c6">T</span><span class="c9 c3 c6">1</span><span class="c3 c6"> p</span><span class="c9 c3 c6">1</span><span class="c6">, </span><span class="c5 c6">var</span><span class="c3 c6"> p</span><span class="c9 c3 c6">2</span><span class="c6">) </span><span class="c3">s</span><span>, </span><span class="c5 c6">catch</span><span class="c6"> (</span><span class="c5 c6">final</span><span class="c6"> </span><span class="c3 c6">T</span><span class="c9 c3 c6">1</span><span class="c3 c6"> p</span><span class="c9 c3 c6">1</span><span class="c6">, </span><span class="c3 c6">T</span><span class="c9 c3 c6">2</span><span class="c3 c6"> p</span><span class="c9 c3 c6">2</span><span class="c6">) </span><span class="c3">s</span><span>, </span><span class="c5 c6">catch</span><span class="c6"> (</span><span class="c5 c6">final</span><span class="c6"> </span><span class="c3 c6">T</span><span class="c9 c3 c6">1</span><span class="c3 c6"> p</span><span class="c9 c3 c6">1</span><span class="c6">, </span><span class="c5 c6">final</span><span class="c6"> </span><span class="c3 c6">p</span><span class="c9 c3 c6">2</span><span class="c6">) </span><span class="c3">s, </span><span class="c5 c6">catch</span><span class="c6"> (</span><span class="c5 c6">final</span><span class="c3 c6">T</span><span class="c9 c3 c6">1</span><span class="c3 c6"> p</span><span class="c9 c3 c6">1</span><span class="c6">, </span><span class="c5 c6">final</span><span class="c6"> </span><span class="c3 c6">T</span><span class="c9 c3 c6">2</span><span class="c6"> </span><span class="c3 c6">p</span><span class="c9 c3 c6">2</span><span class="c6">) </span><span class="c3">s</span><span class="c6"> </span><span>or  </span><span class="c5 c6">catch</span><span class="c6"> (</span><span class="c5 c6">final </span><span class="c3 c6">T</span><span class="c9 c3 c6">1</span><span class="c3 c6"> p</span><span class="c9 c3 c6">1</span><span class="c6">, </span><span class="c5 c6">var</span><span class="c6"> </span><span class="c3 c6">p</span><span class="c9 c3 c6">2</span><span class="c6">) </span><span class="c3">s</span><span class="c6"> </span><span class="c3">matches</span><span> an object </span><span class="c3">o</span><span> if </span><span class="c3">o</span><span> is </span><span class="c5 c6">null</span><span> </span><span>or if the type of </span><span class="c3">o</span><span> is a </span><span class="c1"><a class="c8" href="#id.hiljskbmppmb">subtype</a></span><span> of </span><span class="c3">T</span><span class="c9 c3">1</span><span class="c3">.</span><span>  It is a compile-time error if </span><span class="c3">T</span><span class="c9 c3">1</span><span> does not denote a type available in the lexical scope of the catch clause.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>A </span><span class="c5 c6">catch</span><span> clause of one of the forms  </span><span class="c5 c6">catch</span><span class="c6"> (</span><span class="c5 c6">var</span><span class="c6"> </span><span class="c3 c6">p</span><span class="c9 c3 c6">1</span><span class="c6">, </span><span class="c3 c6">T p</span><span class="c9 c3 c6">2</span><span class="c6">) </span><span class="c3">s,  </span><span class="c5 c6">catch</span><span class="c6"> (</span><span class="c5 c6">var</span><span class="c6"> </span><span class="c3 c6">p</span><span class="c9 c3 c6">1</span><span class="c6">, </span><span class="c5 c6">final</span><span class="c6"> </span><span class="c3 c6">p</span><span class="c9 c3 c6">2</span><span class="c6">) </span><span class="c3">s</span><span>, </span><span class="c5 c6">catch</span><span class="c6"> (</span><span class="c5 c6">var</span><span class="c3 c6"> p</span><span class="c9 c3 c6">1</span><span class="c6">, </span><span class="c5 c6">final </span><span class="c3 c6">T</span><span class="c5 c6"> </span><span class="c6"> </span><span class="c3 c6">p</span><span class="c9 c3 c6">2 </span><span class="c6">)</span><span class="c3 c6"> s</span><span class="c6">, </span><span class="c5 c6"> catch</span><span class="c6"> (</span><span class="c5 c6">var</span><span class="c3 c6"> p</span><span class="c9 c3 c6">1</span><span class="c6">, </span><span class="c5 c6">var</span><span class="c6"> </span><span class="c3 c6">p</span><span class="c9 c3 c6">2</span><span class="c6">) </span><span class="c3">s, </span><span class="c5 c6"> catch</span><span class="c6"> (</span><span class="c5 c6">final</span><span class="c3 c6"> p</span><span class="c9 c3 c6">1</span><span class="c6">, </span><span class="c3 c6">T</span><span class="c6"> </span><span class="c3 c6">p</span><span class="c9 c3 c6">2</span><span class="c6">) </span><span class="c3">s, </span><span class="c5 c6">catch</span><span class="c6"> (</span><span class="c5 c6">final</span><span class="c3 c6"> p</span><span class="c9 c3 c6">1</span><span class="c6">, </span><span class="c5 c6">final</span><span class="c6"> </span><span class="c3 c6">p</span><span class="c9 c3 c6">2</span><span class="c6">) </span><span class="c3">s</span><span class="c6">, </span><span class="c5 c6">catch</span><span class="c6"> (</span><span class="c5 c6">final</span><span class="c3 c6"> p</span><span class="c9 c3 c6">1</span><span class="c6">, </span><span class="c5 c6">final</span><span class="c6"> </span><span class="c3 c6">T</span><span class="c6"> </span><span class="c3 c6">p</span><span class="c9 c3 c6">2</span><span class="c6">) </span><span class="c3">s </span><span>or  </span><span class="c5 c6">catch</span><span class="c6"> (</span><span class="c5 c6">final</span><span class="c6"> </span><span class="c3 c6">p</span><span class="c9 c3 c6">1</span><span class="c6">, </span><span class="c5 c6">var</span><span class="c6"> </span><span class="c3 c6">p</span><span class="c9 c3 c6">2</span><span class="c6">) always matches an object </span><span class="c3 c6">o.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c19">The definition below is an attempt to characterize exception handling without resorting to a normal/abrupt completion formulation. It has the advantage that one need not specify abrupt completion behavior for every compound statement.  On the other hand, it is new different and needs more thought.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>A try statement </span><span class="c5 c6">try</span><span class="c6"> </span><span class="c3 c6">s</span><span class="c9 c3 c6">1</span><span class="c6"> </span><span class="c3 c6">catch</span><span class="c9 c3 c6">1</span><span class="c6"> ... </span><span class="c3 c6">catch</span><span class="c9 c3 c6">n</span><span class="c6"> </span><span class="c5 c6">finally</span><span class="c6"> </span><span class="c3 c6">s</span><span class="c9 c3 c6">f  </span><span>defines an exception handler </span><span class="c3">h</span><span> that executes as follows:</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>The catch clauses are examined in order, starting with </span><span class="c3">catch</span><span class="c9 c3">1</span><span>, until either a catch clause that </span><span>matches</span><span> the current exception is found, or the list of catch clauses has been exhausted. If a catch clause </span><span class="c3">catch</span><span class="c9 c3">k </span><span>is found, then </span><span class="c3">p</span><span class="c9 c3">k1</span><span> is bound to the current exception, </span><span> </span><span class="c3">p</span><span class="c9 c3">k2</span><span> is bound to the current stack trace, and then </span><span class="c3">catch</span><span class="c9 c3">k</span><span> is executed. If no catch clause is found, the </span><span class="c5 c6">finally</span><span> clause is executed. Then, execution resumes at the end of the try statement.</span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><p class="c2"><span>A </span><span class="c5 c6">finally</span><span> clause </span><span class="c5 c6">finally</span><span class="c6"> </span><span class="c3 c6">s </span><span>defines an exception handler </span><span class="c3">h</span><span> that executes by executing the </span><span class="c5 c6">finally</span><span> clause. Then, execution resumes at the end of the try statement.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Execution of a </span><span class="c5 c6">catch</span><span> clause </span><span class="c5 c6">catch</span><span class="c6"> (</span><span class="c3 c6">p</span><span class="c9 c3 c6">1</span><span class="c6">, </span><span class="c3 c6">p</span><span class="c9 c3 c6">2</span><span class="c6">) </span><span class="c3 c6">s</span><span> of a try statement </span><span class="c3">t</span><span> proceeds as follows: The statement </span><span class="c3">s</span><span> is executed in the dynamic scope of the exception handler </span><span>defined by the </span><span class="c5 c6">finally</span><span> clause of </span><span class="c3">t</span><span>. Then, the current exception and current stack trace both become </span><span>undefined.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Execution of a </span><span class="c5 c6">finally</span><span> clause </span><span class="c5 c6">finally</span><span class="c6"> </span><span class="c3 c6">s</span><span> of a try statement proceeds as follows: </span></p><p class="c2 c4"><span></span></p><p class="c2"><span>The statement </span><span class="c3">s</span><span> is executed. Then, if the current exception is defined, control is transferred to the nearest dynamically enclosing exception handler.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Execution of a try statement of the form </span><span class="c5 c6">try</span><span class="c6"> </span><span class="c3 c6">s</span><span class="c9 c3 c6">1</span><span class="c6"> </span><span class="c3 c6">catch</span><span class="c9 c3 c6">1</span><span class="c6"> ... </span><span class="c3 c6">catch</span><span class="c9 c3 c6">n</span><span class="c6"> </span><span class="c5 c6">finally</span><span class="c6"> </span><span class="c3 c6">s</span><span class="c9 c3 c6">f  </span><span>proceeds as follows:</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>The statement </span><span class="c3">s</span><span class="c9 c3">1</span><span> is executed in the dynamic scope of the exception handler defined by the try statement. Then, the </span><span class="c5 c6">finally</span><span> </span><span>clause is executed.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c11">Whether any of the </span><span class="c5 c11 c6">catch</span><span class="c11"> clauses is executed depends on whether a matching exception has been raised by</span><span class="c11"> </span><span class="c11 c3">s</span><span class="c9 c11 c3">1</span><span class="c11"> </span><span class="c11">(see the specification of the </span><span class="c5 c11 c6">throw</span><span class="c11"> statement). </span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span class="c11">If </span><span class="c11 c3">s</span><span class="c9 c11 c3">1</span><span class="c11"> has raised an exception, it will transfer control to the try statement’s handler, which will examine the </span><span class="c5 c11 c6">catch</span><span class="c11"> clauses in order for a match as specified above. If no matches are found, the handler will execute the </span><span class="c5 c11 c6">finally</span><span class="c11"> clause. </span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span class="c11">If a matching </span><span class="c5 c11 c6">catch</span><span class="c11"> was found, it will execute first, and then the </span><span class="c5 c11 c6">finally</span><span class="c11"> clause will be executed. </span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span class="c11">If an exception is raised during execution of a </span><span class="c5 c11 c6">catch</span><span class="c11"> clause, this will transfer control to the handler for the </span><span class="c5 c11 c6">finally</span><span class="c11"> clause, causing the </span><span class="c5 c11 c6">finally</span><span class="c11"> clause to execute in this case as well. </span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span class="c11">If no exception was raised, the </span><span class="c5 c11 c6">finally</span><span class="c11"> clause is also executed. Execution of the </span><span class="c5 c11 c6">finally</span><span class="c11"> clause could also raise an exception, which will cause transfer of control to the next enclosing handler. </span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><a href="#" name="id.963bggxlx5wo"></a><h3 class="c2"><a name="h.q1wj04wamlw9"></a><span>Return</span></h3><p class="c2 c4"><span></span></p><p class="c2"><span>The </span><span class="c3">return statement</span><span> returns a result to the caller of a function.</span></p><p class="c2 c4"><span></span></p><a href="#" name="id.vdmucwmxk5sb"></a><p class="c2"><span class="c5 c3">returnStatement:</span><span class="c3"><br>    </span><span class="c5 c6">return</span><span class="c3"> </span><span class="c0"><a class="c8" href="#id.1u3vxuwrz6py">expression</a></span><span class="c3">? &#39;;&#39;<br>    ;</span></p><p class="c2 c4"><span class="c6"></span></p><p class="c2"><span>Executing a return statement </span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c5 c6">return</span><span class="c6"> </span><span class="c3 c6">e</span><span class="c6">;</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>first causes evaluation of the expression </span><span class="c3">e,</span><span> producing an object </span><span class="c3">o.</span><span> Next, </span><span>control is transferred to the caller </span><span>of the current function activation, and the object </span><span class="c3">o</span><span> is provided to the caller as the result of the function call.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>It is a static type warning if the type of </span><span class="c3">e</span><span> may not be assigned to the declared return type of the immediately enclosing function. </span></p><p class="c2"><span>It is a compile-time error if a return statement of the form </span><span class="c5 c6">return </span><span class="c3 c6">e</span><span class="c6">;</span><span> appears in a </span><span class="c1"><a class="c8" href="#id.e2bn3056d7ls">generative constructor</a></span><span>.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c3 c14">It is quite easy to forget to add the factory prefix for a constructor, accidentally converting a factory into a generative constructor. The static checker may detect a type mismatch in some, but not all, of these cases. The rule above helps catch such errors, which can otherwise be very hard to recognize. There is no real downside to it, as returning a value from a generative constructor is meaningless.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Let </span><span class="c3">f</span><span> be the function immediately enclosing a return statement of the form </span><span class="c5 c6">return</span><span class="c6">;</span><span> It is a static warning if both of the following conditions hold:</span></p><ol class="c25" start="1"><li class="c7 c2"><span> </span><span class="c3">f</span><span> is not a generative constructor. </span></li><li class="c7 c2"><span>The return type of </span><span class="c3">f</span><span> may not be assigned to </span><span class="c5 c6">void.</span><span> </span></li></ol><p class="c2 c4"><span></span></p><p class="c2"><span class="c11">Hence, a static warning will not be issued if </span><span class="c11 c3">f</span><span class="c11"> has no declared return type, since</span><span> </span><span class="c11">the return type would be Dynamic and Dynamic may be assigned to void. However, any function that declares a return type must return an expression explicitly.</span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span class="c3 c14">This helps catch situations where users forget to return a value in a return statement.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>A return statement with no expression, </span><span class="c5 c6">return</span><span class="c6">;</span><span> </span><span>is executed by executing the statement </span><span class="c5 c6">return</span><span class="c6"> </span><span class="c5 c6">null</span><span class="c6">;</span><span> if it occurs inside a method, getter, setter or factory; otherwise, the return statement necessarily occurs inside a generative constructor, in which case it is executed by executing </span><span class="c5 c6">return</span><span class="c6"> </span><span class="c5 c6">this</span><span class="c6">;</span><span>.</span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c11">Despite the fact that </span><span class="c5 c11 c6">return</span><span class="c11 c6">;</span><span class="c11"> is executed as if by a </span><span class="c5 c11 c6">return </span><span class="c11 c3 c6">e</span><span class="c11 c6">;</span><span class="c11">, i</span><span class="c11">t is important to understand that it is </span><span class="c5 c11">not</span><span class="c11"> a static warning to include a statement of the form </span><span class="c5 c11 c6">return</span><span class="c11 c6">;</span><span class="c11"> in a generative constructor. The rules relate only to the specific syntactic form </span><span class="c5 c11 c6">return </span><span class="c11 c3 c6">e</span><span class="c11 c6">;.</span></p><p class="c2 c4"><span class="c11 c6"></span></p><p class="c2"><span class="c3 c14">The motivation for formulating </span><span class="c5 c3 c14 c6">return</span><span class="c3 c14 c6">; </span><span class="c3 c14">in this way stems from the basic requirement that all function invocations indeed return a value. Function invocations are expressions, and we cannot rely on a mandatory typechecker to always prohibit use of </span><span class="c5 c3 c14 c6">void</span><span class="c3 c14"> functions in expressions. Hence, a return statement must always return a value, even if no expression is specified.</span></p><p class="c2 c4"><span class="c3 c14"></span></p><p class="c2"><span class="c3 c14">The question then becomes, what value should a return statement return when no return expression is given. In a generative constructor, it is obviously the object being constructed (</span><span class="c5 c3 c14 c6">this</span><span class="c3 c14">). In void functions we use </span><span class="c5 c3 c14 c6">null</span><span class="c3 c14">. A void function is not expected to participate in an expression, which is why it is marked </span><span class="c5 c3 c14 c6">void</span><span class="c3 c14"> in the first place. Hence, this situation is a mistake which should be detected as soon as possible. The static rules help here, but if the code is executed, using </span><span class="c5 c3 c14 c6">null</span><span class="c3 c14"> leads to fast failure, which is desirable in this case. The same rationale applies for </span><span class="c3 c14">function bodies that do not contain a return statement at all</span><span class="c3 c14">.</span></p><p class="c2 c4"><span class="c6"></span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><a href="#" name="id.va601vsgef9n"></a><h3 class="c2"><a name="h.k6ffi6ql1tjy"></a><span>Labels</span></h3><p class="c2"><span>A </span><span class="c3">label </span><span>is an identifier followed by a colon. A </span><span class="c3">labeled statement</span><span> is a statement prefixed by a label </span><span class="c3">L. </span><span>  A </span><span class="c3">labeled case clause </span><span>is a case clause within a </span><span class="c1"><a class="c8" href="#id.9tgfidrdlcan">switch statement</a></span><span> prefixed by a label </span><span class="c3">L.</span></p><p class="c2"><span class="c3 c14">The sole role of labels is to provide targets for the </span><span class="c1 c3"><a class="c8" href="#id.jzvs6ynykd2x">break</a></span><span class="c3 c14"> and </span><span class="c1 c3"><a class="c8" href="#id.rmt74cjqdxyr">continue</a></span><span class="c3 c14"> statements.</span></p><p class="c2"><span class="c3"><br></span><a href="#" name="kix.3phuboy3max"></a><span class="c5 c3">label:</span><span class="c3"><br>      </span><span class="c0"><a class="c8" href="#id.te0njh1fhw7g">identifier</a></span><span class="c3"> &#39;:&#39;<br>    ;<br></span></p><p class="c2"><span>The semantics of a labeled statement </span><span class="c3">L: s</span><span> are identical to those of the statement </span><span class="c3">s</span><span>. The namespace of labels is distinct from the one used for types, functions and variables.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>The scope of a label that labels a statement </span><span class="c3">s</span><span> is </span><span class="c3">s. </span><span>The scope of a label that labels a case clause of a switch statement </span><span class="c3">s</span><span> is </span><span class="c3">s.</span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c3 c14">Labels should be avoided by programmers at all costs. The motivation for including labels in the language is primarily making Dart a </span><span class="c3 c14">better</span><span class="c3 c14"> target for code generation.</span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><a href="#" name="id.jzvs6ynykd2x"></a><h3 class="c2"><a name="h.s4y8w9w8zyl0"></a><span>Break</span></h3><p class="c2 c4"><span></span></p><p class="c2"><span>The </span><span class="c3">break statement</span><span> consists of the reserved word </span><span class="c5 c6">break</span><span> and an optional </span><span class="c1"><a class="c8" href="#id.va601vsgef9n">label</a></span><span>. </span></p><p class="c2 c4"><span></span></p><a href="#" name="id.xweryammo2zi"></a><p class="c2"><span class="c5 c3">breakStatement:</span><span class="c3"><br>     </span><span class="c5 c6">break</span><span class="c3"> </span><span class="c0"><a class="c8" href="#id.te0njh1fhw7g">identifier</a></span><span class="c3">? &#39;;&#39;<br>    ;<br></span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Let </span><span class="c3">s</span><span class="c9 c3">b</span><span> be a break statement. If </span><span class="c3">s</span><span class="c9 c3">b</span><span> is of the form </span><span class="c5 c6">break</span><span class="c6"> </span><span class="c3 c6">L</span><span class="c6">;</span><span> then let </span><span class="c3">s</span><span class="c9 c3">E</span><span> be the the innermost labeled statement with label </span><span class="c3">L</span><span> enclosing </span><span class="c3">s</span><span class="c9 c3">b</span><span class="c3">.</span><span> If </span><span class="c3">s</span><span class="c9 c3">b</span><span> is of the form </span><span class="c5 c6">break</span><span class="c6">; </span><span>then let </span><span class="c3">s</span><span class="c9 c3">E</span><span> be the the innermost  </span><span class="c1"><a class="c8" href="#id.17r82ed5p6yq">do</a></span><span>, </span><span class="c1"><a class="c8" href="#id.nleo13o1ua6q">for</a></span><span>, </span><span class="c1"><a class="c8" href="#id.9tgfidrdlcan">switch</a></span><span> or </span><span class="c1"><a class="c8" href="#id.e6iow4tlr5al">while</a></span><span> statement enclosing </span><span class="c3">s</span><span class="c9 c3">b</span><span class="c3">.</span><span> It is a compile-time error if no such statement </span><span class="c3">s</span><span class="c9 c3">E </span><span>exists within the innermost function in which </span><span class="c3">s</span><span class="c9 c3">b</span><span> occurs.  Furthermore, let </span><span class="c3">s</span><span class="c9 c3">1</span><span class="c3">... s</span><span class="c9 c3">n</span><span> be those try statements that are both enclosed in </span><span class="c3">s</span><span class="c9 c3">E</span><span> and that enclose </span><span class="c3">s</span><span class="c9 c3">b</span><span class="c3">,</span><span> and that have a </span><span class="c5 c6">finally</span><span> clause. Lastly, let </span><span class="c3">f</span><span class="c9 c3">j</span><span> be the </span><span class="c5 c6">finally</span><span> clause of </span><span class="c3">s</span><span class="c9 c3">j</span><span class="c3">, 1 &lt;= j &lt;= n. </span><span>  Executing </span><span class="c3">s</span><span class="c9 c3">b</span><span> first executes </span><span class="c3">f</span><span class="c9 c3">1</span><span class="c3"> ... f</span><span class="c9 c3">n</span><span> in innermost-clause-first order and then terminates</span><span> </span><span class="c3">s</span><span class="c9 c3">E</span><span class="c3">.</span><span> </span></p><p class="c2 c4"><span class="c19"></span></p><p class="c2 c4"><span></span></p><a href="#" name="id.rmt74cjqdxyr"></a><h3 class="c2"><a name="h.hkf3vffzbfy6"></a><span>Continue</span></h3><p class="c2 c4"><span></span></p><p class="c2"><span>The </span><span class="c3">continue statement</span><span> consists of the reserved word </span><span class="c5 c6">continue</span><span> and an optional </span><span class="c1"><a class="c8" href="#id.va601vsgef9n">label</a></span><span>. </span></p><p class="c2 c4"><span></span></p><a href="#" name="id.ia1g5wsdvip7"></a><p class="c2"><span class="c5 c3">continueStatement:</span><span class="c3"><br>    </span><span class="c5 c6">continue</span><span class="c3"> </span><span class="c0"><a class="c8" href="#id.te0njh1fhw7g">identifier</a></span><span class="c3">? &#39;;&#39;<br>        ;<br></span></p><p class="c2 c4"><span class="c19"></span></p><p class="c2"><span>Let </span><span class="c3">s</span><span class="c9 c3">c</span><span> be a continue statement. If </span><span class="c3">s</span><span class="c9 c3">c</span><span> is of the form </span><span class="c5 c6">continue</span><span class="c6"> </span><span class="c3 c6">L</span><span class="c6">;</span><span> then let </span><span class="c3">s</span><span class="c9 c3">E</span><span> be the the innermost labeled </span><span class="c1"><a class="c8" href="#id.17r82ed5p6yq">do</a></span><span>, </span><span class="c1"><a class="c8" href="#id.nleo13o1ua6q">for</a></span><span> or </span><span class="c1"><a class="c8" href="#id.e6iow4tlr5al">while</a></span><span> statement or case clause with label </span><span class="c3">L</span><span> that encloses </span><span class="c3">s</span><span class="c9 c3">c</span><span class="c3">.</span><span> If </span><span class="c3">s</span><span class="c9 c3">c</span><span> is of the form </span><span class="c5 c6">continue</span><span class="c6">; </span><span>then let </span><span class="c3">s</span><span class="c9 c3">E</span><span> be the the innermost  </span><span class="c1"><a class="c8" href="#id.17r82ed5p6yq">do</a></span><span>, </span><span class="c1"><a class="c8" href="#id.nleo13o1ua6q">for</a></span><span> or </span><span class="c1"><a class="c8" href="#id.e6iow4tlr5al">while</a></span><span> statement enclosing </span><span class="c3">s</span><span class="c9 c3">c</span><span class="c3">.</span><span> It is a compile-time error if no such statement or case clause </span><span class="c3">s</span><span class="c9 c3">E </span><span>exists within the innermost function in which </span><span class="c3">s</span><span class="c9 c3">c</span><span> occurs.  Furthermore, let </span><span class="c3">s</span><span class="c9 c3">1</span><span class="c3">... s</span><span class="c9 c3">n</span><span> be those try statements that are both enclosed in </span><span class="c3">s</span><span class="c9 c3">E</span><span> and that enclose </span><span class="c3">s</span><span class="c9 c3">c</span><span class="c3">,</span><span> and that have a </span><span class="c5 c6">finally</span><span> clause. Lastly, let </span><span class="c3">f</span><span class="c9 c3">j</span><span> be the </span><span class="c5 c6">finally</span><span> clause of </span><span class="c3">s</span><span class="c9 c3">j</span><span class="c3">, 1 &lt;= j &lt;= n. </span><span>  Executing </span><span class="c3">s</span><span class="c9 c3">c</span><span> first executes </span><span class="c3">f</span><span class="c9 c3">1</span><span class="c3"> ... f</span><span class="c9 c3">n</span><span> in innermost-clause-first order and then transfers control to </span><span class="c3">s</span><span class="c9 c3">E</span><span class="c3">.</span><span> </span></p><p class="c2 c4"><span class="c19"></span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><a href="#" name="id.2p1bowyir5aa"></a><h3 class="c2"><a name="h.lo4c3zw824l"></a><span>Throw</span></h3><p class="c2 c4"><span></span></p><p class="c2"><span>The </span><span class="c3">throw statement</span><span> is used to raise or re-raise an exception.</span></p><p class="c2 c4"><span></span></p><a href="#" name="id.dllqbk7mcu19"></a><p class="c2"><span class="c5 c3">throwStatement:</span><span class="c3"><br>     </span><span class="c5 c6">throw</span><span class="c3"> </span><span class="c0"><a class="c8" href="#id.1u3vxuwrz6py">expression</a></span><span class="c3">? &#39;;&#39;<br>    ;<br></span></p><p class="c2"><span>The </span><span class="c3">current exception</span><span> is the last unhandled exception thrown. The </span><span class="c3">current stack trace</span><span> is a record of all the function activations within the current isolate that had not completed execution at the point where the current exception was thrown. For each such function activation, the current stack trace includes the name of the function, the bindings of all its formal parameters, local variables and </span><span class="c5 c6">this,</span><span> and the position at which the function was executing</span><span>.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c11">The term </span><span class="c5 c11">position</span><span class="c11"> should not be interpreted as a line number, but rather as a precise position - the exact character index of the expression that raised the exception. </span></p><p class="c2 c4"><span class="c11 c3"></span></p><p class="c2"><span>Execution of a throw statement of the form </span><span class="c5 c6">throw</span><span> </span><span class="c3 c6">e </span><span class="c6">;</span><span> proceeds as follows:</span></p><p class="c2"><span>The expression </span><span class="c3">e</span><span> is evaluated </span><span>yielding a value </span><span class="c3">v</span><span class="c3">. </span><span>Then, control is transferred to the nearest dynamically enclosing </span><span class="c1"><a class="c8" href="#id.vlflmf5cnfa1">exception handler</a></span><span>, with the current exception set to </span><span class="c3">v</span><span> and the current stack trace set to the series of activations that led to execution of the current function.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c11">There is no requirement that the expression </span><span class="c11 c3">e</span><span class="c11"> evaluate to a special kind of exception or error object.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Execution of a statement of the form </span><span class="c5 c6">throw</span><span class="c6">;</span><span> proceeds as follows:</span></p><p class="c2"><span>Control is transferred to the nearest dynamically enclosing </span><span class="c1"><a class="c8" href="#id.vlflmf5cnfa1">exception handler</a></span><span>.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c11">No change is made to the current stack trace or the current exception.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>It is a compile-time error if a statement of the form </span><span class="c5 c6">throw</span><span class="c6">; </span><span>is not enclosed within a </span><span>catch</span><span> clause.</span></p><p class="c2 c4"><span class="c6"></span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2 c4"><span></span></p><a href="#" name="id.d0t8no72xrno"></a><h3 class="c2"><a name="h.cb5i0axenow6"></a><span>Assert</span></h3><p class="c2 c4"><span></span></p><p class="c2"><span>An assert statement is used to disrupt normal execution if a given boolean condition does not hold.</span></p><p class="c2 c4"><span></span></p><a href="#" name="id.rszxnavlorex"></a><p class="c2"><span class="c5 c3">assertStatement:</span><span class="c3"><br>   </span><span class="c5 c6">assert</span><span class="c3"> &#39;(&#39; </span><span class="c0"><a class="c8" href="#id.u42blbh7fdm7">conditionalExpression</a></span><span class="c3"> &#39;)&#39; &#39;;&#39;<br>      ;<br></span></p><p class="c2"><span>The assert statement has no effect in production mode. In checked mode, execution of an assert statement </span><span class="c5 c6">assert</span><span class="c6">(e);</span><span> </span><span>proceeds as follows:</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>The conditional expression </span><span class="c3">e</span><span> is evaluated to an object </span><span class="c3">o.</span><span> If the class of </span><span class="c3">o</span><span> is a subtype of </span><span class="c6">Function</span><span> then let </span><span class="c3">r</span><span> be the result of invoking </span><span class="c3">o</span><span> with no arguments. Otherwise, let </span><span class="c3">r</span><span> be </span><span class="c3">o.</span><span>  It is a dynamic error if </span><span class="c3">o</span><span> is not of type </span><span class="c6">bool </span><span>or of type </span><span class="c6">Function</span><span>, or if </span><span class="c3">r</span><span> is not of type </span><span class="c6">bool.</span><span>  If </span><span class="c3">r</span><span> is </span><span class="c5 c6">false</span><span class="c5">,</span><span> we say that the </span><span class="c3">assertion failed</span><span>. If </span><span class="c3">r</span><span> is </span><span class="c5 c6">true</span><span class="c5">,</span><span> we say that the </span><span class="c3">assertion succeeded</span><span>. If the assertion succeeded, execution of the assert statement is complete. If the assertion failed, an </span><span class="c6">AssertionError</span><span> is </span><span class="c1"><a class="c8" href="#id.2p1bowyir5aa">thrown</a></span><span>.</span></p><p class="c2 c4"><span class="c6"></span></p><p class="c2"><span> It is a static type warning if the type of </span><span class="c3">e</span><span> may not be assigned to either </span><span class="c6">bool</span><span> or </span><span class="c6">()</span><span class="c3"> →</span><span class="c6"> bool</span><span> </span></p><p class="c2 c4"><span class="c6"></span></p><p class="c2"><span class="c3 c14">Why is this a statement, not a built in function call? Because it is handled magically so it has no effect and </span><span class="c5 c3 c14">no overhead</span><span class="c3 c14"> in production mode. Also, in the absence of final methods. one could not prevent it being overridden (though there is no real harm in that). Overall, perhaps it could be defined as a function, and the overhead issue could be viewed as an optimization.</span></p><p class="c2 c4"><span class="c3 c14"></span></p><p class="c2"><span>If a lexically visible declaration named assert is in scope, an assert statement </span><span class="c5 c6">assert</span><span class="c6">(</span><span class="c3 c6">e)</span><span class="c6">;</span><span> is interpreted as an expression statement </span><span class="c6">(assert(e));</span><span class="c3 c14"> .</span></p><p class="c2 c4"><span class="c3 c14"></span></p><p class="c2"><span class="c3 c14">Since </span><span class="c5 c3 c14 c6">assert</span><span class="c3 c14"> is a built-in identifier, one might define a function or method with this name.</span></p><p class="c2"><span class="c3 c14">It is impossible to distinguish as </span><span class="c5 c3 c14 c6">assert</span><span class="c3 c14"> statement from a method invocation in such a situation. </span></p><p class="c2"><span class="c3 c14">One could choose to always interpret such code as an </span><span class="c5 c3 c14 c6">assert</span><span class="c3 c14"> statement. Or we could choose to give priority to any lexically visible user defined function.  The former can cause rather puzzling situations, e.g.,</span></p><p class="c2 c4"><span class="c3 c14"></span></p><p class="c2 c4"><span class="c19"></span></p><p class="c2"><span class="c14 c6">assert(bool b){print(&#39;My Personal Assertion $b&#39;);}</span></p><p class="c2 c4"><span class="c14 c6"></span></p><p class="c2"><span class="c14 c6"> assert_puzzler() {</span></p><p class="c2"><span class="c14 c6">   (assert(</span><span class="c5 c14 c6">true</span><span class="c14 c6">)); // prints true</span></p><p class="c2"><span class="c14 c6">   </span><span class="c5 c14 c6">assert</span><span class="c14 c6">(</span><span class="c5 c14 c6">true</span><span class="c14 c6">); // would do nothing</span></p><p class="c2"><span class="c14 c6">   (assert(</span><span class="c5 c14 c6">false</span><span class="c14 c6">)); // prints false</span></p><p class="c2"><span class="c14 c6">   </span><span class="c5 c14 c6">assert</span><span class="c14 c6">(</span><span class="c5 c14 c6">false</span><span class="c14 c6">); // would throw if asserts enabled, or do nothing otherwise</span></p><p class="c2"><span class="c14 c6"> }</span></p><p class="c2 c4"><span class="c14 c6"></span></p><p class="c2"><span class="c14">therefore, we opt for the second option.  Alternately, one could insist that assert be a reserved word, which may have an undesirable effect with respect to compatibility of Javascript code ported to Dart.</span></p><p class="c2 c4"><span></span></p><a href="#" name="id.3o1inam4xp4c"></a><h2 class="c2"><a name="h.9ljawpv6s0wp"></a><span>Libraries and Scripts</span></h2><p class="c2 c4"><span></span></p><p class="c2"><span>A </span><span class="c3">library</span><span> consists of (a possibly empty) set of imports, and a set of top level declarations. A </span><span class="c3">top level declaration</span><span> is either a </span><span class="c1"><a class="c8" href="#id.o6h4ul6q3sru">class</a></span><span>, an </span><span class="c1"><a class="c8" href="#id.obndo59vaebw">interface</a></span><span>, a </span><span class="c1"><a class="c8" href="#id.5bys07s0ifop">type declaration</a></span><span>, a </span><span class="c1"><a class="c8" href="#kix.v3h5pp33ioek">function</a></span><span> or a </span><span class="c1"><a class="c8" href="#kix.1b3yzqxc4cdw">variable declaration</a></span><span>.</span></p><p class="c2 c4"><span></span></p><a href="#" name="id.8mpv6ds0oag5"></a><p class="c2"><span class="c5 c3">topLevelDefinition:</span><span class="c3"><br>      </span><span class="c0"><a class="c8" href="#id.64pqsyyi6upg">classDefinition</a></span><span class="c3"><br>    | </span><span class="c0"><a class="c8" href="#id.w0vyfr90e2bg">interfaceDefinition</a></span><span class="c3"><br>    | </span><span class="c0"><a class="c8" href="#id.x1rn8p60orxh">functionTypeAlias</a></span><span class="c3"><br>    | </span><span class="c0"><a class="c8" href="#id.7ttlaph5nhkh">functionSignature</a></span><span class="c3"> </span><span class="c0"><a class="c8" href="#id.twypn7sgnd3j">functionBody</a></span><span class="c3"><br>    | </span><span class="c0"><a class="c8" href="#id.mriqqq9dwbm5">returnType</a></span><span class="c3">? </span><span class="c0"><a class="c8" href="#id.gxfpwladgq5d">getOrSet</a></span><span class="c3"> </span><span class="c0"><a class="c8" href="#id.te0njh1fhw7g">identifier</a></span><span class="c3"> </span><span class="c0"><a class="c8" href="#id.6xer2paz3k7q">formalParameterList</a></span><span class="c3"> </span><span class="c0"><a class="c8" href="#id.twypn7sgnd3j">functionBody</a></span><span class="c3"><br>    | </span><span>(</span><span class="c5 c6">final </span><span class="c6">| </span><span class="c5 c6">const</span><span class="c6">)</span><span class="c3"> </span><span class="c0"><a class="c8" href="#id.qv2a3rupuer9">type</a></span><span class="c3">? staticFinalDeclarationList &#39;;&#39;<br>    | </span><span class="c0"><a class="c8" href="#id.prmcvifr6l2h">variableDeclaration</a></span><span class="c3"> &#39;;&#39;<br>    ;<br></span></p><p class="c2 c4"><span class="c3"></span></p><a href="#" name="id.gxfpwladgq5d"></a><p class="c2"><span class="c5 c3">getOrSet:</span></p><p class="c2"><span class="c3">   </span><span class="c5 c6">get </span></p><p class="c2"><span class="c3"> | </span><span class="c5 c6">set</span></p><p class="c2"><span class="c3"> ;<br></span></p><p class="c2"><span class="c3"><br></span><a href="#" name="id.k3wxok4u9obh"></a><span class="c5 c3">libraryDefinition:</span><span class="c3"><br>      scriptTag? </span><span class="c0"><a class="c8" href="#id.1670myhga7st">libraryName</a></span><span class="c3"> </span><span class="c0"><a class="c8" href="#kix.r438bxskg4fe">import</a></span><span class="c3">* </span><span class="c0"><a class="c8" href="#kix.so0yozbisruw">include</a></span><span class="c3">*</span><span class="c3"> </span><span class="c0"><a class="c8" href="#id.1qvhvsgu26yl">resource</a></span><span class="c3">* </span><span class="c0"><a class="c8" href="#id.8mpv6ds0oag5">topLevelDefinition</a></span><span class="c3">*</span></p><p class="c2"><span class="c3">     ;</span></p><p class="c2 c4"><span class="c3"></span></p><a href="#" name="id.e9x0bshxg9dn"></a><p class="c2"><span class="c5 c3">scriptTag:</span></p><p class="c2"><span class="c3">   “#!” (~NEWLINE)* NEWLINE</span></p><p class="c2"><span class="c3"> ;</span></p><p class="c2 c4"><span class="c3"></span></p><a href="#" name="id.1670myhga7st"></a><p class="c2"><span class="c5 c3">libraryName:</span></p><p class="c2"><span class="c3">   “#library” “(” </span><span class="c0"><a class="c8" href="#id.evk894mdov9u">stringLiteral</a></span><span class="c3"> “)” “;”</span></p><p class="c2"><span class="c3">   ;</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span>A library may optionally begin with a script tag, which can be used to identify the interpreter of the script to whatever computing environment the script is embedded in. A script  tag begins with the characters </span><span class="c6">#! </span><span>and ends at the end of the line. Any characters after </span><span class="c6">#! </span><span>are ignored by the Dart implementation.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Libraries are units of privacy. A private declaration declared within a library </span><span class="c3">L</span><span> can only be accessed by code within </span><span class="c3">L.</span><span> Any attempt to access a private member declaration from outside </span><span class="c3">L</span><span> will cause a run-time error. </span><span class="c11">Since top level privates are not imported, using them is a compile time error and not an issue here. </span></p><p class="c2 c4"><span></span></p><p class="c2"><span>The scope of a library </span><span class="c3">L</span><span> consists of the names introduced of all top level declarations declared in </span><span class="c3">L,</span><span> and the names added by </span><span class="c3">L</span><span>&#39;s imports</span><span class="c3">.</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span>Libraries may include extralinguistic resources (e.g., audio, video or graphics files) </span></p><p class="c2 c4"><span class="c3"></span></p><a href="#" name="id.1qvhvsgu26yl"></a><p class="c2"><span class="c5 c3">resource:</span></p><p class="c2"><span class="c3">   </span><span class="c3">“#resource” “(” </span><span class="c0"><a class="c8" href="#id.evk894mdov9u">stringLiteral</a></span><span class="c3"> “)” “;”</span></p><p class="c2"><span class="c3"> ;</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>It is a compile-time error if the argument </span><span class="c3">a</span><span> to a </span><span class="c6">library</span><span> or </span><span class="c6">resource</span><span> directive is not a compile-time constant, or if </span><span class="c3">a</span><span> involves string interpolation.</span></p><p class="c2"><span> </span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><h3 class="c2"><a name="h.jzu775pul7r3"></a><span>Namespaces</span></h3><p class="c2 c4"><span class="c5 c30"></span></p><p class="c2"><span class="c19">Needs work. I think this can all go into the spec section on scopes, and maybe we just use scope instead of namespace. This will help make the scope rules more precise as well. In fact, the namespace combinators below may be useful for specifying scopes, even if they are only exposed to the user in imports and exports.</span></p><p class="c2 c4"><span class="c19"></span></p><p class="c2"><span>A </span><span class="c3">namespace</span><span> is a mapping of identifiers to declarations.  Let </span><span class="c3">NS</span><span> be a namespace. We say that a </span><span class="c3">name n is in NS</span><span> if </span><span class="c3">n</span><span> is a key of </span><span class="c3">NS</span><span>. We say a </span><span class="c3">declaration d is in NS</span><span> if a key of </span><span class="c3">NS</span><span> maps to </span><span class="c3">d.</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span>A scope </span><span class="c3">S</span><span class="c18 c3">0</span><span> induces a namespace </span><span class="c3">NS</span><span class="c18 c3">0</span><span> that is the mapping that maps the simple name of each declaration </span><span class="c3">d</span><span> declared in </span><span class="c3">S</span><span class="c18 c3">0</span><span> to </span><span class="c3">d</span><span>.</span></p><p class="c2"><span>The </span><span class="c3">public namespace</span><span> of library </span><span class="c3">L</span><span> is the mapping that maps the simple name of each public top level member </span><span class="c3">m</span><span> of </span><span class="c3">L</span><span> to </span><span class="c3">m</span><span>.</span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><a href="#" name="id.dplnn8904tiq"></a><h3 class="c2"><a name="h.eyqxfqjhe14t"></a><span>Imports</span></h3><p class="c2 c4"><span></span></p><p class="c2"><span>An </span><span class="c3">import</span><span> </span><span class="c3">directive </span><span>(often abbreviated as </span><span class="c3">import</span><span>) </span><span>specifies how a </span><span>namespace derived from</span><span> one</span></p><p class="c2"><span>library is to be used in the scope of another library. </span></p><p class="c2 c4"><span class="c3"></span></p><a href="#" name="kix.r438bxskg4fe"></a><p class="c2"><span class="c5 c3">import:</span></p><p class="c2"><span class="c3">    “#import” “(” </span><span class="c0"><a class="c8" href="#id.evk894mdov9u">stringLiteral</a></span><span class="c3"> (“,” </span><span class="c3">combinator</span><span class="c3">? ) “)” “;”</span></p><p class="c2"><span class="c3"> ;</span></p><p class="c2 c4"><span></span></p><a href="#" name="id.p046umbtqpmk"></a><p class="c2"><span class="c5 c3">combinator:</span></p><p class="c2"><span class="c3">    </span><span class="c3">“prefix:” </span><span class="c0"><a class="c8" href="#id.evk894mdov9u">stringLiteral</a></span></p><p class="c2"><span class="c3"> | “show:” </span><span class="c0"><a class="c8" href="#id.8u5sm21y6987">listLiteral</a></span></p><p class="c2"><span class="c3">;</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>An import provides a URI where the declaration of the imported library is to be found. </span><span>The import modifies the top-level scope of the current library in a manner that is determined by the imported library and by the optional arguments provided in the import.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c11">Imports assume a global namespace of libraries (at least per isolate). They also assume the library is in control, rather than the other way around. </span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span>It is a compile-time error if a name </span><span class="c3">N</span><span> is introduced into the library scope of a library </span><span class="c3">A,</span><span> and either:</span></p><ol class="c25" start="1"><li class="c7 c2"><span class="c3">N</span><span> is declared by </span><span class="c3">A,</span><span> OR </span></li><li class="c7 c2"><span>Another import introduces </span><span class="c3">N</span><span> into the scope of </span><span class="c3">A.</span><span> </span></li></ol><p class="c2 c4"><span></span></p><p class="c2"><span class="c11">This implies that it is a compile-time error for a library to import itself, as the names of its members will be duplicated.</span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span>The </span><span class="c3">current library</span><span> is the library currently </span><span>being compiled.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Compiling an import directive of the form </span><span class="c3">#import(s</span><span class="c18 c3">1</span><span class="c3">, c: a); </span><span class="c3"> </span><span>proceeds as follows:</span><span class="c3"> </span></p><p class="c2"><span> </span></p><ol class="c25" start="1"><li class="c7 c2"><span>If the contents of the URI that is value of </span><span class="c3">s</span><span class="c9 c3">1</span><span> have not yet been compiled in the current isolate then they are compiled to yield a library </span><span class="c3">B.</span><span> It is a compile-time error if </span><span class="c3">s</span><span class="c9 c3">1</span><span> does not denote a URI that contains the source code for a Dart library.</span></li><li class="c7 c2"><span>Otherwise, the contents of the URI denoted by </span><span class="c3">s</span><span class="c9 c3">1</span><span> have been compiled into a library </span><span class="c3">B</span><span> within the current isolate.</span></li></ol><p class="c2 c4"><span class="c3"></span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Then, let </span><span class="c3">NS</span><span> be the the mapping of names to declarations defined by </span><span class="c3">c(a, NS</span><span class="c9 c3">1</span><span class="c3">)</span><span> where </span><span class="c3">NS</span><span class="c18 c3">1</span><span> is the</span><span><a class="c8" href="https://docs.google.com/a/google.com/document/d/1ElHPRnh_jIT_NaV-9H9q8q0H3LqDUOueBFbCGrFpuPg/edit#bookmark=id.lymamrq4rkhf"> </a></span><span>public namespace of </span><span class="c3">B</span><span>, and </span><span class="c3">c</span><span> is one of the following namespace combinators:</span></p><ol class="c25" start="1"><li class="c7 c2"><span class="c3">prefix(s, n)</span><span> takes a string </span><span class="c3">s</span><span> and a namespace </span><span class="c3">n</span></li></ol><ol class="c34" start="1"><li class="c2 c20"><span>If </span><span class="c3">s</span><span> is the empty string,  the result is </span><span class="c3">n.</span></li><li class="c20 c2"><span>Otherwise, the result is a namespace that has, for each entry mapping key </span><span class="c3">k</span><span> to declaration </span><span class="c3">d</span><span> in </span><span class="c3">n</span><span>,  an entry mapping </span><span class="c3">s.k to d.</span></li></ol><ol class="c25" start="2"><li class="c7 c2"><span class="c3">show(l, n)</span><span> takes a list of strings </span><span class="c3">l</span><span> and a namespace </span><span class="c3">n</span><span> and produces a namespace that  maps each string </span><span class="c3">k</span><span> in </span><span class="c3">l</span><span> to the same element that </span><span class="c3">n</span><span> does, and is undefined otherwise.</span><span class="c3"> </span></li></ol><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Then, each name in </span><span class="c3">NS</span><span class="c18 c3">1</span><span> </span><span>is is made available in the top level scope of the current library</span><span class="c3">.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>It is a compile-time error to import two or more namespaces that define the same name. It is a compile-time error if the optional argument </span><span class="c3">a </span><span> is not a compile-time constant, or if </span><span class="c3">a</span><span> involves string interpolation. It is a compile-time error if the value of </span><span>an actual argument to the </span><span class="c3">prefix</span><span> combinator</span><span> is not a valid identifier. </span><span>It is a compile-time error if any of the elements of the first argument of a use of a </span><span class="c3">show</span><span> combinator is not a valid identifier.  It is compile time error if the value of an actual argument to the </span><span class="c3">prefix</span><span> combinator denotes a name that is declared by the importing library or imported by it.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c11">Note that no errors or warnings are given if one shows a name that is not in a namespace.  </span><span class="c3 c14">This prevents situations where removing a name from a library would cause breakage of a client library.</span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><a href="#" name="id.zcdmf2p15qxc"></a><h3 class="c2"><a name="h.2zfa4ypqygnv"></a><span>Includes</span></h3><p class="c2 c4"><span></span></p><p class="c2"><span>An include directive specifies a URI where a Dart compilation unit that should be incorporated into the current library may be found.</span></p><p class="c2 c4"><span></span></p><a href="#" name="kix.so0yozbisruw"></a><p class="c2"><span class="c5 c3">include:</span></p><p class="c2"><span class="c3">   “#source”  “(” </span><span class="c0"><a class="c8" href="#id.evk894mdov9u">stringLiteral</a></span><span class="c3"> “)” “;”</span></p><p class="c2"><span class="c3">    ;<br></span></p><a href="#" name="id.kas73a527v46"></a><p class="c2"><span class="c5 c3">compilationUnit:</span><span class="c3"><br>      </span><span class="c0"><a class="c8" href="#id.8mpv6ds0oag5">topLevelDefinition</a></span><span class="c3">* EOF<br>    ;<br></span></p><p class="c2 c4"><span></span></p><p class="c2"><span>A </span><span class="c3">compilation unit</span><span> is a sequence of top level declarations.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Compiling an include directive of the form </span><span class="c3">#source(s); </span><span>causes the Dart system to attempt to compile the contents of the URI that is the value of </span><span class="c3">s.</span><span> The top level declarations at that URI are then compiled by the Dart compiler in the scope of the current library. It is a compile time error if the contents of the URI are not a valid compilation unit.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>It is a compile-time error if </span><span class="c3">s</span><span> is not a compile-time constant, or if </span><span class="c3">s</span><span> involves string interpolation.</span></p><p class="c2 c4"><span></span></p><h3 class="c2"><a name="h.ey3rvr2kjush"></a><span>Scripts</span></h3><p class="c2 c4"><span></span></p><p class="c2"><span>A </span><span class="c3">script</span><span> is a library with a top level function </span><span class="c6">main().</span><span> </span></p><p class="c2 c4"><span></span></p><a href="#" name="id.qkdy0hgohe8f"></a><p class="c2"><span class="c5 c3">scriptDefinition:</span></p><p class="c2"><span class="c3">   scriptTag? </span><span class="c0"><a class="c8" href="#id.1670myhga7st">libraryName</a></span><span class="c3">? </span><span class="c0"><a class="c8" href="#kix.r438bxskg4fe">import</a></span><span class="c3">* </span><span class="c0"><a class="c8" href="#kix.so0yozbisruw">include</a></span><span class="c3">*</span><span class="c3"> </span><span class="c0"><a class="c8" href="#id.1qvhvsgu26yl">resource</a></span><span class="c3">* </span><span class="c0"><a class="c8" href="#id.8mpv6ds0oag5">topLevelDefinition</a></span><span class="c3">*</span></p><p class="c2"><span class="c3"> ;</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>A script </span><span class="c3">S</span><span> may be executed as follows:</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>First, </span><span class="c3">S</span><span> is compiled as a library as specified above. Then, the top level function </span><span class="c6">main()</span><span> that is in scope in </span><span class="c3">S</span><span> is invoked with no arguments. It is a run time error if </span><span class="c3">S</span><span> does not declare or import a top level function </span><span class="c6">main().</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c3 c14">The names of scripts are optional, in the interests of interactive, informal use. However, any script of long term value should be given a name as a matter of good practice. Named scripts are composable: they can be used as libraries by other scripts and libraries. </span></p><p class="c2 c4"><span class="c3 c14"></span></p><a href="#" name="id.438ffsdvzkfw"></a><h2 class="c2"><a name="h.g191elx0cpi8"></a><span>Types</span></h2><p class="c2"><span>Dart supports optional typing based on interface types.</span></p><p class="c2"><span class="c3 c14">The type system is unsound, </span><span class="c3 c14">due to the covariance of generic types</span><span class="c3 c14">. This is a deliberate choice (and undoubtedly controversial).  Experience has shown that sound type rules for generics fly in the face of programmer intuition. </span><span class="c3 c14">It is easy for tools to provide a sound type analysis if they choose</span><span class="c3 c14">, which may be useful for tasks like refactoring.</span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><a href="#" name="id.hiljskbmppmb"></a><h3 class="c2"><a name="h.7tlgp5n9j12w"></a><span>Static Types</span></h3><p class="c2"><span class="c3">Static type annotations</span><span> are used in </span><span class="c1"><a class="c8" href="#kix.6b1cgvgf1cyq">variable declarations</a></span><span> (including </span><span class="c1"><a class="c8" href="#id.dbnqav8zbk9d">formal parameters</a></span><span>) and in the return types of </span><span class="c1"><a class="c8" href="#kix.v3h5pp33ioek">functions</a></span><span>.  Static type annotations are used during static checking and when running programs in checked mode. They have no effect whatsoever in production mode.</span></p><p class="c2 c4"><span></span></p><a href="#" name="id.qv2a3rupuer9"></a><p class="c2"><span class="c5 c3">type:</span><span class="c3"><br>      </span><span class="c0"><a class="c8" href="#id.xsv95i3z7eli">qualified</a></span><span class="c3"> </span><span class="c1 c3"><a class="c8" href="#id.okv2bn8j19mq">typeArguments</a></span><span class="c3">?<br>    ;</span></p><p class="c2 c4"><span class="c3"></span></p><a href="#" name="id.okv2bn8j19mq"></a><p class="c2"><span class="c5 c3">typeArguments:</span><span class="c3"><br>      &#39;&lt;&#39; </span><span class="c1 c3"><a class="c8" href="#id.adfwlw3tslsh">typeList</a></span><span class="c3"> &#39;&gt;&#39;<br>    ;<br><br></span><a href="#" name="id.adfwlw3tslsh"></a><span class="c5 c3">typeList:</span><span class="c3"><br>      </span><span class="c1 c3"><a class="c8" href="#id.qv2a3rupuer9">type</a></span><span class="c3"> (&#39;,&#39; </span><span class="c1 c3"><a class="c8" href="#id.qv2a3rupuer9">type</a></span><span class="c3">)*<br>    ;<br></span></p><p class="c2 c4"><span></span></p><p class="c2"><span>A Dart implementation must provide a static checker that detects and reports exactly those situations this specification identifies as static warnings. However:</span></p><ol class="c25" start="1"><li class="c7 c2"><span>Running  the static checker on a program </span><span class="c3">P</span><span> is not required for compiling and running </span><span class="c3">P.</span><span>  </span></li><li class="c7 c2"><span>Running the static checker on a program </span><span class="c3">P</span><span> must not prevent successful compilation of </span><span class="c3">P</span><span> nor may it prevent the execution of </span><span class="c3">P,</span><span> regardless of whether any static warnings occur.</span></li></ol><p class="c2"><span class="c21">Nothing precludes additional tools that implement alternative static analyses (e.g., interpreting the existing type annotations in a sound manner such as either non-variant generics, or inferring declaration based variance from the actual declarations). However, using these tools does not preclude successful compilation and execution of Dart code.</span></p><p class="c2 c4"><span class="c21"></span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><h3 class="c2"><a name="h.6g03yyyk32we"></a><a href="#" name="id.xmnezjjgjrld"></a><span>Dynamic Type System</span></h3><p class="c2"><span>A Dart implementation must support execution in both </span><span class="c3">production mode</span><span> and </span><span class="c3">checked mode. </span><span> Those dynamic checks specified as occurring specifically in checked mode must be performed iff the code is executed in checked mode.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>A type </span><span class="c3">T is malformed</span><span> iff:</span></p><ol class="c25" start="1"><li class="c7 c2"><span class="c3">T</span><span> has the form </span><span class="c3">id,</span><span> and </span><span class="c3">id</span><span> does not denote a type available in the enclosing lexical scope.</span></li><li class="c7 c2"><span class="c3">T</span><span> is a </span><span class="c1"><a class="c8" href="#id.nr95v4q1z9z0">parameterized type</a></span><span> of the form </span><span class="c3">G&lt;S</span><span class="c9 c3">1</span><span class="c3">, .., S</span><span class="c9 c3">n</span><span class="c3">&gt;,</span><span> and any of the following conditions hold:</span></li></ol><ol class="c34" start="1"><li class="c20 c2"><span>Either </span><span class="c3">G</span><span> or </span><span class="c3">S</span><span class="c9 c3">i</span><span class="c3">, 1 &lt;= i &lt;= n</span><span> are malformed. </span></li><li class="c20 c2"><span class="c3">G</span><span> is not a generic type with </span><span class="c3">n</span><span> type parameters.</span></li><li class="c20 c2"><span>Let </span><span class="c3">T</span><span class="c9 c3">i</span><span> be the type parameters of </span><span class="c3">G</span><span> (if any) and let </span><span class="c3">B</span><span class="c9 c3">i</span><span> be the bound of </span><span class="c3">T</span><span class="c9 c3">i</span><span class="c3">, 1 &lt;= i &lt;= n, </span><span>and </span><span class="c3">S</span><span class="c9 c3">i</span><span> is not a subtype of </span><span class="c3">[S</span><span class="c9 c3">1</span><span class="c3">,  ..., S</span><span class="c9 c3">n</span><span class="c3">/T</span><span class="c9 c3">1</span><span class="c3">,  ..., T</span><span class="c9 c3">n</span><span class="c3">]B</span><span class="c9 c3">i</span><span class="c3">,  1 &lt;= i &lt;= n,</span><span> </span></li></ol><p class="c2 c4"><span></span></p><p class="c2"><span>In checked mode, it is a dynamic type error if a malformed type is used in a subtype test. In production mode, an undeclared type is treated as an instance of type </span><span class="c5 c6">Dynamic</span><span>.</span></p><p class="c2 c4"><span class="c32"></span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span class="c11">Consider the following program</span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2 c4"><span class="c5 c11 c6"></span></p><p class="c2"><span class="c5 c11 c6">typedef</span><span class="c11 c6"> F(bool x);</span></p><p class="c2"><span class="c11 c6">f(foo x) =&gt; x;</span></p><p class="c2"><span class="c11 c6">main() {</span></p><p class="c2"><span class="c11 c6">  if (f is F) {</span></p><p class="c2"><span class="c11 c6">    print(&quot;yoyoma&quot;);</span></p><p class="c2"><span class="c11 c6">  }</span></p><p class="c2"><span class="c11 c6">}</span></p><p class="c2 c4"><span class="c11 c6"></span></p><p class="c2"><span class="c11">The type of the formal parameter of </span><span class="c11 c6">f</span><span class="c11"> is </span><span class="c11 c6">foo</span><span class="c11">, which is undeclared in the lexical scope. This will lead to a static type warning. Running the program in production mode will print </span><span class="c11 c6">yoyoma</span><span class="c11">. In checked mode, however, the program will fail when executing the type test on the first line of </span><span class="c11 c6">main()</span><span class="c11">.  A similar situation would arise if we wrote </span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span class="c11 c6">f(foo x) =&gt; x;</span></p><p class="c2"><span class="c11 c6">main() {</span></p><p class="c2"><span class="c11 c6">     print(f(&quot;yoyoma&quot;));</span></p><p class="c2"><span class="c11 c6">}</span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span class="c11">but the reason would be slightly different - the implicit type test triggered by passing </span><span class="c11 c6">“yoyoma”</span><span class="c11"> to </span><span class="c11 c6">f</span><span class="c11"> would fail. In contrast, the program</span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span class="c11 c6">f(foo x) =&gt; x;</span></p><p class="c2"><span class="c11 c6">main() {</span></p><p class="c2"><span class="c11 c6">     print(&quot;yoyoma&quot;);</span></p><p class="c2"><span class="c11 c6">}</span></p><p class="c2 c4"><span class="c11 c6"></span></p><p class="c2"><span class="c11">runs without incident in both production mode and checked mode (though it too gives rise to a static warning).  </span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span class="c11">Some further examples</span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span class="c5 c11 c6">var</span><span class="c11 c6"> i;</span></p><p class="c2"><span class="c11 c6">i  j; //  a variable j of type i (supposedly)</span></p><p class="c2"><span class="c11 c6">main() {</span></p><p class="c2"><span class="c11 c6">     j = </span><span class="c5 c11 c6">new</span><span class="c11 c6"> Object(); // fails in checked mode</span></p><p class="c2"><span class="c11 c6">}</span></p><p class="c2 c4"><span class="c11 c6"></span></p><p class="c2"><span class="c11">Since</span><span class="c11 c3"> i</span><span class="c11"> is not a type, a static warning will be issue at the declaration of </span><span class="c11 c3">j.</span><span class="c11"> However, the program can be executed in production mode without incident. In checked mode, the assignment to </span><span class="c11 c3">j</span><span class="c11"> implicitly introduces a subtype test that checks whether the the type of the newly allocated object, </span><span class="c11 c3">Object</span><span class="c11">, is a subtype of the malformed type </span><span class="c11 c3">i</span><span class="c11">, which will cause a runtime error. However, no runtime error would occur </span><span class="c11">if </span><span class="c11 c3">j</span><span class="c11"> was not used</span><span class="c11">, or if </span><span class="c11 c3">j</span><span class="c11"> was assigned null (since no subtype check is performed in that case).</span></p><p class="c2 c4"><span class="c11 c6"></span></p><p class="c2 c4"><span class="c11 c6"></span></p><p class="c2"><span class="c3 c14">One could have chosen to treat undeclared types in checked mode as type </span><span class="c5 c3 c14 c6">Dynamic</span><span class="c3 c14">, as is done in production mode. After all, a static warning has already been given. That is a legitimate design option, and it is ultimately a judgement call as to whether checked mode should be more or less aggressive in dealing with such a situation.</span></p><p class="c2 c4"><span class="c3 c14"></span></p><p class="c2"><span class="c3 c14">Likewise, we could opt to ignore malformed types entirely in checked mode.</span></p><p class="c2 c4"><span class="c3 c14"></span></p><p class="c2"><span class="c3 c14">For now, we have opted to treat a malformed type as an error type that has no subtypes or supertypes, and which causes a runtime error when tested against any other type.</span></p><p class="c2 c4"><span class="c3 c14"></span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span class="c11">Here is a different example involving malformed types:</span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span class="c5 c11 c6">interface</span><span class="c11 c6"> I&lt;T </span><span class="c5 c11 c6">extends</span><span class="c11 c6"> num&gt; {}</span></p><p class="c2"><span class="c5 c11 c6">interface</span><span class="c11 c6"> J{}</span></p><p class="c2 c4"><span class="c11 c6"></span></p><p class="c2"><span class="c5 c11 c6">class</span><span class="c11 c6"> A&lt;T&gt; </span><span class="c5 c11 c6">extends,</span><span class="c11 c6"> J,</span><span class="c5 c11 c6"> </span><span class="c11 c6"> I&lt;T&gt; // type warning: T is not a subtype of num</span></p><p class="c2"><span class="c11 c6">{ ...</span></p><p class="c2"><span class="c11 c6">} </span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span class="c11">Given the declarations above, the following</span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span class="c11 c6">I x = </span><span class="c5 c11 c6">new</span><span class="c11 c6"> A&lt;String&gt;(); </span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span class="c11">will cause a dynamic type error in checked mode, because the assignment requires a subtype test </span><span class="c11 c6">A&lt;String&gt;</span><span class="c11"> &lt;: </span><span class="c11 c6">I</span><span class="c11">. To show that this holds, we need to show that </span><span class="c11 c6">A&lt;String&gt;</span><span class="c11">≪ </span><span class="c11 c6">I&lt;String&gt;</span><span class="c11">, but </span><span class="c11 c6">I&lt;String&gt;</span><span class="c11"> is a malformed type, causing the dynamic error.  No error is thrown in production mode. Note that</span></p><p class="c2 c4"><span class="c3 c14 c6"></span></p><p class="c2"><span class="c11 c6">J x = </span><span class="c5 c11 c6">new</span><span class="c11 c6"> A&lt;String&gt;(); </span></p><p class="c2 c4"><span class="c11 c6"></span></p><p class="c2"><span class="c11">does not cause a dynamic error, as there is no need to test against </span><span class="c11 c6">I&lt;String&gt;</span><span class="c11"> in this case.</span><span class="c11 c6"> </span></p><p class="c2"><span class="c11">Similarly, in production mode</span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span class="c11 c6">A x = </span><span class="c5 c11 c6">new</span><span class="c11 c6"> A&lt;String&gt;();</span></p><p class="c2"><span class="c11">bool b = x is I;</span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span class="c11 c6">b</span><span class="c11"> is bound to true, but in checked mode the second line causes a dynamic type error.</span></p><p class="c2 c4"><span class="c3 c14 c6"></span></p><p class="c2 c4"><span class="c11 c6"></span></p><p class="c2 c4"><span class="c32"></span></p><p class="c2 c4"><span></span></p><a href="#" name="id.5bys07s0ifop"></a><h3 class="c2"><a name="h.h8qq10r7b7a7"></a><span>Type Declarations</span></h3><a href="#" name="id.cogei5ciyfcy"></a><h4 class="c2"><a name="h.vv8c77hhsmtm"></a><span>Typedef</span></h4><p class="c2 c4"><span></span></p><p class="c2"><span>A </span><span class="c3">type alias</span><span> declares a name for a type expression.</span></p><p class="c2 c4"><span></span></p><a href="#" name="id.x1rn8p60orxh"></a><p class="c2"><span class="c5 c3">functionTypeAlias:</span><span class="c3"><br>      </span><span class="c5 c6">typedef</span><span class="c3"> </span><span class="c0"><a class="c8" href="#kix.yyd520hand9j">functionPrefix</a></span><span class="c3"> </span><span class="c0"><a class="c8" href="#id.p9q99pefxn6v">typeParameters</a></span><span class="c3">? </span><span class="c0"><a class="c8" href="#id.6xer2paz3k7q">formalParameterList</a></span><span class="c3"> &#39;;&#39;<br>    ;<br><br></span><a href="#" name="kix.yyd520hand9j"></a><span class="c5 c3">functionPrefix:</span><span class="c3"><br>    </span><span class="c0"><a class="c8" href="#id.mriqqq9dwbm5">returnType</a></span><span class="c3">? </span><span class="c0"><a class="c8" href="#id.te0njh1fhw7g">identifier</a></span><span class="c3"><br>    ;<br></span></p><p class="c2"><span>The effect of a type alias of the form  </span><span class="c5 c6">typedef</span><span> </span><span class="c3">T id (T</span><span class="c9 c3">1</span><span class="c3"> p</span><span class="c9 c3">1</span><span class="c3">, .., T</span><span class="c9 c3">n</span><span class="c3"> p</span><span class="c9 c3">n</span><span class="c3">, [T</span><span class="c9 c3">n+1</span><span class="c3"> p</span><span class="c9 c3">n+1</span><span class="c3">, …, T</span><span class="c9 c3">n+k</span><span class="c3"> p</span><span class="c9 c3">n+k</span><span class="c3">]</span><span class="c3">)</span><span> declared in a library </span><span class="c3">L</span><span> is is to introduce the name </span><span class="c3">id</span><span> into the scope of </span><span class="c3">L,</span><span> bound to the function type </span><span class="c3">(T</span><span class="c9 c3">1</span><span class="c3">, .., T</span><span class="c9 c3">n</span><span class="c3">, [ T</span><span class="c9 c3">n+1 </span><span class="c3">p</span><span class="c9 c3">n+1</span><span class="c3">:, …,  T</span><span class="c9 c3">n+k </span><span class="c3">p</span><span class="c9 c3">n+k</span><span class="c3">]</span><span class="c3">)  → T.</span><span>  If no return type is specified, it is taken to be</span><span class="c3"> </span><span class="c5 c6">Dynamic.</span><span> Likewise, if a type annotation is omitted on a formal parameter, it is taken to be </span><span class="c5 c6">Dynamic.</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span>Currently, type aliases are restricted to function types. It is a compile-time error if any default values are specified in the signature of a function type alias. </span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><a href="#" name="id.sos77naoaj3x"></a><h3 class="c2"><a name="h.ew91lxv9x8zq"></a><span>Interface Types</span></h3><p class="c2"><span>An interface </span><span class="c3">I</span><span> is a </span><span class="c3">direct supertype</span><span> of an interface </span><span class="c3">J</span><span> iff:</span></p><ol class="c25" start="1"><li class="c7 c2"><span>If </span><span class="c3">I</span><span> is </span><span class="c6">Object</span><span>, and </span><span class="c3">J</span><span> has no </span><span class="c6">extends</span><span> clause</span><span class="c3">.</span></li><li class="c7 c2"><span>if </span><span class="c3">I</span><span> is listed in the </span><span class="c6">extends</span><span> clause of </span><span class="c3">J.</span></li></ol><p class="c2 c4"><span></span></p><p class="c2"><span>A type </span><span class="c3">T</span><span> is </span><span class="c3">more specific than</span><span> a type </span><span class="c3">S,</span><span> written </span><span class="c3">T</span><span> ≪ </span><span class="c3">S, </span><span> if one of the following conditions is met:</span></p><ol class="c26" start="1"><li class="c7 c2"><span class="c5">Reflexivity:</span><span> </span><span class="c3">T</span><span> is </span><span class="c3">S</span><span>.</span></li><li class="c7 c2"><span class="c3">T</span><span> is </span><span class="c3">bottom</span><span>.</span></li><li class="c7 c2"><span class="c3">S </span><span>is </span><span class="c5 c6">Dynamic</span><span>.</span></li><li class="c7 c2"><span class="c5">Direct supertype:</span><span> </span><span class="c3">S</span><span> is a direct supertype of </span><span class="c3">T</span><span>.</span></li><li class="c7 c2"><span> </span><span class="c3">T</span><span> is a type variable and </span><span class="c3">S</span><span> is the upper bound of </span><span class="c3">T.</span></li><li class="c7 c2"><span class="c5">Covariance:</span><span> </span><span class="c3">T</span><span> is of the form </span><span class="c3">I&lt;T</span><span class="c9 c3">1</span><span class="c3">, ..., T</span><span class="c9 c3">n</span><span class="c3">&gt;</span><span> and </span><span class="c3">S</span><span> is of the form </span><span class="c3">I&lt;S</span><span class="c9 c3">1</span><span class="c3">, ..., S</span><span class="c9 c3">n</span><span class="c3">&gt;</span><span> and </span><span class="c3">T</span><span class="c9 c3">i</span><span class="c9"> </span><span> ≪ </span><span class="c3">S</span><span class="c9 c3">i </span><span class="c3">, 1 &lt;= i &lt;= n.</span></li><li class="c7 c2"><span class="c5">Transitivity: </span><span class="c3">T</span><span> ≪ </span><span class="c3">U</span><span> and </span><span class="c3">U</span><span> ≪ </span><span class="c3">S</span><span>.</span></li></ol><p class="c2 c4"><span></span></p><p class="c2"><span>≪ is a </span><span class="c13"><a class="c8" href="http://en.wikipedia.org/wiki/Partial_order">partial order</a></span><span> on types.</span></p><p class="c2"><span class="c3">T</span><span> is a </span><span class="c3">subtype</span><span> of </span><span class="c3">S</span><span>, written </span><span class="c3">T</span><span> &lt;: </span><span class="c3">S, </span><span>iff </span><span class="c3">[</span><span class="c3">bottom/</span><span class="c5 c6">Dynamic</span><span class="c3">]T</span><span> ≪ </span><span class="c3">S</span><span>.</span></p><p class="c2"><span class="c3 c14">Note that &lt;: is not a partial order on types, it is only </span><span class="c13 c3"><a class="c8" href="http://en.wikipedia.org/wiki/Relation_(mathematics)">binary relation</a></span><span class="c3 c14"> on types. This is because &lt;: is not transitive. If it was, the subtype rule would have a cycle. For example:</span></p><p class="c2"><span class="c3 c14">List &lt;: List&lt;String&gt; and List&lt;int&gt; &lt;: List, but List&lt;int&gt; is not a subtype of List&lt;String&gt;.</span></p><p class="c2"><span class="c3 c14">Although &lt;: is not a partial order on types, it does contain a partial order, namely ≪. This means that, barring raw types, intuition about classical subtype rules does apply.</span></p><p class="c2 c4"><span class="c5"></span></p><p class="c2"><span class="c3">S</span><span> is a </span><span class="c3">supertype</span><span> of </span><span class="c3">T</span><span>, written </span><span class="c3">S</span><span> :&gt; </span><span class="c3">T</span><span>, iff </span><span class="c3">T</span><span> is a subtype of </span><span class="c3">S</span><span>.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c11">The </span><span class="c11 c3">supertypes</span><span class="c11"> of an interface are its direct supertypes and their supertypes. </span></p><p class="c2 c4"><span></span></p><p class="c2"><span>A type </span><span class="c3">T</span><span> </span><span class="c3">may be assigned to</span><span> a type </span><span class="c3">S</span><span>, written  T ⇔ S, iff either </span><span class="c3">T &lt;: S</span><span> or </span><span class="c3">S &lt;: T. </span></p><p class="c2"><span class="c16 c3 c14">This rule may surprise readers accustomed to conventional typechecking. The intent of the ⇔ relation is not to ensure that an assignment is correct. Instead, it aims to only flag assignments that are almost certain to be erroneous, without precluding assignments that may work. </span></p><p class="c2 c4"><span class="c16 c3 c14"></span></p><p class="c2"><span class="c16 c3 c14">For example, assigning a value of static type Object to a variable with static type String, while not guaranteed to be correct, might be fine if the runtime value happens to be a string.</span></p><p class="c2 c4"><span></span></p><a href="#" name="id.mmt307l7ge76"></a><h3 class="c2"><a name="h.hj977zpcf6uf"></a><span>Function Types</span></h3><p class="c2 c4"><span></span></p><p class="c2"><span>A function type </span><span class="c3">(T</span><span class="c9 c3">1</span><span class="c3">, ..., T</span><span class="c9 c3">n</span><span class="c3">, [T</span><span class="c9 c3">x1</span><span class="c3"> x</span><span class="c9 c3">1</span><span class="c3">, …, T</span><span class="c9 c3">xk</span><span class="c3"> x</span><span class="c9 c3">k</span><span class="c3">]</span><span class="c3">) → T</span><span> is a subtype of the function type </span><span class="c3">(S</span><span class="c9 c3">1</span><span class="c3">, ..., S</span><span class="c9 c3">n</span><span class="c3">, [S</span><span class="c9 c3">y1</span><span class="c3"> y</span><span class="c9 c3">1</span><span class="c3">, …, S</span><span class="c9 c3">ym</span><span class="c3"> y</span><span class="c9 c3">m</span><span class="c3">]</span><span class="c3">) → S,</span><span> if all of the following conditions are met:</span></p><ol class="c26" start="1"><li class="c7 c2"><span>Either</span></li></ol><ol class="c34" start="1"><li class="c20 c2"><span class="c3">S</span><span> is </span><span class="c6">void</span><span>,</span></li><li class="c20 c2"><span>or </span><span class="c3">T</span><span> ⇔ </span><span class="c3">S</span><span>.</span></li></ol><ol class="c26" start="2"><li class="c7 c2"><span>For all </span><span class="c3">i</span><span> , 1 &lt;= i &lt;=  </span><span class="c3">n</span><span>, </span><span class="c3">T</span><span class="c9 c3">i</span><span> ⇔ </span><span class="c3">S</span><span class="c9 c3">i</span><span>.</span></li><li class="c7 c2"><span class="c3">k &gt;= m</span><span> and </span><span class="c3">x</span><span class="c9 c3">i</span><span class="c3"> = y</span><span class="c9 c3">i</span><span>, </span><span class="c3">1 &lt;= i &lt;= m.</span><span> </span><span class="c3 c14">It is necessary, but not sufficient, that the optional arguments of the subtype  be a superset of those of the supertype. We cannot treat them as just sets, because optional arguments can be invoked positionally, so the order matters.</span></li><li class="c7 c2"><span>For all </span><span class="c3">y</span><span> in </span><span class="c3">{y</span><span class="c9 c3">1</span><span class="c3">, …, y</span><span class="c9 c3">m</span><span class="c3">} S</span><span class="c9 c3">y</span><span> ⇔ </span><span class="c3">T</span><span class="c9 c3">y</span><span class="c3">.</span></li></ol><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><p class="c2"><span>We write </span><span class="c3">(T</span><span class="c9 c3">1</span><span class="c3">, ..., T</span><span class="c9 c3">n</span><span class="c3">) → T</span><span> as a shorthand for the type </span><span class="c3">(T</span><span class="c9 c3">1</span><span class="c3">, ..., T</span><span class="c9 c3">n</span><span class="c3">, []) → T.</span></p><p class="c2 c4"><span class="c3 c14"></span></p><p class="c2"><span>If an interface type </span><span class="c3">I </span><span>includes the special operator call, and the type of call is the function type</span><span class="c3"> F, </span><span>then</span><span class="c3"> I </span><span>is considered to be a subtype of </span><span class="c3">F.</span></p><p class="c2"><span>All functions implement the interface </span><span class="c6">Function</span><span>.  However not all function types are a subtype of </span><span class="c6">Function</span><span>.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c21"> </span></p><p class="c2 c4"><span></span></p><a href="#" name="kix.5kehb35oxqwh"></a><h3 class="c2"><a name="h.myhds5lp5ovr"></a><span>Type Dynamic</span></h3><p class="c2 c4"><span></span></p><p class="c2"><span>The built-in identifier </span><span class="c5 c6">Dynamic</span><span> denotes the </span><span class="c3">unknown type.</span><span> </span></p><p class="c2 c4"><span class="c3 c14"></span></p><p class="c2"><span>If no static type annotation has been provided the type system assumes the declaration has the type </span><span class="c5 c6">Dynamic</span><span>. If a generic type is used but the corresponding type arguments are not provided, then the missing type arguments default to the unknown type.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c21">This means that given a generic declaration </span><span class="c21 c3">G&lt;T</span><span class="c21 c9 c3">1</span><span class="c21 c3">, …, T</span><span class="c21 c9 c3">n</span><span class="c21 c3">&gt;,</span><span class="c21"> the type </span><span class="c21 c3">G</span><span class="c21"> is equivalent to </span><span class="c21 c3">G&lt;Dynamic, …, Dynamic&gt;.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Type </span><span class="c5 c6">Dynamic</span><span> </span><span>has methods for every possible identifier and arity, with every possible combination of named parameters</span><span>. These methods all have </span><span class="c5 c6">Dynamic</span><span class="c6"> </span><span>as their return type, and their formal parameters all have type </span><span class="c5 c6">Dynamic</span><span>.</span></p><p class="c2"><span>Type </span><span class="c5 c6">Dynamic</span><span class="c6"> </span><span>has properties for every possible identifier. These properties all have type </span><span class="c5 c6">Dynamic</span><span>.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c3 c14">From a usability perspective, we want to ensure that the checker does not issue errors everywhere an unknown type is used. The definitions above ensure that no secondary errors are reported when accessing an unknown type. </span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c3 c14">The current rules say that missing type arguments are treated as if they were the type Dynamic. An alternative is to consider them as meaning </span><span class="c3 c14 c6">Object</span><span class="c3 c14">.  This would lead to earlier error detection in checked mode, and more aggressive errors during static typechecking. For example:</span></p><p class="c2 c4"><span class="c3 c14 c6"></span></p><p class="c2"><span class="c3 c14 c6">(1) typedAPI(G&lt;String&gt; g){...}</span></p><p class="c2"><span class="c3 c14 c6">(2) typedAPI(new G()); </span></p><p class="c2 c4"><span class="c3 c14 c6"></span></p><p class="c2"><span class="c3 c14 c6">Under the alternative rules, (2) would cause a runtime error in checked mode. This seems desirable from the perspective of error localization. However, when a Dynamic error is raised at (2), the only way to keep running is rewriting (2) into</span></p><p class="c2 c4"><span class="c3 c14 c6"></span></p><p class="c2"><span class="c3 c14 c6">(3) typedAPI(new G&lt;String&gt;());</span></p><p class="c2 c4"><span class="c3 c14 c6"></span></p><p class="c2"><span class="c3 c14 c6">This forces users to write type information in their client code just because they are calling a typed API.  We do not want to impose this on Dart programmers, some of which may be blissfully unaware of types in general, and genericity in particular.</span></p><p class="c2 c4"><span class="c3 c14 c6"></span></p><p class="c2"><span class="c3 c14 c6">What of static checking? Surely we would want to flag (2) when users have explicitly asked for static typechecking? Yes, but the reality is that the Dart static checker is likely to be running in the background by default. Engineering teams typically desire a “clean build” free of warnings and so the checker is designed to be extremely charitable. Other tools can interpret the type information more aggressively and warn about violations of conventional (and sound) static type discipline.</span></p><p class="c2 c4"><span class="c3 c14 c6"></span></p><p class="c2"><span class="c3 c14"> </span></p><h3 class="c2"><a name="h.a5hjb7g00phr"></a><span>Type Void</span></h3><p class="c2 c4"><span></span></p><p class="c2"><span>The special type </span><span class="c5 c3 c6">void</span><span> may only be used as the return type of a function: it is a compile-time error to use </span><span class="c5 c6">void</span><span> in any other context. </span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c11">For example, as a type argument, or as the type of a variable or parameter</span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span class="c11">Void is not an interface type. </span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span class="c11">The only subtype relations that pertain to </span><span class="c5 c11 c6">void</span><span class="c11"> are therefore:</span></p><ol class="c25" start="1"><li class="c7 c2"><span class="c5 c11 c6">void</span><span class="c11"> &lt;: </span><span class="c5 c11 c6">void</span><span class="c11">(by reflexivity)</span></li><li class="c7 c2"><span class="c11">bottom &lt;: </span><span class="c5 c11 c6">void</span><span class="c11"> (as bottom is a subtype of all types).</span></li><li class="c7 c2"><span class="c5 c11 c6">void</span><span class="c11"> &lt;: Dynamic (as Dynamic is a supertype of all types)</span></li></ol><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span class="c11">Hence, the static checker will issue warnings if one attempts to access a member of the result of a </span><span class="c5 c11 c6">void</span><span class="c11"> method invocation (even for members of </span><span class="c5 c11 c6">null,</span><span class="c11"> such as </span><span class="c11 c6">==</span><span class="c11">).  Likewise, passing the result of a </span><span class="c5 c11 c6">void</span><span class="c11"> method as a parameter or assigning it to a variable will cause a warning unless the variable/formal parameter has type Dynamic.</span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span class="c11">On the other hand, it is possible to return the result of a </span><span class="c5 c11 c6">void</span><span class="c11"> method from within a void method. One can also return </span><span class="c5 c11 c6">null;</span><span class="c11"> or a value of type </span><span class="c5 c11 c6">Dynamic</span><span class="c11">. Returning any other result will cause a type warning (or a dynamic type error in checked mode).</span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2 c4"><span class="c11"></span></p><a href="#" name="id.nr95v4q1z9z0"></a><h3 class="c2"><a name="h.6kyg74b28ed0"></a><span>Parameterized Types</span></h3><p class="c2 c4"><span></span></p><p class="c2"><span>A </span><span class="c3">parameterized type</span><span> is an invocation of a generic type declaration.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Let </span><span class="c3">p = G&lt;A</span><span class="c9 c3">1</span><span class="c3">, …, A</span><span class="c9 c3">n</span><span class="c3">&gt;</span><span> be a parameterized type. </span></p><p class="c2 c4"><span></span></p><p class="c2"><span>It is a static type warning if </span><span class="c3">G</span><span> is not an accessible generic type declaration with </span><span class="c3">n</span><span> type parameters. It is a static type warning if </span><span class="c3">A</span><span class="c9 c3">i</span><span class="c3">, 1 &lt;= i &lt;= n</span><span>  does not denote a type in the enclosing lexical scope.</span></p><p class="c2 c4"><span></span></p><p class="c2"><span>If </span><span class="c3">S</span><span> is the static type of of a member </span><span class="c3">m</span><span> of G, then the static type of the member </span><span class="c3">m</span><span> of </span><span class="c3">G&lt;A</span><span class="c9 c3">1</span><span class="c3">, …, A</span><span class="c9 c3">n</span><span class="c3">&gt;</span><span> is </span><span class="c3">[A</span><span class="c9 c3">1</span><span class="c3">, …, A</span><span class="c9 c3">n</span><span class="c3">/T</span><span class="c9 c3">1</span><span class="c3">, …, T</span><span class="c9 c3">n</span><span class="c3">]S</span><span> where </span><span class="c3">T</span><span class="c9 c3">1</span><span class="c3">, …, T</span><span class="c9 c3">n </span><span>are the formal type parameters of </span><span class="c3">G. </span><span>Let </span><span class="c3">B</span><span class="c9 c3">i</span><span class="c3"> </span><span>be the bounds of </span><span class="c3">T</span><span class="c9 c3">i</span><span class="c3">, 1 &lt;= i &lt;= n. </span><span>It is a static type warning if </span><span class="c3">A</span><span class="c9 c3">i</span><span class="c3"> </span><span>is not a subtype of </span><span class="c3">[A</span><span class="c9 c3">1</span><span class="c3">, …, A</span><span class="c9 c3">n</span><span class="c3">/T</span><span class="c9 c3">1</span><span class="c3">, …, T</span><span class="c9 c3">n</span><span class="c3">]B</span><span class="c9 c3">i</span><span class="c3">, 1 &lt;= i &lt;= n.</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2 c4"><span class="c11"></span></p><a href="#" name="id.93yudg3nk9o1"></a><h4 class="c2"><a name="h.eu4kv2vjewua"></a><span>Actual Type of a Declaration</span></h4><p class="c2 c4"><span class="c11"></span></p><p class="c2"><span>A type </span><span class="c3">T depends on a type variable U</span><span> iff:</span></p><ol class="c25" start="1"><li class="c7 c2"><span class="c3">T</span><span> is </span><span class="c3">U.</span></li><li class="c7 c2"><span class="c3">T</span><span> is a parameterized type, and one of the type arguments of </span><span class="c3">T</span><span> depends on </span><span class="c3">U.</span></li></ol><p class="c2 c4"><span></span></p><p class="c2"><span>Let </span><span class="c3">T</span><span> be the declared type of a declaration </span><span class="c3">d,</span><span> as it appears in the program source. The </span><span class="c3">actual type</span><span> of </span><span class="c3">d</span><span> is</span></p><p class="c2 c4"><span></span></p><ol class="c25" start="1"><li class="c7 c2"><span class="c3">[A</span><span class="c9 c3">1</span><span class="c3">, ..., A</span><span class="c9 c3">n</span><span class="c3">/U</span><span class="c9 c3">1</span><span class="c3">, ..., U</span><span class="c9 c3">n</span><span class="c3">]T</span><span> if </span><span class="c3">T</span><span> depends on type variables </span><span class="c3">U</span><span class="c9 c3">1</span><span class="c3">, ..., U</span><span class="c9 c3">n</span><span class="c3">,</span><span> and </span><span class="c3">A</span><span class="c9 c3">i</span><span> is the actual value of </span><span class="c3">U</span><span class="c9 c3">i</span><span class="c3">, 1 &lt;= i &lt;= n.</span></li><li class="c7 c2"><span class="c3">T</span><span> otherwise.</span></li></ol><p class="c2 c4"><span class="c11"></span></p><p class="c2 c4"><span class="c11"></span></p><h4 class="c2"><a name="h.hegkdje9bscx"></a><span>Least Upper Bounds</span></h4><p class="c2 c4"><span></span></p><p class="c2"><span>Given two interfaces </span><span class="c3">I</span><span> and </span><span class="c3">J,</span><span> let </span><span class="c3">S</span><span class="c9 c3">I</span><span> be the set of superinterfaces of </span><span class="c3">I,</span><span>  let </span><span class="c3">S</span><span class="c9 c3">J</span><span> be the set of superinterfaces of </span><span class="c3">J</span><span> and let</span><span class="c3"> S = (I </span><img src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=%5Ccup%7B%7D"><span class="c3">S</span><span class="c9 c3">I </span><span class="c3">)</span><img src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=%5Ccap%7B%7D"><span class="c3"> (J </span><img src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=%5Ccup%7B%7D"><span class="c3"> S</span><span class="c9 c3">J </span><span class="c3">).</span><span> Furthermore, we define </span><span class="c3">S</span><span class="c9 c3">n</span><span class="c3"> = {T | T </span><img src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=%5Cin%7B%7D"><span class="c3"> S  </span><img src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=%5Cwedge%7B%7D"><span class="c3"> depth(T) =n}</span><span> </span><span>for any finite </span><span class="c3">n,</span><span> and </span><span class="c3">k=</span><span class="c3">max(depth(T</span><span class="c9 c3">1</span><span class="c3">), ..., depth(T</span><span class="c9 c3">m</span><span class="c3">)), T</span><span class="c9 c3">i</span><span class="c3"> </span><img src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=%5Cin%7B%7D"><span class="c3"> S, 1 &lt;= i &lt;= m,</span><span> where </span><span class="c3">depth(T)</span><span> is the number of steps in the shortest inheritance path from </span><span class="c3">T</span><span> to </span><span class="c6">Object</span><span>. Let </span><span class="c3">q</span><span> be the smallest number such that </span><span class="c3">S</span><span class="c9 c3">q</span><span> has cardinality one. The least upper bound of </span><span class="c3">I</span><span> and </span><span class="c3">J</span><span> is the sole element of </span><span class="c3">S</span><span class="c9 c3">q</span><span>.</span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span class="c11"></span></p><p class="c2 c4"><span class="c11"></span></p><a href="#" name="id.o15g7g72qsq"></a><h2 class="c2"><a name="h.lhp7sn5lni0h"></a><span>Reference</span></h2><a href="#" name="id.72xk08vpsgpx"></a><h3 class="c2"><a name="h.h9utggye7amm"></a><span>Lexical Rules</span></h3><p class="c2 c4"><span></span></p><p class="c2"><span>Dart source text is represented as a sequence of Unicode code points normalized to Unicode Normalization Form C. </span></p><h4 class="c2"><a name="h.7y8tn090mmsr"></a><span>Reserved Words </span></h4><p class="c2"><span class="c5 c6">break, case, catch, class, const, continue, default, do, else, extends, false, final, finally, for, if, in, is, new, null, return, super, switch, this, throw, true, try, var, void, while.</span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c3"> </span><a href="#" name="id.bptaecjachp1"></a><span class="c5 c3">LETTER</span><span class="c5 c3">:</span><span class="c3"><br>      &#39;a&#39;..&#39;z&#39;<br>    | &#39;A&#39;..&#39;Z&#39;<br>    ;<br><br></span><a href="#" name="id.w2ucufslrxvb"></a><span class="c5 c3">DIGIT:</span><span class="c3"><br>      &#39;0&#39;..&#39;9&#39;<br>    ;<br><br></span><a href="#" name="id.4583jo1p24zz"></a><span class="c5 c3">WHITESPACE:</span><span class="c3"><br>      (&#39;\t&#39; | &#39; &#39; | NEWLINE)+<br>    ;<br></span></p><h4 class="c2"><a name="h.gey5ehc2i2ad"></a><span>Comments</span></h4><p class="c2 c4"><span></span></p><p class="c2"><span>Comments are sections of program text that are used for documentation.</span></p><p class="c2"><span class="c3"><br></span><a href="#" name="id.gl18l17xcban"></a><span class="c5 c3">SINGLE_LINE_COMMENT:</span><span class="c3"><br>      &#39;//&#39; ~(NEWLINE)* (NEWLINE)?<br>    ;<br><br></span><a href="#" name="id.ec52omtr1lpp"></a><span class="c5 c3">MULTI_LINE_COMMENT:</span><span class="c3"><br>      &#39;/*&#39; </span><span class="c3">(MULTI_LINE_COMMENT | ~ &#39;*/&#39;)*</span><span class="c3"> &#39;*/&#39;<br>    ;</span></p><p class="c2"><span class="c27 c3">  <br></span><span>Dart supports both single-line and multi-line comments. A single line </span><span>comment</span><span> begins with the token //. </span><span class="c16">Everything between </span><span class="c16">// and the</span><span class="c16"> end of line must be ignored by the Dart compiler. </span></p><p class="c2 c4"><span class="c16"></span></p><p class="c2"><span class="c16">A multi-line comment begins with the token /* and ends with the token */.  Everything between </span><span class="c16">/*</span><span class="c16"> and </span><span class="c16">*/</span><span class="c16"> must be ignored by the Dart compiler unless the comment is a documentation comment. Comments may nest.</span><span> </span></p><p class="c2 c4"><span></span></p><p class="c2"><span>Documentation comments are multi-line comments that begin with the </span><span>tokens</span><span> /**. Inside a documentation comment, the Dart compiler ignores all text </span><span>unless</span><span> it is enclosed in brackets.</span></p><p class="c2 c4"><span class="c19"></span></p><p class="c2 c4"><span></span></p><p class="c2"><span class="c19"> </span></p><p class="c2 c4"><span></span></p><a href="#" name="id.2yixkvmdnmcn"></a><h3 class="c2"><a name="h.sn1uuf2ffwwd"></a><span>Operator Precedence</span></h3><p class="c2 c4"><span></span></p><p class="c2"><span>Operator precedence is given implicitly by the grammar.</span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p><p class="c2 c4"><span></span></p></div><div id="footer"><span>Published by <a target="_blank" title="Learn more about Google Docs" href="//docs.google.com/">Google Docs</a></span></div>
</body></html>
