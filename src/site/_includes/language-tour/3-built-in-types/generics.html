<p>
Generics are annotations to help you and your tools understand more about the types you'll use with objects such as collections.
</p>

<p>
Maps can be specified with parameterized types, which allow you to say what kind of types you want to store inside the map. For example, perhaps you want a Map of Strings to integers. Without generics, you'd have to just hope everyone (including you) puts in String/int pairs, and you'd probably have to add a bunch of assertions to ensure that they (or you) did. However, with generics, the tools and runtime can help ensure that the code maps Strings to integers.
</p>

<p>
(The examples in the post so far have not specified any parameterized types.)
</p>

<p>
In Dart, you can be more specific about your Map, and actually say "A Map that maps Strings to integers" in this way:
</p>

{% pretty_code dart 0 %}
var stuff = <String, int>{'four': 4, 'five': 5};
print( stuff['four'] ); // 4
{% endpretty_code %}

<p>
The above is the same as:
</p>

{% pretty_code dart 0 %}
var stuff = new Map<String, int>();
stuff['four'] = 4;
stuff['five'] = 5;
print( stuff['four'] ); // 4
{% endpretty_code %}

<p>
Our tools come to the rescue when someone (definitely not you, because you're a Dart viking) accidentally assigns the wrong type. For example, if you run the below in Checked Mode:
</p>

{% pretty_code dart 0 %}
var stuff = new Map<String, int>();
stuff['four'] = "oh uh!"; // Failed type check: type String is not assignable to type int
print( stuff['four'] ); // won't get this far
{% endpretty_code %}

<p>
Now that's what I'm talking about! For the small cost of specifying the expected types at object instantiation time, the system (in checked mode) will warn you the wrong type is being used, and the program will stop running. (again, if you're in checked mode, this is true) Check out the above example and play with the "checked mode" toggle.
</p>

<p>
You can go further and even specify the parameterized types statically, such as:
</p>

{% pretty_code dart 0 %}
Map<String, int> stuff = new Map<String, int>();
stuff['four'] = "oh uh!"; // warning here if NOT in checked mode
print( stuff['four'] ); // won't get this far
{% endpretty_code %}

<p>
Now the system has even more information, so you will get further warnings even if you're not in checked mode! The program will still run if you have checked mode turned off, since the above program still works. However, by specifying the static type for stuff, you've added enough annotations to give you warnings that something isn't quite right. Try the above code yourself, with and without "checked mode" enabled.
</p>

<p>
As mentioned above, if you are using the non-literal syntax to declare a Map (such as new Map()) then you can use any object that implements hashCode as the key.
</p>

<section id="maps-summary">
<h4> Summary of generics </h4>

<p>
Just as Dart has optional types,
parameterized types are optional as well.
They are quite useful when you're writing method signatures and interfaces,
as they convey even more intention and documentation
about the expected containers and objects.
The more type annotations you can add,
the more rich documentation can be extracted
and the more the tools can warn you when things don't go as planned.
</p>

</section>
