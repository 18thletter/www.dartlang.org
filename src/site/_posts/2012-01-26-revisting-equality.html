---
layout: default
title: Revisiting equality
rel:
  author: gilad-bracha
author:
  name: Gilad Bracha
pubdate: 2012-01-26
---

{% capture contents %}

<div class="spec-update">
  
  <aside>
    <span class="rationale">Discussion of the motivation for language design decisions appears in blue italics.</span>
    <span class="commentary">Commentary is green, serving to illustrate or clarify the specification, but are redundant with the normative text. </span>
    <span class="open-questions">Open questions are red. Open questions are points that are unsettled in the mind of the author(s) of the specification; expect them  (the questions, not the authors; precision is important in a specification) to be eliminated in the final specification</span>
    <span class="new">New changes are highlighted in yellow</span>
  </aside>

<h1>Equality Revisited</h1>


<p>This is a draft specification for the revised handling of equality. The essence of the change is as follows:</p>

<p>The == operator is no longer user definable. It has fixed behavior, that is however customizable via the operator/method equals(). Specifically, given x == y:</p>

<ul>
  <li>If x === y then return true. Otherwise</li>
  <li>if either x or y is null, return false. Otherwise</li>
  <li>return the result of x.equals(y)</li>
</ul>

<p>The question arises, do we need the special story with operators for negate, call and equals? Can we just say that the operators are hardwired to invoke the methods involved?</p>

<h2>Specification Changes</h2>


<p><em>Spec changes highlighted in yellow.</em></p>

<h3>Operators</h3>


<p>Operators are instance methods with special names.</p>

<pre>
<b>operatorSignature</b>:
      returnType? <b>operator</b> operator formalParameterList
       ;

<b>operator</b>:
      unaryOperator
    | binaryOperator
    | '[' ']'
    | '[' ']' '='
    | <b>negate</b>
   | <b>call</b>
   <span class="new">| <b>equals</b></span>
    ;
    
<b>unaryOperator</b>:
      negateOperator
    ;

<b>binaryOperator</b>:
      multiplicativeOperator
    | additiveOperator
    | shiftOperator
    | relationalOperator
    | equalityOperator
    | bitwiseOperator
    ;

<b>prefixOperator</b>:
       '-'
   | negateOperator
    ;


<b>negateOperator</b>:
      '!'
    | '~'
    ;
</pre>

<p>An operator declaration is identified with built-in identifier <b>operator</b>.</p>

<p>The following names are allowed for user-defined operators:  &lt;, >, &lt;=, >=, -, +, /, ~/,  *, %, |, ^, &amp;, &lt;&lt;, >>, []=, [], ~, <b>call</b>, <b>equals</b>, <b>negate</b>.</p>

<p>The built-in identifier <b>negate</b> is used to denote unary minus. The built-in identifier call is used to denote function application ( ()  ). <span class="new">The built-in identifier equals is used to denote equality (==).</span></p>

<p class="commentary">Defining a nullary method named call, <span class="new">equals</span> or negate will have the same effect as defining an operator, but is considered bad style, and will cause a static warning.</p>

<p class="rationale">It is tempting to define it to be a compile-time error to declare a method named call, <span class="new">equals</span> or negate. However, this causes compatibility problems.  Since these are <span class="new">all</span> built-in identifiers, unsanctioned use will cause a static warning, which is arguably sufficient to alert the programmer to the fact that the ported code is likely not intended to define an operator. In fresh Dart code, the warning will indicate that either the built-in identifier operator was forgotten, or that the method should have a different name.</p>

<p>It is a compile-time error if the number of formal parameters of the user-declared operator []= is not 2. It is a compile time error if the number of formal parameters of a user-declared operator with one of the names:  <span class="new">equals</span>, &lt;, >, &lt;=, >=, -, +, /, ~/, *, %, |, ^, &amp;, &lt;&lt;, >>, [] is not 1. It is a compile time error if the arity of a user-declared operator with one of the names: ~, <b>negate</b> is not 0.</p>

<p>It is a compile-time error to declare an optional named parameter in an operator. The operator <b>call</b> can have any arity.</p>

<p>It is a compile-time error to declare an optional named parameter in an operator, with the exception of the operator <b>call</b>.</p>

<p>It is a static warning if the return type of the user-declared operator []= is explicitly declared and not <b>void</b>. <span class="new">It is a static warning if the return type of the operator <b>equals</b> is explicitly declared and is not bool.</span> It is a static warning if the return type of the operator <b>negate</b> is explicitly declared and not a numerical type. </p>

<h3>Equality</h3>

<p>Equality expressions test objects for identity or equality.</p>

<pre>
<b>equalityExpression</b>:
      relationalExpression (equalityOperator relationalExpression)?
    | super equalityOperator relationalExpression
    ;

<b>equalityOperator</b>:
      '=='
    | '!='
    | '==='
    | '!=='
    ;
</pre>

<p>An <em>equality expression</em> is either a relational expression, or an invocation of a equality operator on  on either <b>super</b> or an expression e1, with argument e2.</p>

<div class="new">
  
  <p>Evaluation of an equality expression ee of the form e<sub>1</sub> == e<sub>2</sub> proceeds as follows:</p>

  <ul>
   <li> The expression e<sub>1</sub> is evaluated to an object o<sub>1</sub>.</li>
  <li>The expression e<sub>2</sub> is evaluated to an object o<sub>2</sub>.</li>
  <li>If o<sub>1</sub> === o<sub>2</sub> evaluates to <b>true</b>, then ee evaluates to <b>true</b>. Otherwise,</li>
  <li>If either o<sub>1</sub> or o<sub>2</sub> is null, then ee evaluates to <b>false</b>. Otherwise,</li>
  <li>ee is equivalent to the method invocation o<sub>1</sub>.equals(o<sub>2</sub>).</li>
  </ul>


  <p>Evaluation of an equality expression ee of the form <b>super</b> == e proceeds as follows:</p>

  <ul>
  <li>The expression e is evaluated to an object o.</li>
  <li>If <b>this</b> === o evaluates to <b>true</b>, then ee evaluates to <b>true</b>. Otherwise,</li>
  <li>If either <b>this</b> or o is null, then ee evaluates to <b>false</b>. Otherwise,</li>
  <li>ee is equivalent to the method invocation <b>super</b>.equals(o).</li>
  </ul>


  <p class="commentary">As a result of the above definition, user defined equals() methods can assume that their argument is not this and is non-null, and avoid the standard boiler-plate prelude:</p>

  <pre class="commentary">
    if (this === arg) return true;
    if (null === arg) return false;
  </pre>

  <p class="commentary">Another implication is that there is never a need to use === to test against null, nor should anyone ever worry about whether to write null == e or e = = null.</p>

</div> <!-- end of new -->

<p>An equality expression of the form e1 != e2  is equivalent to the expression !(e1 == e2 ). An equality expression of the form  <b>super</b> != e is equivalent to the expression !(<b>super</b> == e)).</p>


<p>Evaluation of an equality expression ee of the form e1 === e2 proceeds as follows:</p>
<p>The expression e1 is evaluated to an object o1; then the expression e2 is evaluated to an object o2.  Next, if o1 and o2 are the same object, then ee evaluates to <b>true</b>, otherwise ee evaluates to <b>false</b>.</p>

<p>An equality expression of the form  <b>super</b> === e is equivalent to the expression <b>this</b> === e.</p>

<p>An equality expression of the form e1 !== e2  is equivalent to the expression !(e1 === e2 ). An equality expression of the form  <b>super</b> !== e is equivalent to the expression !(<b>super</b> === e).</p>

<p>The static type of an equality expression of the form e1 === e2 is bool.</p>

<p class="commentary">The static types of other equality expressions follow from the definitions above.  The forms  e1 != e2, e1 !== e2 , <b>super</b> != e and <b>super</b> !== e are negations and have static type bool. The expression e1 == e2 is typed as a method invocation so its static type depends on the operator method declaration. It had better be bool.</p>

</div>

{% endcapture %}

{% include post.html %}
