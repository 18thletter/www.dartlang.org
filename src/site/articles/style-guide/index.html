---
layout: default
title: "Dart Style Guide"
rel:
  author: bob-nystrom
---

<h1>Dart Style Guide</h1>
<em>Written by Bob Nystrom<br />
<time pubdate date="2011-10-27">October 2011</time></em>

<section id="intro">
<p>As we build up an ecosystem of Dart code, it's helpful if it follows a consistent coding style. A dedicated style guide for Dart helps us make the most of the features unique to the language and makes it easier for users to collaborate.</p>
<p>There will likely be things you disagree with in this guide. As the author, there are things <em>I</em> disagree with. I hope you'll agree that consistency is often worth more than our individual preferences.</p>
<p>Keep in mind that, like many things with Dart, this guide isn't carved in stone. As the language evolves and we gain experience with it, our style will evolve too. This means that there will inevitably be code that doesn't follow the latest style, or places where the style guide is ambiguous or open-ended. Bear with us and it will get better as the language and its libraries settle down.</p>

<h4>Contents</h4>
<ol class="toc">
  <li> <a href="#how-to-read">How to read this</a> </li>
  <li> <a href="#types">Types</a> </li>
  <li> <a href="#members">Members</a> </li>
  <li> <a href="#names">Names</a> </li>
  <li> <a href="#comments">Comments</a> </li>
  <li> <a href="#whitespace">Whitespace</a> </li>
</ol>
</section>

<section>
<h2 id="how-to-read">How to read this</h2>
<p>This guide is broken into a couple of sections roughly working from the macro scale down to the micro. Sections contain a list of guidelines. Each one starts with one of four words:</p>

<ul>
<li><p><strong>DO</strong> guidelines describe practices that should always be followed. There will almost never be a valid reason to stray from them.</p></li>
<li><p><strong>DON'T </strong> guidelines are the converse: things that are almost never a good idea. You'll note there are few of these here. Guidelines like these in other languages help to avoid the pitfalls that appear over time. Dart is new enough that we can just fix those pitfalls directly instead of putting up ropes around them.</p></li>
<li><p><strong>CONSIDER</strong> guidelines are practices that you should usually follow but where there may be valid exceptions.</p></li>
<li><p><strong>AVOID</strong> guidelines are the dual to "consider": stuff you shouldn't generally do but where there may be good reasons to on occasion.</p></li>
</ul>

<aside>This sounds like the style police are going to beat down your door if you don't have your laces tied correctly. Things aren't that bad. Most of the guidelines here are common sense and we're all reasonable people. The goal, as always, is nice, readable and maintainable code.</aside>
</section>

<section>
<h2 id="types">Types</h2>

<h4>CONSIDER using using top-level definitions instead of static members.</h4>
<p>In Java and C#, all members must be in a class. In those languages, you occasionally encounter classes that are basically namespaces: just bags of static members. Dart, like Python and JavaScript, doesn't have this limitation. You are free to define variables and functions at the top level.</p>
<p>Name collisions, when they occur, can be avoided by importing a library using a prefix. The advantage to this is that when collisions <em>don't</em> occur (which only the <em>user</em> of a library knows, not the creator), the user doesn't have to fully qualify the name at every callsite.</p>
<p>This doesn't mean you shouldn't have <em>any</em> static members, but it should be rare to create classes that have <em>only</em> static members. Most classes should represent things you can construct.</p>
{% pretty_code dart 0 good %}
num distance(num x1, num y1, num x2, num y2) => ...
{% endpretty_code %}
{% pretty_code dart 0 bad %}
class GeometryUtils {
  num distance(num x1, num y1, num x2, num y2) => ...
}
{% endpretty_code %}

<h4>AVOID defining a one-member interface when a simple function will do.</h4>
<p>Unlike Java, Dart has first-class functions, closures, and a nice light syntax for using them. If all you need is something like a callback, just use a function. If you're defining an interface and it only has a single member with a meaningless name like <code>call</code> or <code>invoke</code>, there is a good chance you just want a function.</p>
{% pretty_code dart 0 good %}
typedef bool Predicate(item);
{% endpretty_code %}
{% pretty_code dart 0 bad %}
interface Predicate {
  bool call(item);
}
{% endpretty_code %}
</section>

<section>
<h2 id="members">Members</h2>

<h4>DO use constructors instead of static methods to create instances.</h4>
<p>Constructors are invoked using <code>new</code> or <code>const</code> which communicates clearly at the callsite that an object is being created. Named constructors and factory constructors in Dart give you all of the flexibility of static methods in other languages, while still allowing the callsite to appear like a regular constructor invocation.</p>
{% pretty_code dart 0 good %}
new Point.zero();
new DateTime.now();
new Address.fromString('123 Main St.');
{% endpretty_code %}
{% pretty_code dart 0 bad %}
Point.zero();
DateTime.now();
Address.fromString('123 Main St.');
{% endpretty_code %}

<h4>DO use a getter for operations that conceptually access a property.</h4>
<p>If the name of the method starts with <code>get</code> or is an adjective like <code>visible</code> or <code>empty</code> that's a sign you're better off using a getter. More specifically, a getter should:</p>
<ul>
  <li><strong>Not take any arguments.</strong></li>
  <li><strong>Return a value.</strong></li>
  <li><strong>Be side-effect free.</strong> Invoking a getter shouldn't change any externally-visible state (caching internally or lazy initialization is OK). Invoking the same getter repeatedly should return the same value unless the object is explicitly changed between calls.</li>
  <li><strong>Be fast.</strong> Users expect expressions like <code>foo.bar</code> to execute quickly.</li>
</ul>
<br/>
{% pretty_code dart 0 good %}
rect.width
collection.isEmpty
button.visible
{% endpretty_code %}
{% pretty_code dart 0 bad %}
collection.sum // may be slow to calculate
DateTime.now   // returns different value each call
window.refresh // doesn't return a value
{% endpretty_code %}

<h4>DO use a setter for operations that conceptually change a property.</h4>
<p>If the name of the method starts with <code>set</code> that's often a sign that it could be a setter. More specifically, a setter should:</p>
<ul>
  <li><strong>Take a single argument.</strong></li>
  <li><strong>Change some state in the object.</strong></li>
  <li><strong>Usually have a corresponding getter.</strong> It feels weird for users to have state that they can modify but not see. (The converse is not true; it's fine to have getters that don't have setters.)</li>
  <li><strong>Be idempotent.</strong> Calling the same setter twice with the same value should do nothing the second time.</li>
  <li><strong>Be fast.</strong> Users expect expressions like <code>foo.bar = value</code> to execute quickly.</li>
</ul>

<br/>
{% pretty_code dart 0 good %}
rect.width = 3;
button.visible = false;
{% endpretty_code %}

<h4>AVOID wrapping fields in getters and setters just to be "safe".</h4>
<p>In Java and C#, it's common to hide all fields behind getters and setters (or properties in C#), even if the implementation just forwards to the field. That way, if you ever need to do more work in those members, you can without needing to touch the callsites. This is because calling a getter method is different than accessing a field in Java, and accessing a property isn't binary-compatible with accessing a raw field in C#.</p>
<p>Dart doesn't have this limitation. Fields and getters/setters are completely indistinguishable. You can expose a field in a class and later wrap it in a getter and setter without having to touch any code that uses that field.</p>
{% pretty_code dart 0 good %}
class Box {
  var contents;
}
{% endpretty_code %}
{% pretty_code dart 0 bad %}
class Box {
  var _contents;
  get contents() => _contents;
  set contents(value) {
    _contents = value;
  }
}
{% endpretty_code %}

<h4>CONSIDER using a public final field instead of a private field with a public getter.</h4>
<p>If you have a field that outside code should be able to see but not assign to (and you don't need to set it outside of the constructor), a simple solution that works in some cases is to just mark it <code>final</code>.</p>
{% pretty_code dart 0 good %}
class Box {
  final contents;
}
{% endpretty_code %}
{% pretty_code dart 0 bad %}
class Box {
  var _contents;
  get contents() => _contents;
}
{% endpretty_code %}

<h4>DO use <code>=&gt;</code> to define members whose body is a single expression that fits on one line.</h4>
<p>In addition to using <code>=&gt;</code> for function expressions, Dart also lets you define members with them. They are a good fit for simple members that just calculate and return a value.</p>
{% pretty_code dart 0 good %}
get width() =&gt; right - left;
bool ready(num time) =&gt; minTime === null || minTime &lt;= time;
containsValue(String value) =&gt; getValues().some((v) =&gt; v == value);
{% endpretty_code %}

<h4>AVOID boolean arguments unless their meaning is completely obvious.</h4>
<p>Unlike other types, booleans are usually used in literal form. Things like numbers are usually wrapped in named constants, but we usually just pass around <code>true</code> and <code>false</code> directly. That can make callsites unreadable if it isn't clear what the boolean represents:</p>

{% pretty_code dart 0 bad %}
new Timer(true);
new Timer(false);
new ListBox(false, true, true);
{% endpretty_code %}

<p>Instead, consider using named arguments, named constructors, or named constants to clarify what the call is doing.</p>

{% pretty_code dart 0 good %}
new Timer.oneShot();
new Timer.repeating();
new ListBox(scroll: SCROLL_BOTH, showScrollbars: true);
{% endpretty_code %}
</section>

<section>
<h2 id="names">Names</h2>

<h4>DO name types using <code>UpperCamelCase</code>.</h4>
<p>Classes, interfaces, and typedefs should capitalize the first letter of each word (including the first word), and use no separators. Abbreviations should be capitalized like words.</p>
{% pretty_code dart 0 good %}
SliderMenu
XmlHttpRequest
{% endpretty_code %}

<h4>DO name other identifiers using <code>lowerCamelCase</code>.</h4>
<p>Class members, top level definitions, variables, parameters, and named parameters, should capitalize the first letter of each word <em>except</em> the first word, and use no separators. Abbreviations should be capitalized like words.</p>
{% pretty_code dart 0 good %}
item
xmlHttpRequest
clearItems
{% endpretty_code %}
</section>

<section>
<h2 id="comments">Comments</h2>

<h4>DO comment members and types using doc-style comments.</h4>
<p>These start with <code>/**</code> and end with <code>*/</code>.</p>
{% pretty_code dart 0 good %}
/**
 * Returns the greater of the two arguments (or the second argument
 * if the two are equal.)
 */
max(a, b) => a > b ? a : b;
{% endpretty_code %}

<h4>CONSIDER using a single-line Dart-doc comment if the comment is short enough.</h4>
{% pretty_code dart 0 good %}
/** Returns the greater of the two arguments. */
max(a, b) => a > b ? a : b;
{% endpretty_code %}

<h4>DO use line comments for everything else.</h4>
{% pretty_code dart 0 good %}
greet(name) {
  // Assume we have a valid name.
  print('Hi, $name!');
}
{% endpretty_code %}
{% pretty_code dart 0 bad %}
greet(name) {
  /* Assume we have a valid name. */
  print('Hi, $name!');
}
{% endpretty_code %}

<h4>DO capitalize and punctuate comments like sentences.</h4>
<p>This doesn't mean that the comment must always be a complete sentence, though it usually should. "Returns the number of items." is an acceptable comment.</p>
{% pretty_code dart 0 good %}
// Remove the last item from the collection.
{% endpretty_code %}
{% pretty_code dart 0 bad %}
// remove the last item from the collection
{% endpretty_code %}

<h4>DO use square brackets in doc comments for identifiers that are in scope.</h4>
<p>If you surround things like variable, method or type names in square brackets, then documentation generators can look up the name and cross-link the two together.</p>
{% pretty_code dart 0 good %}
/* Rolls both [Dice] and returns the highest rolled value. */
num greatestRoll(Dice a, Dice b) => Math.max(a.roll(), b.roll());
{% endpretty_code %}

<h4>DO use <code>[: ... :]</code> for code in doc comments.</h4>
<p>Document generators will parse comments surrounded by square brackets and colons and format them as source code.</p>
{% pretty_code dart 0 good %}
/**
 * Compares each pairwise element in the lists using
 * [:equals(expectedElement, actualElement):]. */
listEquals(List expected, List actual) {
  ...
}
{% endpretty_code %}
</section>

<section>
<h2 id="whitespace">Whitespace</h2>

<p>Like many languages, Dart ignores whitespace. However, <em>humans</em> don't. Having a consistent whitespace style helps ensure that human readers see code the same way the compiler does.</p>

<h4>DON'T use tabs.</h4>
<p>Using spaces for formatting ensures the code looks the same in everyone's editor. It also makes sure it looks the same when posted to blogs, or on code sites like <a href="http://code.google.com/projecthosting/">Google Code</a> or <a href="http://github.com">github</a>.</p>
<p>You may complain that spaces take more effort to type. If that's the case, I encourage you to pause your 8-track player, put on your parachute pants and go out and find a modern text editor that makes spaces as easy to work with as tabs.</p>

<h4>AVOID lines longer than 80 characters.</h4>
<p>Readability studies show that long lines of text are harder to read because your eye has to travel farther when moving to the beginning of the next line. This is why newspapers and magazines use multiple columns of text.</p>
<p>If you really find yourself wanting lines longer than 80 characters, our experience is that your code is likely too verbose and could be a little more compact. Do you really need to call that class <code>AbstractWidgetFactoryManagerBuilder</code>?</p>

<h4>DO indent blocks with two spaces.</h4>
{% pretty_code dart 0 good %}
if (condition) {
  print('hi');
}
{% endpretty_code %}

<h4>DO indent continued lines with four spaces.</h4>
{% pretty_code dart 0 good %}
someLongObject.aReallyLongMethodName(longArg, anotherLongArg,
    wrappedToNextLine);
{% endpretty_code %}

<p>The one exception to this is function expressions used within larger expressions, like being passed to methods. These are formatted like so:
{% pretty_code dart 0 good %}
window.setTimeout(() {
  print('I am a callback');
});
{% endpretty_code %}

<h4>DO place the opening curly brace (<code>{</code>) on the same line as what it follows.</h4>
{% pretty_code dart 0 good %}
class Foo {
  method() {
    if (true) {
      ...
    } else {
      ...
    }
  }
}
{% endpretty_code %}

<h4>DO use curly braces for all flow control structures.</h4>
<p>Doing so avoids the <a href="http://en.wikipedia.org/wiki/Dangling_else">dangling else</a> problem.</p>
{% pretty_code dart 0 good %}
if (true) {
  print('sanity');
} else {
  print('opposite day!');
}
{% endpretty_code %}
{% pretty_code dart 0 bad %}
if (true) print('sanity');
else
  print('opposite day!');
{% endpretty_code %}
<p>There is one exception to this: short <code>if</code> statements with no <code>else</code> clause that fit on one line may omit the braces.</p>
{% pretty_code dart 0 good %}
if (arg == null) return defaultValue;
{% endpretty_code %}

<h4>DO use spaces around binary and ternary operators, after commas, and not around unary operators.</h4>

<p>Note that <code>&lt;</code> and <code>&gt;</code> are considered binary operators when used as expressions, but not for specifying generic types. The <code>.</code> used to access members should not have spaces around it.</p>
{% pretty_code dart 0 good %}
a = 1 + 2 / (3 * -b);
c = !condition == a > b;
d = a ? b : object.method(a, b, c);
{% endpretty_code %}
{% pretty_code dart 0 bad %}
a=1+2/(3* - b);
c= ! condition==a>b;
d= a?b:object.method(a,b,c);
{% endpretty_code %}

<h4>DO place spaces around <code>in</code>, or after each <code>;</code> in a loop.</h4>
{% pretty_code dart 0 good %}
for (var i = 0; i < 100; i++)
for (final item in collection)
{% endpretty_code %}

<h4>DON'T use a space after <code>(</code> and <code>[</code>, or before <code>)</code> and <code>]</code>.</h4>
<p>Also, do not use a space when using <code>&lt;</code> and <code>&gt;</code> for generic types.</p>
{% pretty_code dart 0 good %}
&lt;int&gt;[1, 2, (3 + 4)]
{% endpretty_code %}

<h4>DO use a space after flow-control keywords.</h4>
<p>This is unlike function and method calls which do <em>not</em> have a space between the name and the opening parenthesis.</p>
{% pretty_code dart 0 good %}
while (foo) {
  ...
}

try {
  ...
}
{% endpretty_code %}
</section>

{% include syntax-highlighting.html %}
