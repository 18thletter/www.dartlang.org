---
layout: default
title: "Spirodraw Sample"
---
<link href="/css/style.css" type="text/css" rel="stylesheet"/>
<link href="/css/prettify.css" type="text/css" rel="stylesheet"/>
<script type="text/javascript" src="/js/prettify.js"></script>

<body onLoad="prettyPrint()">
<div id="containers">
<p>The Spirodraw sample is similar to Sunflower and illustrates a few more language features.</p>

<ul>
<li><a href="#code_organization">Code organization</a></li>
<li><a href="#requestAnimationFrame">RequestAnimationFrame</a></li>
<li><a href="#top_level_functions">Top-level functions</a></li>
<li><a href="#color_picker">ColorPicker sample</a></li>
<li><a href="#typedef">Function type aliases</a></li>
<li><a href="#type_inference">Type inference</a></li>
<li><a href="#initializers">Constructor initializers</a></li>
<li><a href="#terse_function_syntax">Terse function syntax</a></li>
<li><a href="#for-in">For-in statement</a></li>
<li><a href="#string_interpolation">String interpolation</a></li>
</ul>

<h2 id="code_organization">Code organization</h2>
<p>First, let's take a look at the Spirodraw declarations.</p>

<pre class="prettyprint lang-dart linenums">
#library('spirodraw');

#import('dart:dom');
#source("ColorPicker.dart");
#resource("spirodraw.css");</pre>

<p>A Dart script belongs to a libary declared with a name given by the #library directive.
Dart scripts include other scripts using the #source directive and include other libraries
with the #import directive. The #resource directive is currently not used. In the future,
it may be used to bundle non-code resources with libraries. The arguments #import, 
#source, and #resource are URLs.</p>

<p>Spirodraw.dart defines a library named 'spirodraw', which includes Spirodraw.dart,
ColorPicker.dart, and the built-in Dart DOM library. For more on libraries, see also the 
Total sample.</p>

<h2 id="requestAnimationFrame">RequestAnimationFrame</h2>
<p>Spirodraw uses <a href="http://www.html5rocks.com/en/tutorials/canvas/performance/#toc-raf">requestAnimationFrame</a>
to improve rendering.</p>

<pre class="prettyprint lang-dart linenums">
  void start() {
    refresh();
    rad = 0.0;
    run = true;
    window.webkitRequestAnimationFrame((int time) {animate(time);}, frontCanvas);
  }
  
  void animate(int time) {
    if (run && rad <= maxTurns * PI2) {
      rad+=stepSize;
      drawFrame(rad);
      num nTurns = rad / PI2;
      numTurns.innerText = nTurns.floor().toString() + "/" 
        + maxTurns.toString();
      window.webkitRequestAnimationFrame(animate, frontCanvas);
    } else {
      stop();
    }
  }</pre>

<p>In the code excerpt above, line 5 invokes webkitRequestAnimationFrame with a closure containing
the callback function, <em>animate</em>. The animate function in turn requests the next
animation frame, passing itself as the callback using the shortcut syntax available when
a function invokes itself.</p>

<h2 id="top_level_functions">Top-level functions</h2>
<p>In Dart, a function does not have to be associated with a class.</p>

<pre class="prettyprint lang-dart linenums">
...
void main() {
  new Spirodraw().go();
}

class Spirodraw {
  ...
  int calcTurns() {
    // compute ratio of wheel radius to big R then find LCM
    if ((dUnits==0) || (rUnits==0))
      return 1;
    int ru = rUnits.abs();
    int wrUnits = RUnits + rUnits;
    int g = gcf (wrUnits, ru);
    return ru ~/ g;
  }
  ...
}

int gcf(int n, int d) {
  if (n==d)
    return n;
  int max = Math.max(n, d);
  for (int i = max ~/ 2; i > 1; i--)
    if ((n % i == 0) && (d % i == 0))
      return i;
  return 1;
}</pre>

<p>In this example, note that the gcf function is defined outside the Spirodraw class and is
invoked statically within the calcTurns() function. The main function is likewise defined 
outside the Spirodraw class. In Dart, variables can also be top-level.</p>

<h2 id="color_picker">ColorPicker sample</h2>
<p>Now let's look at ColorPicker.dart.</p>

<pre class="prettyprint lang-dart linenums">
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

typedef void PickerListener(String selectedColor);

class ColorPicker {

  static final List hexValues = ["00", "33", "66", "99", "CC", "FF"];
  static final int COLS = 18;
  // Block height, width, padding
  static final int BH = 10;
  static final int BW = 10;
  static final int BP = 1;
  final List<PickerListener> _listeners;
  HTMLCanvasElement canvasElement;
  String _selectedColor = 'red';
  final int height = 160;
  final int width = 180;
  CanvasRenderingContext2D ctx;
  
  ColorPicker(this.canvasElement) :
    _listeners = []
  {
    ctx = canvasElement.getContext("2d");
    drawPalette();
    addHandlers();
    showSelected();
  }
  
  String get selectedColor() => _selectedColor;
  
  void onMouseMove(MouseEvent event) {
    int x = event.offsetX;
    int y = event.offsetY - 40;
    if (( y &lt; 0) || (x &gt;= width)) {
      return;
    }
    ctx.setFillStyle(getHexString(getColorIndex(x, y)));
    ctx.fillRect(0, 0, width/2, 30);
  }

  void onMouseDown(MouseEvent event) {
    Element elt = event.target;
    event.cancelBubble = true;
    int x = event.offsetX;
    int y = event.offsetY - 40;
    if ((y &lt; 0) || (x &gt;= width))
      return;
    setSelected(getColorIndex(x, y));
    fireSelected();
  }

  /**
   * Adds a [PickerListener] to receive updates.
   */
  void addListener(PickerListener listener) {
    _listeners.add(listener);
  }

  void addHandlers() {
    canvasElement.onmousemove = (e) { onMouseMove(e); };
    canvasElement.onmousedown = (e) { onMouseDown(e); };
  }

   void drawPalette() {
    int i=0;
    for (int r=0; r &lt; 256; r+=51) {
      for (int g=0; g &lt; 256; g+=51) {
        for (int b=0; b &lt; 256; b+=51) {
          String color = getHexString(i);
          ctx.setFillStyle(color);
          int x = BW * (i % COLS);
          int y = BH * (i ~/ COLS) + 40;
          ctx.fillRect(x + BP, y + BP, BW - 2 * BP, BH - 2 * BP);
          i++;
        }
      }
    }
  }

  void fireSelected() {
    for (final listener in _listeners) {
      listener(_selectedColor);
    }
  }

  int getColorIndex(int x, int y) {
    // Get color index 0-215 using row, col
    int i = y ~/ BH * COLS + x ~/ BW;
    return i;
  }

  void showSelected() {
    ctx.setFillStyle(_selectedColor);
    ctx.fillRect(width / 2, 0, width / 2, 30);
    ctx.setFillStyle("white");
    ctx.fillRect(0, 0, width / 2, 30);
  }
  
  void setSelected(num i) {
    _selectedColor = getHexString(i.floor());
    showSelected();
    fireSelected();
  }
 
  String getHexString(int i) {
    int r = i ~/ 36;
    int g = (i % 36) ~/ 6;
    int b = i % 6;
    return '#${hexValues[r]}${hexValues[g]}${hexValues[b]}';
  }
  
}</pre>

<h2 id="typedef">Function type aliases</h2>

<p>In Dart, functions are objects just as strings and numbers. To declare the type of a variable
or return type that references a function, you use a function type alias, or typedef.</p>

<p>In the example above, the typedef statement in line 5 declares a function type 
PickerListener that takes a String argument and returns void. Lines 57-59 add a function of 
type PickerListener to a List, and lines 82-83 iterate over the List to invoke each function.</p>

<p>Function type aliases offer a compact way to represent any type of callback.</p>

<h2 id="type_inference">Type inference</h2>
<p>Dart is an optionally typed language and types can often be inferred. For example,
line 9 initializes a List of strings, but the variable is declared only as List, not 
List&lt;String&gt;, because the type can be inferred from the string literals.</p>

<h2 id="initializers">Constructor initializers</h2>
<p>Often constructor arguments are used to initialize instance fields. To avoid repetitive 
this.name = name initializers, Dart allows you to write this.name in the constructor instead 
of the argument name. See the ColorPicker constructor in line 22 for an example. Also, Dart 
lets you write an initializer list in the constructor as shown in line 23. Initializers are 
executed before the instance is constructed.</p>

<h2 id="terse_function_syntax">Terse function syntax</h2>
<p>Functions that contain a single line in the body can be declared in a compact one-line 
syntax using =&gt; as shown in line 31. Note also the definition of an explicit getter. When
you define a getter or setter function this way, Dart will automatically invoke the getter
or setter when you reference a variable having the same name as the getter/setter. By 
convention, the actual variable name is prefixed with an underscore to distinguish it from
the getter/setter name.</p>

<h2 id="for-in">For-in statement</h2>
<p>Lines 81-84 show a for-in loop, which iterates over any object that implements
the Iterable interface.</p>

<h2 id="string_interpolation">String interpolation</h2>
<p>Our last bit of syntactic sugar in this example is string interpolation. As shown in line 
111, you can evaluate variables in a string literal using $<em>identifier</em> or 
${<em>identifier</em>}. This syntax offers a shortcut for string concatenation using the
+ operator.
 </p>
</div>
</body>
